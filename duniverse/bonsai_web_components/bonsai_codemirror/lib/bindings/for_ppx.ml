[@@@js.dummy "!! This code has been generated by gen_js_api !!"]
[@@@ocaml.warning "-7-32-39"]

open! Js_of_ocaml
open! Gen_js_api
open Custom_ojs_converter

module Promise = struct
  type ('a, 'e) t = Ojs.t

  let rec t_of_js : 'a 'e. (Ojs.t -> 'a) -> (Ojs.t -> 'e) -> Ojs.t -> ('a, 'e) t =
    fun (type __a __e) (__a_of_js : Ojs.t -> __a) (__e_of_js : Ojs.t -> __e) (x2 : Ojs.t) ->
    x2

  and t_to_js : 'a 'e. ('a -> Ojs.t) -> ('e -> Ojs.t) -> ('a, 'e) t -> Ojs.t =
    fun (type __a __e) (__a_to_js : __a -> Ojs.t) (__e_to_js : __e -> Ojs.t) (x1 : Ojs.t) ->
    x1
  ;;

  let create : (('a -> unit) -> ('e -> unit) -> unit) -> ('a, 'e) t =
    fun (x3 : ('a -> unit) -> ('e -> unit) -> unit) ->
    t_of_js
      Obj.magic
      Obj.magic
      (Ojs.new_obj
         (Ojs.get_prop_ascii Ojs.global "Promise")
         [| Ojs.fun_to_js 2 (fun (x4 : Ojs.t) (x6 : Ojs.t) ->
              x3
                (fun (x5 : 'a) -> (ignore : _) (Ojs.apply x4 [| Obj.magic x5 |]))
                (fun (x7 : 'e) -> (ignore : _) (Ojs.apply x6 [| Obj.magic x7 |])))
         |])
  ;;
end

module RegExp = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x11 : Ojs.t) -> x11
  and t_to_js : t -> Ojs.t = fun (x10 : Ojs.t) -> x10

  let create : string -> string option -> t =
    fun (x12 : string) (x13 : string option) ->
    t_of_js
      (Ojs.new_obj
         (Ojs.get_prop_ascii Ojs.global "RegExp")
         [| Ojs.string_to_js x12; Ojs.option_to_js Ojs.string_to_js x13 |])
  ;;
end

module Text = struct
  module Line = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x16 : Ojs.t) -> x16
    and t_to_js : t -> Ojs.t = fun (x15 : Ojs.t) -> x15

    let from : t -> int =
      fun (x17 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x17) "from")
    ;;

    let to_ : t -> int =
      fun (x18 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x18) "to")
    ;;

    let number : t -> int =
      fun (x19 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x19) "number")
    ;;

    let text : t -> string =
      fun (x20 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x20) "text")
    ;;

    let length : t -> int =
      fun (x21 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x21) "length")
    ;;
  end

  module Text_iterator = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x23 : Ojs.t) -> x23
    and t_to_js : t -> Ojs.t = fun (x22 : Ojs.t) -> x22

    let next : t -> ?skip:int -> unit -> t =
      fun (x27 : t) ?skip:(x24 : int option) () ->
      t_of_js
        (let x28 = t_to_js x27 in
         Ojs.call
           (Ojs.get_prop_ascii x28 "next")
           "apply"
           [| x28
            ; (let x25 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x24 with
                | Some x26 -> (ignore : _) (Ojs.call x25 "push" [| Ojs.int_to_js x26 |])
                | None -> ());
               x25)
           |])
    ;;

    let value : t -> string =
      fun (x29 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x29) "value")
    ;;

    let done_ : t -> bool =
      fun (x30 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x30) "done")
    ;;

    let line_break : t -> bool =
      fun (x31 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x31) "lineBreak")
    ;;
  end

  module Text = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x33 : Ojs.t) -> x33
    and t_to_js : t -> Ojs.t = fun (x32 : Ojs.t) -> x32

    let length : t -> int =
      fun (x34 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x34) "length")
    ;;

    let lines : t -> int =
      fun (x35 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x35) "lines")
    ;;

    let line_at : t -> int -> Line.t =
      fun (x37 : t) (x36 : int) ->
      Line.t_of_js (Ojs.call (t_to_js x37) "lineAt" [| Ojs.int_to_js x36 |])
    ;;

    let line : t -> int -> Line.t =
      fun (x39 : t) (x38 : int) ->
      Line.t_of_js (Ojs.call (t_to_js x39) "line" [| Ojs.int_to_js x38 |])
    ;;

    let replace : t -> from:int -> to_:int -> with_:t -> t =
      fun (x43 : t) ~from:(x40 : int) ~to_:(x41 : int) ~with_:(x42 : t) ->
      t_of_js
        (Ojs.call
           (t_to_js x43)
           "replace"
           [| Ojs.int_to_js x40; Ojs.int_to_js x41; t_to_js x42 |])
    ;;

    let append : t -> t -> t =
      fun (x45 : t) (x44 : t) ->
      t_of_js (Ojs.call (t_to_js x45) "append" [| t_to_js x44 |])
    ;;

    let slice : t -> from:int -> ?to_:int -> unit -> t =
      fun (x50 : t) ~from:(x46 : int) ?to_:(x47 : int option) () ->
      t_of_js
        (let x51 = t_to_js x50 in
         Ojs.call
           (Ojs.get_prop_ascii x51 "slice")
           "apply"
           [| x51
            ; (let x48 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x48 "push" [| Ojs.int_to_js x46 |]);
               (match x47 with
                | Some x49 -> (ignore : _) (Ojs.call x48 "push" [| Ojs.int_to_js x49 |])
                | None -> ());
               x48)
           |])
    ;;

    let slice_string : t -> from:int -> ?to_:int -> ?line_sep:string -> unit -> string =
      fun (x58 : t)
        ~from:(x52 : int)
        ?to_:(x53 : int option)
        ?line_sep:(x54 : string option)
        () ->
      Ojs.string_of_js
        (let x59 = t_to_js x58 in
         Ojs.call
           (Ojs.get_prop_ascii x59 "sliceString")
           "apply"
           [| x59
            ; (let x55 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x55 "push" [| Ojs.int_to_js x52 |]);
               (match x53 with
                | Some x57 -> (ignore : _) (Ojs.call x55 "push" [| Ojs.int_to_js x57 |])
                | None -> ());
               (match x54 with
                | Some x56 ->
                  (ignore : _) (Ojs.call x55 "push" [| Ojs.string_to_js x56 |])
                | None -> ());
               x55)
           |])
    ;;

    let equal : t -> t -> bool =
      fun (x61 : t) (x60 : t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x61) "eq" [| t_to_js x60 |])
    ;;

    let iter : t -> ?dir:int -> unit -> Text_iterator.t =
      fun (x65 : t) ?dir:(x62 : int option) () ->
      Text_iterator.t_of_js
        (let x66 = t_to_js x65 in
         Ojs.call
           (Ojs.get_prop_ascii x66 "iter")
           "apply"
           [| x66
            ; (let x63 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x62 with
                | Some x64 -> (ignore : _) (Ojs.call x63 "push" [| Ojs.int_to_js x64 |])
                | None -> ());
               x63)
           |])
    ;;

    let iter_range : t -> from:int -> ?to_:int -> unit -> Text_iterator.t =
      fun (x71 : t) ~from:(x67 : int) ?to_:(x68 : int option) () ->
      Text_iterator.t_of_js
        (let x72 = t_to_js x71 in
         Ojs.call
           (Ojs.get_prop_ascii x72 "iterRange")
           "apply"
           [| x72
            ; (let x69 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x69 "push" [| Ojs.int_to_js x67 |]);
               (match x68 with
                | Some x70 -> (ignore : _) (Ojs.call x69 "push" [| Ojs.int_to_js x70 |])
                | None -> ());
               x69)
           |])
    ;;

    let iter_lines : t -> ?from:int -> ?to_:int -> unit -> Text_iterator.t =
      fun (x78 : t) ?from:(x73 : int option) ?to_:(x74 : int option) () ->
      Text_iterator.t_of_js
        (let x79 = t_to_js x78 in
         Ojs.call
           (Ojs.get_prop_ascii x79 "iterLines")
           "apply"
           [| x79
            ; (let x75 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x73 with
                | Some x77 -> (ignore : _) (Ojs.call x75 "push" [| Ojs.int_to_js x77 |])
                | None -> ());
               (match x74 with
                | Some x76 -> (ignore : _) (Ojs.call x75 "push" [| Ojs.int_to_js x76 |])
                | None -> ());
               x75)
           |])
    ;;

    let to_json : t -> string list =
      fun (x80 : t) ->
      Ojs.list_of_js Ojs.string_of_js (Ojs.call (t_to_js x80) "toJSON" [||])
    ;;

    let of_ : string list -> t =
      fun (x82 : string list) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Text")
           "of"
           [| Ojs.list_to_js Ojs.string_to_js x82 |])
    ;;

    let of_array : string array -> t =
      fun (x84 : string array) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Text")
           "of"
           [| Ojs.array_to_js Ojs.string_to_js x84 |])
    ;;

    let empty : t =
      t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Text")
           "empty")
    ;;
  end

  let count_column : string -> n:int -> tab_size:int -> int =
    fun (x88 : string) ~n:(x86 : int) ~tab_size:(x87 : int) ->
    Ojs.int_of_js
      (Ojs.call
         (Ojs.string_to_js x88)
         "countColumn"
         [| Ojs.int_to_js x86; Ojs.int_to_js x87 |])
  ;;

  module Offset_and_left_over = struct
    type t =
      { offset : int
      ; left_over : int
      }

    let rec t_of_js : Ojs.t -> t =
      fun (x90 : Ojs.t) ->
      { offset = Ojs.int_of_js (Ojs.get_prop_ascii x90 "offset")
      ; left_over = Ojs.int_of_js (Ojs.get_prop_ascii x90 "leftOver")
      }

    and t_to_js : t -> Ojs.t =
      fun (x89 : t) ->
      Ojs.obj
        [| "offset", Ojs.int_to_js x89.offset; "leftOver", Ojs.int_to_js x89.left_over |]
    ;;
  end

  let find_column : string -> n:int -> col:int -> tab_size:int -> Offset_and_left_over.t =
    fun (x94 : string) ~n:(x91 : int) ~col:(x92 : int) ~tab_size:(x93 : int) ->
    Offset_and_left_over.t_of_js
      (Ojs.call
         (Ojs.string_to_js x94)
         "findColumn"
         [| Ojs.int_to_js x91; Ojs.int_to_js x92; Ojs.int_to_js x93 |])
  ;;

  let code_point_at : string -> int -> int =
    fun (x96 : string) (x95 : int) ->
    Ojs.int_of_js (Ojs.call (Ojs.string_to_js x96) "codePointAt" [| Ojs.int_to_js x95 |])
  ;;

  let from_code_point : int -> string =
    fun (x97 : int) ->
    Ojs.string_of_js (Ojs.call (Ojs.int_to_js x97) "fromCodePoint" [||])
  ;;

  let code_point_size : int -> int =
    fun (x98 : int) -> Ojs.int_of_js (Ojs.call (Ojs.int_to_js x98) "codePointSize" [||])
  ;;

  let find_cluster_break : string -> int -> ?forward:bool -> unit -> int =
    fun (x103 : string) (x99 : int) ?forward:(x100 : bool option) () ->
    Ojs.int_of_js
      (let x104 = Ojs.string_to_js x103 in
       Ojs.call
         (Ojs.get_prop_ascii x104 "findClusterBreak")
         "apply"
         [| x104
          ; (let x101 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (ignore : _) (Ojs.call x101 "push" [| Ojs.int_to_js x99 |]);
             (match x100 with
              | Some x102 -> (ignore : _) (Ojs.call x101 "push" [| Ojs.bool_to_js x102 |])
              | None -> ());
             x101)
         |])
  ;;
end

module State = struct
  module Extension = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x106 : Ojs.t) -> x106
    and t_to_js : t -> Ojs.t = fun (x105 : Ojs.t) -> x105

    let of_list : t list -> t =
      fun (x107 : t list) -> t_of_js (Ojs.list_to_js t_to_js x107)
    ;;
  end

  module Editor_state_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x110 : Ojs.t) -> x110
    and t_to_js : t -> Ojs.t = fun (x109 : Ojs.t) -> x109

    let create : ?doc:string -> ?extensions:Extension.t list -> unit -> t =
      fun ?doc:(x111 : string option) ?extensions:(x112 : Extension.t list option) () ->
      let x113 = Ojs.empty_obj () in
      (match x111 with
       | Some x116 -> Ojs.set_prop_ascii x113 "doc" (Ojs.string_to_js x116)
       | None -> ());
      (match x112 with
       | Some x114 ->
         Ojs.set_prop_ascii x113 "extensions" (Ojs.list_to_js Extension.t_to_js x114)
       | None -> ());
      t_of_js x113
    ;;
  end

  type state_effect = Ojs.t

  let rec state_effect_of_js : Ojs.t -> state_effect = fun (x118 : Ojs.t) -> x118
  and state_effect_to_js : state_effect -> Ojs.t = fun (x117 : Ojs.t) -> x117

  module State_effect_type = struct
    type 'a t = Ojs.t

    let rec t_of_js : 'a. (Ojs.t -> 'a) -> Ojs.t -> 'a t =
      fun (type __a) (__a_of_js : Ojs.t -> __a) (x120 : Ojs.t) -> x120

    and t_to_js : 'a. ('a -> Ojs.t) -> 'a t -> Ojs.t =
      fun (type __a) (__a_to_js : __a -> Ojs.t) (x119 : Ojs.t) -> x119
    ;;

    let of_ : 'a t -> 'a -> state_effect =
      fun (x122 : 'a t) (x121 : 'a) ->
      state_effect_of_js (Ojs.call (t_to_js Obj.magic x122) "of" [| Obj.magic x121 |])
    ;;
  end

  module State_effect = struct
    type t = state_effect

    let rec t_of_js : Ojs.t -> t = fun (x125 : Ojs.t) -> state_effect_of_js x125
    and t_to_js : t -> Ojs.t = fun (x124 : state_effect) -> state_effect_to_js x124

    let value : t -> 'a =
      fun (x126 : t) -> Obj.magic (Ojs.get_prop_ascii (t_to_js x126) "value")
    ;;

    let is : t -> type_:'a State_effect_type.t -> bool =
      fun (x129 : t) ~type_:(x127 : 'a State_effect_type.t) ->
      Ojs.bool_of_js
        (Ojs.call (t_to_js x129) "is" [| State_effect_type.t_to_js Obj.magic x127 |])
    ;;

    let define : unit -> 'a State_effect_type.t =
      fun () ->
      State_effect_type.t_of_js
        Obj.magic
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "StateEffect")
           "define"
           [||])
    ;;

    let reconfigure : Extension.t State_effect_type.t =
      State_effect_type.t_of_js
        Extension.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "StateEffect")
           "reconfigure")
    ;;
  end

  module Annotation = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x133 : Ojs.t) -> x133
    and t_to_js : t -> Ojs.t = fun (x132 : Ojs.t) -> x132
  end

  module Effects_and_annotation = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x135 : Ojs.t) -> x135
    and t_to_js : t -> Ojs.t = fun (x134 : Ojs.t) -> x134

    let create
      : ?effects:State_effect.t list -> ?annotations:Annotation.t list -> unit -> t
      =
      fun ?effects:(x136 : State_effect.t list option)
        ?annotations:(x137 : Annotation.t list option)
        () ->
      let x138 = Ojs.empty_obj () in
      (match x136 with
       | Some x141 ->
         Ojs.set_prop_ascii x138 "effects" (Ojs.list_to_js State_effect.t_to_js x141)
       | None -> ());
      (match x137 with
       | Some x139 ->
         Ojs.set_prop_ascii x138 "annotations" (Ojs.list_to_js Annotation.t_to_js x139)
       | None -> ());
      t_of_js x138
    ;;
  end

  type change_set = Ojs.t

  let rec change_set_of_js : Ojs.t -> change_set = fun (x144 : Ojs.t) -> x144
  and change_set_to_js : change_set -> Ojs.t = fun (x143 : Ojs.t) -> x143

  module Change_spec = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x146 : Ojs.t) -> x146
    and t_to_js : t -> Ojs.t = fun (x145 : Ojs.t) -> x145

    let single : ?from:int -> ?to_:int -> ?insert:Text.Text.t -> unit -> t =
      fun ?from:(x147 : int option)
        ?to_:(x148 : int option)
        ?insert:(x149 : Text.Text.t option)
        () ->
      let x150 = Ojs.empty_obj () in
      (match x147 with
       | Some x153 -> Ojs.set_prop_ascii x150 "from" (Ojs.int_to_js x153)
       | None -> ());
      (match x148 with
       | Some x152 -> Ojs.set_prop_ascii x150 "to" (Ojs.int_to_js x152)
       | None -> ());
      (match x149 with
       | Some x151 -> Ojs.set_prop_ascii x150 "insert" (Text.Text.t_to_js x151)
       | None -> ());
      t_of_js x150
    ;;

    let change_set : change_set -> t =
      fun (x154 : change_set) -> t_of_js (change_set_to_js x154)
    ;;

    let many : t list -> t = fun (x155 : t list) -> t_of_js (Ojs.list_to_js t_to_js x155)
  end

  module Map_mode = struct
    type t =
      | Simple
      | TrackDel
      | TrackBefore
      | TrackAfter

    let rec t_of_js : Ojs.t -> t =
      fun (x158 : Ojs.t) ->
      let x159 = x158 in
      match Ojs.string_of_js x159 with
      | "Simple" -> Simple
      | "TrackDel" -> TrackDel
      | "TrackBefore" -> TrackBefore
      | "TrackAfter" -> TrackAfter
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x157 : t) ->
      match x157 with
      | Simple -> Ojs.string_to_js "Simple"
      | TrackDel -> Ojs.string_to_js "TrackDel"
      | TrackBefore -> Ojs.string_to_js "TrackBefore"
      | TrackAfter -> Ojs.string_to_js "TrackAfter"
    ;;
  end

  module Cursor_association = struct
    type t =
      | Left
      | None
      | Right

    let rec t_of_js : Ojs.t -> t =
      fun (x161 : Ojs.t) ->
      let x162 = x161 in
      match Ojs.int_of_js x162 with
      | -1 -> Left
      | 0 -> None
      | 1 -> Right
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x160 : t) ->
      match x160 with
      | Left -> Ojs.int_to_js (-1)
      | None -> Ojs.int_to_js 0
      | Right -> Ojs.int_to_js 1
    ;;
  end

  module Touches_range = struct
    type t =
      | True
      | False
      | Cover

    let rec t_of_js : Ojs.t -> t =
      fun (x164 : Ojs.t) ->
      let x165 = x164 in
      match Ojs.type_of x165 with
      | "string" ->
        (match Ojs.string_of_js x165 with
         | "cover" -> Cover
         | _ -> assert false)
      | "boolean" ->
        (match Ojs.bool_of_js x165 with
         | true -> True
         | false -> False)
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x163 : t) ->
      match x163 with
      | True -> Ojs.bool_to_js true
      | False -> Ojs.bool_to_js false
      | Cover -> Ojs.string_to_js "cover"
    ;;
  end

  module Change_desc = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x167 : Ojs.t) -> x167
    and t_to_js : t -> Ojs.t = fun (x166 : Ojs.t) -> x166

    let length : t -> int =
      fun (x168 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x168) "length")
    ;;

    let new_length : t -> int =
      fun (x169 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x169) "newLength")
    ;;

    let empty : t -> bool =
      fun (x170 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x170) "empty")
    ;;

    let iter_gaps : t -> f:(a:int -> b:int -> length:int -> unit) -> unit =
      fun (x175 : t) ~f:(x171 : a:int -> b:int -> length:int -> unit) ->
      (ignore : _)
        (Ojs.call
           (t_to_js x175)
           "iterGaps"
           [| Ojs.fun_to_js 3 (fun (x172 : Ojs.t) (x173 : Ojs.t) (x174 : Ojs.t) ->
                x171
                  ~a:(Ojs.int_of_js x172)
                  ~b:(Ojs.int_of_js x173)
                  ~length:(Ojs.int_of_js x174))
           |])
    ;;

    let iter_changed_ranges
      : t -> f:(from_a:int -> to_a:int -> from_b:int -> to_b:int -> unit) -> unit
      =
      fun (x181 : t) ~f:(x176 : from_a:int -> to_a:int -> from_b:int -> to_b:int -> unit) ->
      (ignore : _)
        (Ojs.call
           (t_to_js x181)
           "iterChangedRanges"
           [| Ojs.fun_to_js
                4
                (fun (x177 : Ojs.t) (x178 : Ojs.t) (x179 : Ojs.t) (x180 : Ojs.t) ->
                   x176
                     ~from_a:(Ojs.int_of_js x177)
                     ~to_a:(Ojs.int_of_js x178)
                     ~from_b:(Ojs.int_of_js x179)
                     ~to_b:(Ojs.int_of_js x180))
           |])
    ;;

    let inverted_desc : t -> t =
      fun (x182 : t) -> t_of_js (Ojs.get_prop_ascii (t_to_js x182) "invertedDesc")
    ;;

    let compose_desc : t -> t -> t =
      fun (x184 : t) (x183 : t) ->
      t_of_js (Ojs.call (t_to_js x184) "composeDesc" [| t_to_js x183 |])
    ;;

    let map_desc : t -> t -> ?before:bool -> unit -> t =
      fun (x189 : t) (x185 : t) ?before:(x186 : bool option) () ->
      t_of_js
        (let x190 = t_to_js x189 in
         Ojs.call
           (Ojs.get_prop_ascii x190 "mapDesc")
           "apply"
           [| x190
            ; (let x187 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x187 "push" [| t_to_js x185 |]);
               (match x186 with
                | Some x188 ->
                  (ignore : _) (Ojs.call x187 "push" [| Ojs.bool_to_js x188 |])
                | None -> ());
               x187)
           |])
    ;;

    let map_pos : t -> int -> assoc:Cursor_association.t -> mode:Map_mode.t -> t =
      fun (x194 : t)
        (x191 : int)
        ~assoc:(x192 : Cursor_association.t)
        ~mode:(x193 : Map_mode.t) ->
      t_of_js
        (Ojs.call
           (t_to_js x194)
           "mapPos"
           [| Ojs.int_to_js x191
            ; Cursor_association.t_to_js x192
            ; Map_mode.t_to_js x193
           |])
    ;;

    let touches_range : t -> from:int -> ?to_:int -> unit -> Touches_range.t =
      fun (x199 : t) ~from:(x195 : int) ?to_:(x196 : int option) () ->
      Touches_range.t_of_js
        (let x200 = t_to_js x199 in
         Ojs.call
           (Ojs.get_prop_ascii x200 "touchesRange")
           "apply"
           [| x200
            ; (let x197 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x197 "push" [| Ojs.int_to_js x195 |]);
               (match x196 with
                | Some x198 ->
                  (ignore : _) (Ojs.call x197 "push" [| Ojs.int_to_js x198 |])
                | None -> ());
               x197)
           |])
    ;;
  end

  module Selection_range = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x202 : Ojs.t) -> x202
    and t_to_js : t -> Ojs.t = fun (x201 : Ojs.t) -> x201

    let from : t -> int =
      fun (x203 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x203) "from")
    ;;

    let to_ : t -> int =
      fun (x204 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x204) "to")
    ;;

    let anchor : t -> int =
      fun (x205 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x205) "anchor")
    ;;

    let head : t -> int =
      fun (x206 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x206) "head")
    ;;

    let empty : t -> bool =
      fun (x207 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x207) "empty")
    ;;

    let assoc : t -> Cursor_association.t =
      fun (x208 : t) ->
      Cursor_association.t_of_js (Ojs.get_prop_ascii (t_to_js x208) "assoc")
    ;;

    let bidi_level : t -> int option =
      fun (x209 : t) ->
      Ojs.option_of_js Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x209) "bidiLevel")
    ;;

    let goal_column : t -> int option =
      fun (x211 : t) ->
      Ojs.option_of_js Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x211) "goalColumn")
    ;;

    let map : t -> Change_desc.t -> ?assoc:Cursor_association.t -> unit -> t =
      fun (x217 : t) (x213 : Change_desc.t) ?assoc:(x214 : Cursor_association.t option) () ->
      t_of_js
        (let x218 = t_to_js x217 in
         Ojs.call
           (Ojs.get_prop_ascii x218 "map")
           "apply"
           [| x218
            ; (let x215 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x215 "push" [| Change_desc.t_to_js x213 |]);
               (match x214 with
                | Some x216 ->
                  (ignore : _)
                    (Ojs.call x215 "push" [| Cursor_association.t_to_js x216 |])
                | None -> ());
               x215)
           |])
    ;;

    let extend : t -> from:int -> ?to_:int -> unit -> t =
      fun (x223 : t) ~from:(x219 : int) ?to_:(x220 : int option) () ->
      t_of_js
        (let x224 = t_to_js x223 in
         Ojs.call
           (Ojs.get_prop_ascii x224 "extend")
           "apply"
           [| x224
            ; (let x221 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x221 "push" [| Ojs.int_to_js x219 |]);
               (match x220 with
                | Some x222 ->
                  (ignore : _) (Ojs.call x221 "push" [| Ojs.int_to_js x222 |])
                | None -> ());
               x221)
           |])
    ;;

    let equal : t -> t -> bool =
      fun (x226 : t) (x225 : t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x226) "eq" [| t_to_js x225 |])
    ;;

    let to_json : t -> Ojs.t = fun (x227 : t) -> Ojs.call (t_to_js x227) "toJSON" [||]

    let from_json : Ojs.t -> t =
      fun (x228 : Ojs.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "SelectionRange")
           "fromJSON"
           [| x228 |])
    ;;
  end

  module Editor_selection = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x230 : Ojs.t) -> x230
    and t_to_js : t -> Ojs.t = fun (x229 : Ojs.t) -> x229

    let ranges : t -> Selection_range.t list =
      fun (x231 : t) ->
      Ojs.list_of_js Selection_range.t_of_js (Ojs.get_prop_ascii (t_to_js x231) "ranges")
    ;;

    let main_index : t -> int =
      fun (x233 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x233) "mainIndex")
    ;;

    let main : t -> Selection_range.t =
      fun (x234 : t) -> Selection_range.t_of_js (Ojs.get_prop_ascii (t_to_js x234) "main")
    ;;

    let map : t -> Change_desc.t -> ?assoc:Cursor_association.t -> unit -> t =
      fun (x239 : t) (x235 : Change_desc.t) ?assoc:(x236 : Cursor_association.t option) () ->
      t_of_js
        (let x240 = t_to_js x239 in
         Ojs.call
           (Ojs.get_prop_ascii x240 "map")
           "apply"
           [| x240
            ; (let x237 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x237 "push" [| Change_desc.t_to_js x235 |]);
               (match x236 with
                | Some x238 ->
                  (ignore : _)
                    (Ojs.call x237 "push" [| Cursor_association.t_to_js x238 |])
                | None -> ());
               x237)
           |])
    ;;

    let equal : t -> t -> bool =
      fun (x242 : t) (x241 : t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x242) "eq" [| t_to_js x241 |])
    ;;

    let as_single : t -> t =
      fun (x243 : t) -> t_of_js (Ojs.call (t_to_js x243) "asSingle" [||])
    ;;

    let add_range : t -> Selection_range.t -> ?main:bool -> unit -> t =
      fun (x248 : t) (x244 : Selection_range.t) ?main:(x245 : bool option) () ->
      t_of_js
        (let x249 = t_to_js x248 in
         Ojs.call
           (Ojs.get_prop_ascii x249 "addRange")
           "apply"
           [| x249
            ; (let x246 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x246 "push" [| Selection_range.t_to_js x244 |]);
               (match x245 with
                | Some x247 ->
                  (ignore : _) (Ojs.call x246 "push" [| Ojs.bool_to_js x247 |])
                | None -> ());
               x246)
           |])
    ;;

    let replace_range : Selection_range.t -> ?which:int -> unit -> t =
      fun (x253 : Selection_range.t) ?which:(x250 : int option) () ->
      t_of_js
        (let x254 = Selection_range.t_to_js x253 in
         Ojs.call
           (Ojs.get_prop_ascii x254 "replaceRange")
           "apply"
           [| x254
            ; (let x251 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x250 with
                | Some x252 ->
                  (ignore : _) (Ojs.call x251 "push" [| Ojs.int_to_js x252 |])
                | None -> ());
               x251)
           |])
    ;;

    let to_json : t -> Ojs.t = fun (x255 : t) -> Ojs.call (t_to_js x255) "toJSON" [||]

    let from_json : Ojs.t -> t =
      fun (x256 : Ojs.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorSelection")
           "fromJSON"
           [| x256 |])
    ;;

    let single : anchor:int -> ?head:int -> unit -> t =
      fun ~anchor:(x257 : int) ?head:(x258 : int option) () ->
      t_of_js
        (let x261 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x261 "single")
           "apply"
           [| x261
            ; (let x259 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x259 "push" [| Ojs.int_to_js x257 |]);
               (match x258 with
                | Some x260 ->
                  (ignore : _) (Ojs.call x259 "push" [| Ojs.int_to_js x260 |])
                | None -> ());
               x259)
           |])
    ;;

    let create : ranges:Selection_range.t list -> ?main_index:int -> unit -> t =
      fun ~ranges:(x262 : Selection_range.t list) ?main_index:(x263 : int option) () ->
      t_of_js
        (let x267 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x267 "create")
           "apply"
           [| x267
            ; (let x264 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _)
                 (Ojs.call x264 "push" [| Ojs.list_to_js Selection_range.t_to_js x262 |]);
               (match x263 with
                | Some x265 ->
                  (ignore : _) (Ojs.call x264 "push" [| Ojs.int_to_js x265 |])
                | None -> ());
               x264)
           |])
    ;;

    let cursor
      :  pos:int -> ?assoc:Cursor_association.t -> ?bidi_level:int -> ?goal_column:int
      -> unit -> Selection_range.t
      =
      fun ~pos:(x268 : int)
        ?assoc:(x269 : Cursor_association.t option)
        ?bidi_level:(x270 : int option)
        ?goal_column:(x271 : int option)
        () ->
      Selection_range.t_of_js
        (let x276 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x276 "cursor")
           "apply"
           [| x276
            ; (let x272 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x272 "push" [| Ojs.int_to_js x268 |]);
               (match x269 with
                | Some x275 ->
                  (ignore : _)
                    (Ojs.call x272 "push" [| Cursor_association.t_to_js x275 |])
                | None -> ());
               (match x270 with
                | Some x274 ->
                  (ignore : _) (Ojs.call x272 "push" [| Ojs.int_to_js x274 |])
                | None -> ());
               (match x271 with
                | Some x273 ->
                  (ignore : _) (Ojs.call x272 "push" [| Ojs.int_to_js x273 |])
                | None -> ());
               x272)
           |])
    ;;

    let range : anchor:int -> head:int -> ?goal_column:int -> unit -> Selection_range.t =
      fun ~anchor:(x277 : int) ~head:(x278 : int) ?goal_column:(x279 : int option) () ->
      Selection_range.t_of_js
        (let x282 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x282 "range")
           "apply"
           [| x282
            ; (let x280 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x280 "push" [| Ojs.int_to_js x277 |]);
               (ignore : _) (Ojs.call x280 "push" [| Ojs.int_to_js x278 |]);
               (match x279 with
                | Some x281 ->
                  (ignore : _) (Ojs.call x280 "push" [| Ojs.int_to_js x281 |])
                | None -> ());
               x280)
           |])
    ;;
  end

  module Change_set = struct
    type t = change_set

    let rec t_of_js : Ojs.t -> t = fun (x284 : Ojs.t) -> change_set_of_js x284
    and t_to_js : t -> Ojs.t = fun (x283 : change_set) -> change_set_to_js x283

    let iter_changes
      :  t
      -> f:
           (from_a:int
            -> to_a:int
            -> from_b:int
            -> to_b:int
            -> inserted:Text.Text.t
            -> unit)
      -> unit
      =
      fun (x291 : t)
        ~f:
          (x285 :
            from_a:int
            -> to_a:int
            -> from_b:int
            -> to_b:int
            -> inserted:Text.Text.t
            -> unit) ->
      (ignore : _)
        (Ojs.call
           (t_to_js x291)
           "iterChanges"
           [| Ojs.fun_to_js
                5
                (fun
                    (x286 : Ojs.t)
                    (x287 : Ojs.t)
                    (x288 : Ojs.t)
                    (x289 : Ojs.t)
                    (x290 : Ojs.t)
                  ->
                   x285
                     ~from_a:(Ojs.int_of_js x286)
                     ~to_a:(Ojs.int_of_js x287)
                     ~from_b:(Ojs.int_of_js x288)
                     ~to_b:(Ojs.int_of_js x289)
                     ~inserted:(Text.Text.t_of_js x290))
           |])
    ;;

    let desc : t -> Change_desc.t =
      fun (x292 : t) -> Change_desc.t_of_js (Ojs.get_prop_ascii (t_to_js x292) "desc")
    ;;
  end

  type editor_state = Ojs.t

  let rec editor_state_of_js : Ojs.t -> editor_state = fun (x294 : Ojs.t) -> x294
  and editor_state_to_js : editor_state -> Ojs.t = fun (x293 : Ojs.t) -> x293

  module Annotation_type = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x296 : Ojs.t) -> x296
    and t_to_js : t -> Ojs.t = fun (x295 : Ojs.t) -> x295
  end

  module Transaction = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x298 : Ojs.t) -> x298
    and t_to_js : t -> Ojs.t = fun (x297 : Ojs.t) -> x297

    let start_state : t -> editor_state =
      fun (x299 : t) ->
      editor_state_of_js (Ojs.get_prop_ascii (t_to_js x299) "startState")
    ;;

    let changes : t -> Change_set.t =
      fun (x300 : t) -> Change_set.t_of_js (Ojs.get_prop_ascii (t_to_js x300) "changes")
    ;;

    let selection : t -> Editor_selection.t option =
      fun (x301 : t) ->
      Ojs.option_of_js
        Editor_selection.t_of_js
        (Ojs.get_prop_ascii (t_to_js x301) "selection")
    ;;

    let effects : t -> State_effect.t list =
      fun (x303 : t) ->
      Ojs.list_of_js State_effect.t_of_js (Ojs.get_prop_ascii (t_to_js x303) "effects")
    ;;

    let scroll_into_view : t -> bool =
      fun (x305 : t) ->
      Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x305) "scrollIntoView")
    ;;

    let new_doc : t -> Text.Text.t =
      fun (x306 : t) -> Text.Text.t_of_js (Ojs.get_prop_ascii (t_to_js x306) "newDoc")
    ;;

    let new_selection : t -> Editor_selection.t =
      fun (x307 : t) ->
      Editor_selection.t_of_js (Ojs.get_prop_ascii (t_to_js x307) "newSelection")
    ;;

    let state : t -> editor_state =
      fun (x308 : t) -> editor_state_of_js (Ojs.get_prop_ascii (t_to_js x308) "state")
    ;;

    let doc_changed : t -> bool =
      fun (x309 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x309) "docChanged")
    ;;

    let reconfigured : t -> bool =
      fun (x310 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x310) "reconfigured")
    ;;

    let is_user_event : t -> string -> bool =
      fun (x312 : t) (x311 : string) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x312) "isUserEvent" [| Ojs.string_to_js x311 |])
    ;;

    let time : Annotation_type.t =
      Annotation_type.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Transaction")
           "time")
    ;;

    let user_event : Annotation_type.t =
      Annotation_type.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Transaction")
           "userEvent")
    ;;

    let add_to_history : Annotation_type.t =
      Annotation_type.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Transaction")
           "addToHistory")
    ;;
  end

  module State_field_config = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x314 : Ojs.t) -> x314

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x313 : Ojs.t) -> x313
    ;;

    let create
      :  create:(editor_state -> 'v) -> update:('v -> Transaction.t -> 'v)
      -> compare:('v -> 'v -> bool) option -> 'v t
      =
      fun ~create:(x315 : editor_state -> 'v)
        ~update:(x316 : 'v -> Transaction.t -> 'v)
        ~compare:(x317 : ('v -> 'v -> bool) option) ->
      let x318 = Ojs.empty_obj () in
      Ojs.set_prop_ascii
        x318
        "create"
        (Ojs.fun_to_js 1 (fun (x325 : Ojs.t) ->
           Obj.magic (x315 (editor_state_of_js x325))));
      Ojs.set_prop_ascii
        x318
        "update"
        (Ojs.fun_to_js 2 (fun (x323 : Ojs.t) (x324 : Ojs.t) ->
           Obj.magic (x316 (Obj.magic x323) (Transaction.t_of_js x324))));
      Ojs.set_prop_ascii
        x318
        "compare"
        (Ojs.option_to_js
           (fun (x320 : 'v -> 'v -> bool) ->
             Ojs.fun_to_js 2 (fun (x321 : Ojs.t) (x322 : Ojs.t) ->
               Ojs.bool_to_js (x320 (Obj.magic x321) (Obj.magic x322))))
           x317);
      t_of_js Obj.magic x318
    ;;
  end

  module State_field = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x327 : Ojs.t) -> x327

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x326 : Ojs.t) -> x326
    ;;

    let extension : 'v t -> Extension.t =
      fun (x328 : 'v t) ->
      Extension.t_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x328) "extension")
    ;;

    let init : 'v t -> create:(editor_state -> 'v) -> Extension.t =
      fun (x332 : 'v t) ~create:(x330 : editor_state -> 'v) ->
      Extension.t_of_js
        (Ojs.call
           (t_to_js Obj.magic x332)
           "init"
           [| Ojs.fun_to_js 1 (fun (x331 : Ojs.t) ->
                Obj.magic (x330 (editor_state_of_js x331)))
           |])
    ;;

    let define : config:'v State_field_config.t -> 'v t =
      fun ~config:(x334 : 'v State_field_config.t) ->
      t_of_js
        Obj.magic
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "StateField")
           "define"
           [| State_field_config.t_to_js Obj.magic x334 |])
    ;;
  end

  module Facet = struct
    type ('i, 'o) t = Ojs.t

    let rec t_of_js : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) t =
      fun (type __i __o)
        (__i_of_js : Ojs.t -> __i)
        (__o_of_js : Ojs.t -> __o)
        (x338 : Ojs.t) ->
      x338

    and t_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) t -> Ojs.t =
      fun (type __i __o)
        (__i_to_js : __i -> Ojs.t)
        (__o_to_js : __o -> Ojs.t)
        (x337 : Ojs.t) ->
      x337
    ;;

    type 'i multi_out = ('i, 'i list) t

    let rec multi_out_of_js : 'i. (Ojs.t -> 'i) -> Ojs.t -> 'i multi_out =
      fun (type __i) (__i_of_js : Ojs.t -> __i) (x343 : Ojs.t) ->
      t_of_js __i_of_js (fun (x345 : Ojs.t) -> Ojs.list_of_js __i_of_js x345) x343

    and multi_out_to_js : 'i. ('i -> Ojs.t) -> 'i multi_out -> Ojs.t =
      fun (type __i) (__i_to_js : __i -> Ojs.t) (x339 : (__i, __i list) t) ->
      t_to_js __i_to_js (fun (x341 : __i list) -> Ojs.list_to_js __i_to_js x341) x339
    ;;

    let of_ : ('i, 'o) t -> 'i With_conversion.t -> Extension.t =
      fun (x349 : ('i, 'o) t) (x347 : 'i With_conversion.t) ->
      Extension.t_of_js
        (Ojs.call
           (t_to_js Obj.magic Obj.magic x349)
           "of"
           [| With_conversion.t_to_js Obj.magic x347 |])
    ;;

    module Dep = struct
      type ('i, 'o) facet = ('i, 'o) t

      let rec facet_of_js
        : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) facet
        =
        fun (type __i __o)
          (__i_of_js : Ojs.t -> __i)
          (__o_of_js : Ojs.t -> __o)
          (x355 : Ojs.t) ->
        t_of_js __i_of_js __o_of_js x355

      and facet_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) facet -> Ojs.t =
        fun (type __i __o)
          (__i_to_js : __i -> Ojs.t)
          (__o_to_js : __o -> Ojs.t)
          (x352 : (__i, __o) t) ->
        t_to_js __i_to_js __o_to_js x352
      ;;

      type t =
        | Doc : t
        | Selection : t
        | Facet : ('i, 'o) facet -> t

      let rec t_of_js : Ojs.t -> t =
        let doc_str = Js.string "doc" in
        let selection_str = Js.string "selection" in
        let ojs_equal (x : Ojs.t) (y : Js.js_string Js.t) =
          Js.strict_equals ((Obj.magic : Ojs.t -> Js.js_string Js.t) x) y
        in
        function
        | x when ojs_equal x doc_str -> Doc
        | x when ojs_equal x selection_str -> Selection
        | _ ->
          Core.raise_s
            [%message
              "[Dep.of_js] is only supported for 'doc' and 'selection'"
                ([%here] : Core.Source_code_position.t)]

      and t_to_js : t -> Ojs.t = function
        | Doc -> Ojs.string_to_js "doc"
        | Selection -> Ojs.string_to_js "selection"
        | Facet facet -> (facet : Ojs.t)
      ;;
    end

    let compute : ('i, 'o) t -> deps:Dep.t list -> get:(editor_state -> 'i) -> Extension.t
      =
      fun (x362 : ('i, 'o) t) ~deps:(x358 : Dep.t list) ~get:(x360 : editor_state -> 'i) ->
      Extension.t_of_js
        (Ojs.call
           (t_to_js Obj.magic Obj.magic x362)
           "compute"
           [| Ojs.list_to_js Dep.t_to_js x358
            ; Ojs.fun_to_js 1 (fun (x361 : Ojs.t) ->
                Obj.magic (x360 (editor_state_of_js x361)))
           |])
    ;;

    let from : ('i, 'o) t -> field:'t State_field.t -> get:(value:'t -> 'i) -> Extension.t
      =
      fun (x369 : ('i, 'o) t)
        ~field:(x365 : 't State_field.t)
        ~get:(x367 : value:'t -> 'i) ->
      Extension.t_of_js
        (Ojs.call
           (t_to_js Obj.magic Obj.magic x369)
           "from"
           [| State_field.t_to_js Obj.magic x365
            ; Ojs.fun_to_js 1 (fun (x368 : Ojs.t) ->
                Obj.magic (x367 ~value:(Obj.magic x368)))
           |])
    ;;

    module Config = struct
      type ('i, 'o) facet = ('i, 'o) t

      let rec facet_of_js
        : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) facet
        =
        fun (type __i __o)
          (__i_of_js : Ojs.t -> __i)
          (__o_of_js : Ojs.t -> __o)
          (x375 : Ojs.t) ->
        t_of_js __i_of_js __o_of_js x375

      and facet_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) facet -> Ojs.t =
        fun (type __i __o)
          (__i_to_js : __i -> Ojs.t)
          (__o_to_js : __o -> Ojs.t)
          (x372 : (__i, __o) t) ->
        t_to_js __i_to_js __o_to_js x372
      ;;

      type ('i, 'o) t = Ojs.t

      let rec t_of_js : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) t =
        fun (type __i __o)
          (__i_of_js : Ojs.t -> __i)
          (__o_of_js : Ojs.t -> __o)
          (x379 : Ojs.t) ->
        x379

      and t_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) t -> Ojs.t =
        fun (type __i __o)
          (__i_to_js : __i -> Ojs.t)
          (__o_to_js : __o -> Ojs.t)
          (x378 : Ojs.t) ->
        x378
      ;;

      let create
        :  combine:('i list -> 'o) -> ?compare:('o -> 'o -> bool)
        -> ?compareInput:('i -> 'i -> bool) -> ?static:bool
        -> ?enables:(('i, 'o) facet -> Extension.t) -> unit -> ('i, 'o) t
        =
        fun ~combine:(x380 : 'i list -> 'o)
          ?compare:(x381 : ('o -> 'o -> bool) option)
          ?compareInput:(x382 : ('i -> 'i -> bool) option)
          ?static:(x383 : bool option)
          ?enables:(x384 : (('i, 'o) facet -> Extension.t) option)
          () ->
        let x385 = Ojs.empty_obj () in
        Ojs.set_prop_ascii
          x385
          "combine"
          (Ojs.fun_to_js 1 (fun (x399 : Ojs.t) ->
             Obj.magic (x380 (Ojs.list_of_js Obj.magic x399))));
        (match x381 with
         | Some x396 ->
           Ojs.set_prop_ascii
             x385
             "compare"
             (Ojs.fun_to_js 2 (fun (x397 : Ojs.t) (x398 : Ojs.t) ->
                Ojs.bool_to_js (x396 (Obj.magic x397) (Obj.magic x398))))
         | None -> ());
        (match x382 with
         | Some x393 ->
           Ojs.set_prop_ascii
             x385
             "compareInput"
             (Ojs.fun_to_js 2 (fun (x394 : Ojs.t) (x395 : Ojs.t) ->
                Ojs.bool_to_js (x393 (Obj.magic x394) (Obj.magic x395))))
         | None -> ());
        (match x383 with
         | Some x392 -> Ojs.set_prop_ascii x385 "static" (Ojs.bool_to_js x392)
         | None -> ());
        (match x384 with
         | Some x388 ->
           Ojs.set_prop_ascii
             x385
             "enables"
             (Ojs.fun_to_js 1 (fun (x389 : Ojs.t) ->
                Extension.t_to_js (x388 (facet_of_js Obj.magic Obj.magic x389))))
         | None -> ());
        t_of_js Obj.magic Obj.magic x385
      ;;
    end

    let define : ('i, 'o) Config.t -> ('i, 'o) t =
      fun (x401 : ('i, 'o) Config.t) ->
      t_of_js
        Obj.magic
        Obj.magic
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Facet")
           "define"
           [| Config.t_to_js Obj.magic Obj.magic x401 |])
    ;;
  end

  module Char_category = struct
    type t =
      | Word
      | Space
      | Other

    let rec t_of_js : Ojs.t -> t =
      fun (x407 : Ojs.t) ->
      let x408 = x407 in
      match Ojs.string_of_js x408 with
      | "Word" -> Word
      | "Space" -> Space
      | "Other" -> Other
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x406 : t) ->
      match x406 with
      | Word -> Ojs.string_to_js "Word"
      | Space -> Ojs.string_to_js "Space"
      | Other -> Ojs.string_to_js "Other"
    ;;
  end

  module Change_filter_result = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x410 : Ojs.t) -> x410
    and t_to_js : t -> Ojs.t = fun (x409 : Ojs.t) -> x409

    let bool : bool -> t = fun (x411 : bool) -> t_of_js (Ojs.bool_to_js x411)

    let ranges : int list -> t =
      fun (x412 : int list) -> t_of_js (Ojs.list_to_js Ojs.int_to_js x412)
    ;;
  end

  module Transaction_spec = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x415 : Ojs.t) -> x415
    and t_to_js : t -> Ojs.t = fun (x414 : Ojs.t) -> x414

    let create
      :  ?changes:Change_spec.t -> ?selection:Editor_selection.t
      -> ?effects:State_effect.t list -> ?annotations:Annotation.t list
      -> ?scroll_into_view:bool -> ?filter:bool -> ?sequential:bool -> unit -> t
      =
      fun ?changes:(x416 : Change_spec.t option)
        ?selection:(x417 : Editor_selection.t option)
        ?effects:(x418 : State_effect.t list option)
        ?annotations:(x419 : Annotation.t list option)
        ?scroll_into_view:(x420 : bool option)
        ?filter:(x421 : bool option)
        ?sequential:(x422 : bool option)
        () ->
      let x423 = Ojs.empty_obj () in
      (match x416 with
       | Some x432 -> Ojs.set_prop_ascii x423 "changes" (Change_spec.t_to_js x432)
       | None -> ());
      (match x417 with
       | Some x431 -> Ojs.set_prop_ascii x423 "selection" (Editor_selection.t_to_js x431)
       | None -> ());
      (match x418 with
       | Some x429 ->
         Ojs.set_prop_ascii x423 "effects" (Ojs.list_to_js State_effect.t_to_js x429)
       | None -> ());
      (match x419 with
       | Some x427 ->
         Ojs.set_prop_ascii x423 "annotations" (Ojs.list_to_js Annotation.t_to_js x427)
       | None -> ());
      (match x420 with
       | Some x426 -> Ojs.set_prop_ascii x423 "scrollIntoView" (Ojs.bool_to_js x426)
       | None -> ());
      (match x421 with
       | Some x425 -> Ojs.set_prop_ascii x423 "filter" (Ojs.bool_to_js x425)
       | None -> ());
      (match x422 with
       | Some x424 -> Ojs.set_prop_ascii x423 "sequential" (Ojs.bool_to_js x424)
       | None -> ());
      t_of_js x423
    ;;
  end

  module Compartment = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x434 : Ojs.t) -> x434
    and t_to_js : t -> Ojs.t = fun (x433 : Ojs.t) -> x433

    let create : unit -> t =
      fun () ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Compartment")
           [||])
    ;;

    let of_ : t -> Extension.t -> Extension.t =
      fun (x436 : t) (x435 : Extension.t) ->
      Extension.t_of_js (Ojs.call (t_to_js x436) "of" [| Extension.t_to_js x435 |])
    ;;

    let reconfigure : t -> Extension.t -> state_effect =
      fun (x438 : t) (x437 : Extension.t) ->
      state_effect_of_js
        (Ojs.call (t_to_js x438) "reconfigure" [| Extension.t_to_js x437 |])
    ;;

    let get : t -> editor_state -> Extension.t option =
      fun (x440 : t) (x439 : editor_state) ->
      Ojs.option_of_js
        Extension.t_of_js
        (Ojs.call (t_to_js x440) "get" [| editor_state_to_js x439 |])
    ;;
  end

  module Editor_state = struct
    type t = editor_state

    let rec t_of_js : Ojs.t -> t = fun (x443 : Ojs.t) -> editor_state_of_js x443
    and t_to_js : t -> Ojs.t = fun (x442 : editor_state) -> editor_state_to_js x442

    let doc : t -> Text.Text.t =
      fun (x444 : t) -> Text.Text.t_of_js (Ojs.get_prop_ascii (t_to_js x444) "doc")
    ;;

    let selection : t -> Editor_selection.t =
      fun (x445 : t) ->
      Editor_selection.t_of_js (Ojs.get_prop_ascii (t_to_js x445) "selection")
    ;;

    let field : t -> 'a State_field.t -> 'a option =
      fun (x448 : t) (x446 : 'a State_field.t) ->
      Ojs.option_of_js
        Obj.magic
        (Ojs.call (t_to_js x448) "field" [| State_field.t_to_js Obj.magic x446 |])
    ;;

    let update : t -> Transaction_spec.t list -> Transaction.t =
      fun (x453 : t) (x450 : Transaction_spec.t list) ->
      Transaction.t_of_js
        (let x454 = t_to_js x453 in
         Ojs.call
           (Ojs.get_prop_ascii x454 "update")
           "apply"
           [| x454
            ; (let x451 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               List.iter
                 (fun (x452 : Transaction_spec.t) ->
                   (ignore : _) (Ojs.call x451 "push" [| Transaction_spec.t_to_js x452 |]))
                 x450;
               x451)
           |])
    ;;

    let replace_selection : t -> Text.Text.t -> Transaction_spec.t =
      fun (x456 : t) (x455 : Text.Text.t) ->
      Transaction_spec.t_of_js
        (Ojs.call (t_to_js x456) "replaceSelection" [| Text.Text.t_to_js x455 |])
    ;;

    let change_by_range
      : t -> f:(Selection_range.t -> Transaction_spec.t) -> Transaction_spec.t
      =
      fun (x459 : t) ~f:(x457 : Selection_range.t -> Transaction_spec.t) ->
      Transaction_spec.t_of_js
        (Ojs.call
           (t_to_js x459)
           "changeByRange"
           [| Ojs.fun_to_js 1 (fun (x458 : Ojs.t) ->
                Transaction_spec.t_to_js (x457 (Selection_range.t_of_js x458)))
           |])
    ;;

    let changes : t -> Change_spec.t -> Change_set.t =
      fun (x461 : t) (x460 : Change_spec.t) ->
      Change_set.t_of_js
        (Ojs.call (t_to_js x461) "changes" [| Change_spec.t_to_js x460 |])
    ;;

    let to_text : t -> string -> Text.Text.t =
      fun (x463 : t) (x462 : string) ->
      Text.Text.t_of_js (Ojs.call (t_to_js x463) "toText" [| Ojs.string_to_js x462 |])
    ;;

    let slice_doc : t -> ?from:int -> ?to_:int -> unit -> string =
      fun (x469 : t) ?from:(x464 : int option) ?to_:(x465 : int option) () ->
      Ojs.string_of_js
        (let x470 = t_to_js x469 in
         Ojs.call
           (Ojs.get_prop_ascii x470 "sliceDoc")
           "apply"
           [| x470
            ; (let x466 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x464 with
                | Some x468 ->
                  (ignore : _) (Ojs.call x466 "push" [| Ojs.int_to_js x468 |])
                | None -> ());
               (match x465 with
                | Some x467 ->
                  (ignore : _) (Ojs.call x466 "push" [| Ojs.int_to_js x467 |])
                | None -> ());
               x466)
           |])
    ;;

    let word_at : t -> pos:int -> Selection_range.t option =
      fun (x472 : t) ~pos:(x471 : int) ->
      Ojs.option_of_js
        Selection_range.t_of_js
        (Ojs.call (t_to_js x472) "wordAt" [| Ojs.int_to_js x471 |])
    ;;

    let facet : t -> ('i, 'o) Facet.t -> 'o =
      fun (x477 : t) (x474 : ('i, 'o) Facet.t) ->
      Obj.magic
        (Ojs.call (t_to_js x477) "facet" [| Facet.t_to_js Obj.magic Obj.magic x474 |])
    ;;

    let to_json : t -> Ojs.t = fun (x478 : t) -> Ojs.call (t_to_js x478) "toJSON" [||]

    let get_tab_size : t -> int =
      fun (x479 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x479) "tabSize")
    ;;

    let line_break : t -> string =
      fun (x480 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x480) "lineBreak")
    ;;

    let phrase : t -> string -> string =
      fun (x482 : t) (x481 : string) ->
      Ojs.string_of_js (Ojs.call (t_to_js x482) "phrase" [| Ojs.string_to_js x481 |])
    ;;

    let language_data_at : t -> name:string -> pos:int -> Ojs.t list =
      fun (x485 : t) ~name:(x483 : string) ~pos:(x484 : int) ->
      Ojs.list_of_js
        (fun (x486 : Ojs.t) -> x486)
        (Ojs.call
           (t_to_js x485)
           "languageDataAt"
           [| Ojs.string_to_js x483; Ojs.int_to_js x484 |])
    ;;

    let char_categorizer : t -> int -> string -> Char_category.t =
      fun (x489 : t) (x487 : int) (x488 : string) ->
      Char_category.t_of_js
        (Ojs.call
           (t_to_js x489)
           "charCategorizer"
           [| Ojs.int_to_js x487; Ojs.string_to_js x488 |])
    ;;

    let from_json
      : json:Ojs.t -> ?config:Editor_state_config.t -> ?fields:Ojs.t -> unit -> t
      =
      fun ~json:(x490 : Ojs.t)
        ?config:(x491 : Editor_state_config.t option)
        ?fields:(x492 : Ojs.t option)
        () ->
      t_of_js
        (let x496 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorState"
         in
         Ojs.call
           (Ojs.get_prop_ascii x496 "fromJSON")
           "apply"
           [| x496
            ; (let x493 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x493 "push" [| x490 |]);
               (match x491 with
                | Some x495 ->
                  (ignore : _)
                    (Ojs.call x493 "push" [| Editor_state_config.t_to_js x495 |])
                | None -> ());
               (match x492 with
                | Some x494 -> (ignore : _) (Ojs.call x493 "push" [| x494 |])
                | None -> ());
               x493)
           |])
    ;;

    let create : Editor_state_config.t -> t =
      fun (x497 : Editor_state_config.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "create"
           [| Editor_state_config.t_to_js x497 |])
    ;;

    let allow_multiple_selections : (bool, bool) Facet.t =
      Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "allowMultipleSelections")
    ;;

    let tab_size : (int, int) Facet.t =
      Facet.t_of_js
        Ojs.int_of_js
        Ojs.int_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "tabSize")
    ;;

    let read_only : (bool, bool) Facet.t =
      Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "readOnly")
    ;;

    let line_separator : (string, string option) Facet.t =
      Facet.t_of_js
        Ojs.string_of_js
        (fun (x505 : Ojs.t) -> Ojs.option_of_js Ojs.string_of_js x505)
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "lineSeparator")
    ;;

    let phrases : Ojs.t Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x507 : Ojs.t) -> x507)
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "phrases")
    ;;

    let language_data : (t -> int -> Ojs.t list) Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x508 : Ojs.t) (x509 : t) (x510 : int) ->
          Ojs.list_of_js
            (fun (x511 : Ojs.t) -> x511)
            (Ojs.apply x508 [| t_to_js x509; Ojs.int_to_js x510 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "languageData")
    ;;

    let change_filter : (Transaction.t -> Change_filter_result.t) Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x512 : Ojs.t) (x513 : Transaction.t) ->
          Change_filter_result.t_of_js (Ojs.apply x512 [| Transaction.t_to_js x513 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "changeFilter")
    ;;

    let transaction_filter : (Transaction.t -> Transaction_spec.t list) Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x514 : Ojs.t) (x515 : Transaction.t) ->
          Ojs.list_of_js
            Transaction_spec.t_of_js
            (Ojs.apply x514 [| Transaction.t_to_js x515 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "transactionFilter")
    ;;

    let transaction_extender : (Transaction.t -> Effects_and_annotation.t) Facet.multi_out
      =
      Facet.multi_out_of_js
        (fun (x517 : Ojs.t) (x518 : Transaction.t) ->
          Effects_and_annotation.t_of_js (Ojs.apply x517 [| Transaction.t_to_js x518 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "transactionExtender")
    ;;
  end

  module Range = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x520 : Ojs.t) -> x520

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x519 : Ojs.t) -> x519
    ;;

    let from : 'v t -> int =
      fun (x521 : 'v t) ->
      Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x521) "from")
    ;;

    let to_ : 'v t -> int =
      fun (x523 : 'v t) ->
      Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x523) "to")
    ;;
  end

  module Range_set_update_spec = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x526 : Ojs.t) -> x526

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x525 : Ojs.t) -> x525
    ;;

    let create
      :  add:'v Range.t list -> sort:bool
      -> filter:(from:int -> to_:int -> value:'v -> bool) option -> filter_from:int option
      -> filter_to:int option -> 'v t
      =
      fun ~add:(x527 : 'v Range.t list)
        ~sort:(x528 : bool)
        ~filter:(x529 : (from:int -> to_:int -> value:'v -> bool) option)
        ~filter_from:(x530 : int option)
        ~filter_to:(x531 : int option) ->
      let x532 = Ojs.empty_obj () in
      Ojs.set_prop_ascii
        x532
        "add"
        (Ojs.list_to_js (fun (x540 : 'v Range.t) -> Range.t_to_js Obj.magic x540) x527);
      Ojs.set_prop_ascii x532 "sort" (Ojs.bool_to_js x528);
      Ojs.set_prop_ascii
        x532
        "filter"
        (Ojs.option_to_js
           (fun (x536 : from:int -> to_:int -> value:'v -> bool) ->
             Ojs.fun_to_js 3 (fun (x537 : Ojs.t) (x538 : Ojs.t) (x539 : Ojs.t) ->
               Ojs.bool_to_js
                 (x536
                    ~from:(Ojs.int_of_js x537)
                    ~to_:(Ojs.int_of_js x538)
                    ~value:(Obj.magic x539))))
           x529);
      Ojs.set_prop_ascii x532 "filterFrom" (Ojs.option_to_js Ojs.int_to_js x530);
      Ojs.set_prop_ascii x532 "filterTo" (Ojs.option_to_js Ojs.int_to_js x531);
      t_of_js Obj.magic x532
    ;;
  end

  module Range_set = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x543 : Ojs.t) -> x543

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x542 : Ojs.t) -> x542
    ;;

    let empty : 'v t =
      t_of_js
        Obj.magic
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "RangeSet")
           "empty")
    ;;

    let size : 'v t -> int =
      fun (x545 : 'v t) ->
      Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x545) "size")
    ;;

    let update : 'v t -> update_spec:'v Range_set_update_spec.t -> 'v t =
      fun (x549 : 'v t) ~update_spec:(x547 : 'v Range_set_update_spec.t) ->
      t_of_js
        Obj.magic
        (Ojs.call
           (t_to_js Obj.magic x549)
           "update"
           [| Range_set_update_spec.t_to_js Obj.magic x547 |])
    ;;

    let between
      :  'v t -> from:int -> to_:int -> f:(from:int -> to_:int -> value:'v -> bool option)
      -> unit
      =
      fun (x559 : 'v t)
        ~from:(x552 : int)
        ~to_:(x553 : int)
        ~f:(x554 : from:int -> to_:int -> value:'v -> bool option) ->
      (ignore : _)
        (Ojs.call
           (t_to_js Obj.magic x559)
           "between"
           [| Ojs.int_to_js x552
            ; Ojs.int_to_js x553
            ; Ojs.fun_to_js 3 (fun (x555 : Ojs.t) (x556 : Ojs.t) (x557 : Ojs.t) ->
                Ojs.option_to_js
                  Ojs.bool_to_js
                  (x554
                     ~from:(Ojs.int_of_js x555)
                     ~to_:(Ojs.int_of_js x556)
                     ~value:(Obj.magic x557)))
           |])
    ;;
  end

  module Prec = struct
    let fallback : Extension.t -> Extension.t =
      fun (x561 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "fallback"
           [| Extension.t_to_js x561 |])
    ;;

    let default : Extension.t -> Extension.t =
      fun (x562 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "default"
           [| Extension.t_to_js x562 |])
    ;;

    let extend : Extension.t -> Extension.t =
      fun (x563 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "extend"
           [| Extension.t_to_js x563 |])
    ;;

    let override : Extension.t -> Extension.t =
      fun (x564 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "override"
           [| Extension.t_to_js x564 |])
    ;;

    let high : Extension.t -> Extension.t =
      fun (x565 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "high"
           [| Extension.t_to_js x565 |])
    ;;
  end
end

module View = struct
  type editor_view = Ojs.t

  let rec editor_view_of_js : Ojs.t -> editor_view = fun (x567 : Ojs.t) -> x567
  and editor_view_to_js : editor_view -> Ojs.t = fun (x566 : Ojs.t) -> x566

  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x569 : Ojs.t) -> x569
    and t_to_js : t -> Ojs.t = fun (x568 : Ojs.t) -> x568

    let create
      :  ?state:State.Editor_state.t
      -> ?dispatch:(State.Transaction.t -> editor_view -> unit) Callback.t
      -> ?scroll_to:State.State_effect.t -> unit -> t
      =
      fun ?state:(x570 : State.Editor_state.t option)
        ?dispatch:(x571 : (State.Transaction.t -> editor_view -> unit) Callback.t option)
        ?scroll_to:(x572 : State.State_effect.t option)
        () ->
      let x573 = Ojs.empty_obj () in
      (match x570 with
       | Some x579 -> Ojs.set_prop_ascii x573 "state" (State.Editor_state.t_to_js x579)
       | None -> ());
      (match x571 with
       | Some x575 ->
         Ojs.set_prop_ascii
           x573
           "dispatch"
           (Callback.t_to_js
              (fun (x576 : State.Transaction.t -> editor_view -> unit) ->
                Ojs.fun_to_js 2 (fun (x577 : Ojs.t) (x578 : Ojs.t) ->
                  x576 (State.Transaction.t_of_js x577) (editor_view_of_js x578)))
              x575)
       | None -> ());
      (match x572 with
       | Some x574 -> Ojs.set_prop_ascii x573 "scrollTo" (State.State_effect.t_to_js x574)
       | None -> ());
      t_of_js x573
    ;;
  end

  module View_update = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x581 : Ojs.t) -> x581
    and t_to_js : t -> Ojs.t = fun (x580 : Ojs.t) -> x580

    let changes : t -> State.Change_set.t =
      fun (x582 : t) ->
      State.Change_set.t_of_js (Ojs.get_prop_ascii (t_to_js x582) "changes")
    ;;

    let transactions : t -> State.Transaction.t list =
      fun (x583 : t) ->
      Ojs.list_of_js
        State.Transaction.t_of_js
        (Ojs.get_prop_ascii (t_to_js x583) "transactions")
    ;;

    let state : t -> State.Editor_state.t =
      fun (x585 : t) ->
      State.Editor_state.t_of_js (Ojs.get_prop_ascii (t_to_js x585) "state")
    ;;

    let view : t -> editor_view =
      fun (x586 : t) -> editor_view_of_js (Ojs.get_prop_ascii (t_to_js x586) "view")
    ;;

    let viewport_changed : t -> bool =
      fun (x587 : t) ->
      Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x587) "viewportChanged")
    ;;

    let doc_changed : t -> bool =
      fun (x588 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x588) "docChanged")
    ;;

    let focus_changed : t -> bool =
      fun (x589 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x589) "focusChanged")
    ;;
  end

  let highlight_special_chars : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "highlightSpecialChars"
         [||])
  ;;

  let highlight_active_line : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "highlightActiveLine"
         [||])
  ;;

  let placeholder : content:string -> State.Extension.t =
    fun ~content:(x590 : string) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "placeholder"
         [| Ojs.string_to_js x590 |])
  ;;

  module Draw_selection_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x592 : Ojs.t) -> x592
    and t_to_js : t -> Ojs.t = fun (x591 : Ojs.t) -> x591

    let create : ?cursor_blink_rate:float -> ?draw_range_cursor:bool -> unit -> t =
      fun ?cursor_blink_rate:(x593 : float option)
        ?draw_range_cursor:(x594 : bool option)
        () ->
      let x595 = Ojs.empty_obj () in
      (match x593 with
       | Some x597 -> Ojs.set_prop_ascii x595 "cursorBlinkRate" (Ojs.float_to_js x597)
       | None -> ());
      (match x594 with
       | Some x596 -> Ojs.set_prop_ascii x595 "drawRangeCursor" (Ojs.bool_to_js x596)
       | None -> ());
      t_of_js x595
    ;;
  end

  let draw_selection : ?config:Draw_selection_config.t -> unit -> State.Extension.t =
    fun ?config:(x598 : Draw_selection_config.t option) () ->
    State.Extension.t_of_js
      (let x601 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View"
       in
       Ojs.call
         (Ojs.get_prop_ascii x601 "drawSelection")
         "apply"
         [| x601
          ; (let x599 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (match x598 with
              | Some x600 ->
                (ignore : _)
                  (Ojs.call x599 "push" [| Draw_selection_config.t_to_js x600 |])
              | None -> ());
             x599)
         |])
  ;;

  module Widget_type = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x603 : Ojs.t) -> x603
    and t_to_js : t -> Ojs.t = fun (x602 : Ojs.t) -> x602

    let create : unit -> t =
      fun () ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "WidgetType")
           [||])
    ;;

    let set_to_dom : t -> (unit -> Ojs.t) -> unit =
      fun (x604 : t) (x605 : unit -> Ojs.t) ->
      Ojs.set_prop_ascii (t_to_js x604) "toDOM" (Ojs.fun_to_js 1 (fun _ -> x605 ()))
    ;;
  end

  module Decoration = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x607 : Ojs.t) -> x607
    and t_to_js : t -> Ojs.t = fun (x606 : Ojs.t) -> x606

    let range : t -> from:int -> to_:int -> t State.Range.t =
      fun (x610 : t) ~from:(x608 : int) ~to_:(x609 : int) ->
      State.Range.t_of_js
        t_of_js
        (Ojs.call (t_to_js x610) "range" [| Ojs.int_to_js x608; Ojs.int_to_js x609 |])
    ;;

    let set : t State.Range.t list -> sort:bool -> t State.Range_set.t =
      fun (x612 : t State.Range.t list) ~sort:(x615 : bool) ->
      State.Range_set.t_of_js
        t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "set"
           [| Ojs.list_to_js
                (fun (x613 : t State.Range.t) -> State.Range.t_to_js t_to_js x613)
                x612
            ; Ojs.bool_to_js x615
           |])
    ;;

    let none : t State.Range_set.t =
      State.Range_set.t_of_js
        t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "none")
    ;;

    module Mark_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x619 : Ojs.t) -> x619
      and t_to_js : t -> Ojs.t = fun (x618 : Ojs.t) -> x618

      let create
        :  ?inclusive:bool -> ?inclusive_start:bool -> ?inclusive_end:bool
        -> ?attributes:Ojs.t -> ?class_:string -> ?tag_name:string -> unit -> t
        =
        fun ?inclusive:(x620 : bool option)
          ?inclusive_start:(x621 : bool option)
          ?inclusive_end:(x622 : bool option)
          ?attributes:(x623 : Ojs.t option)
          ?class_:(x624 : string option)
          ?tag_name:(x625 : string option)
          () ->
        let x626 = Ojs.empty_obj () in
        (match x620 with
         | Some x632 -> Ojs.set_prop_ascii x626 "inclusive" (Ojs.bool_to_js x632)
         | None -> ());
        (match x621 with
         | Some x631 -> Ojs.set_prop_ascii x626 "inclusiveStart" (Ojs.bool_to_js x631)
         | None -> ());
        (match x622 with
         | Some x630 -> Ojs.set_prop_ascii x626 "inclusiveEnd" (Ojs.bool_to_js x630)
         | None -> ());
        (match x623 with
         | Some x629 -> Ojs.set_prop_ascii x626 "attributes" x629
         | None -> ());
        (match x624 with
         | Some x628 -> Ojs.set_prop_ascii x626 "class" (Ojs.string_to_js x628)
         | None -> ());
        (match x625 with
         | Some x627 -> Ojs.set_prop_ascii x626 "tagName" (Ojs.string_to_js x627)
         | None -> ());
        t_of_js x626
      ;;
    end

    let mark : Mark_spec.t -> t =
      fun (x633 : Mark_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "mark"
           [| Mark_spec.t_to_js x633 |])
    ;;

    module Widget_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x635 : Ojs.t) -> x635
      and t_to_js : t -> Ojs.t = fun (x634 : Ojs.t) -> x634

      let create
        :  widget:Widget_type.t -> ?side:int -> ?inline_order:bool -> ?block:bool -> unit
        -> t
        =
        fun ~widget:(x636 : Widget_type.t)
          ?side:(x637 : int option)
          ?inline_order:(x638 : bool option)
          ?block:(x639 : bool option)
          () ->
        let x640 = Ojs.empty_obj () in
        Ojs.set_prop_ascii x640 "widget" (Widget_type.t_to_js x636);
        (match x637 with
         | Some x643 -> Ojs.set_prop_ascii x640 "side" (Ojs.int_to_js x643)
         | None -> ());
        (match x638 with
         | Some x642 -> Ojs.set_prop_ascii x640 "inlineOrder" (Ojs.bool_to_js x642)
         | None -> ());
        (match x639 with
         | Some x641 -> Ojs.set_prop_ascii x640 "block" (Ojs.bool_to_js x641)
         | None -> ());
        t_of_js x640
      ;;
    end

    let widget : Widget_spec.t -> t =
      fun (x644 : Widget_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "widget"
           [| Widget_spec.t_to_js x644 |])
    ;;

    module Replace_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x646 : Ojs.t) -> x646
      and t_to_js : t -> Ojs.t = fun (x645 : Ojs.t) -> x645

      let create
        :  ?widget:Widget_type.t -> ?inclusive:bool -> ?inclusive_start:bool
        -> ?inclusive_end:bool -> ?block:bool -> unit -> t
        =
        fun ?widget:(x647 : Widget_type.t option)
          ?inclusive:(x648 : bool option)
          ?inclusive_start:(x649 : bool option)
          ?inclusive_end:(x650 : bool option)
          ?block:(x651 : bool option)
          () ->
        let x652 = Ojs.empty_obj () in
        (match x647 with
         | Some x657 -> Ojs.set_prop_ascii x652 "widget" (Widget_type.t_to_js x657)
         | None -> ());
        (match x648 with
         | Some x656 -> Ojs.set_prop_ascii x652 "inclusive" (Ojs.bool_to_js x656)
         | None -> ());
        (match x649 with
         | Some x655 -> Ojs.set_prop_ascii x652 "inclusiveStart" (Ojs.bool_to_js x655)
         | None -> ());
        (match x650 with
         | Some x654 -> Ojs.set_prop_ascii x652 "inclusiveEnd" (Ojs.bool_to_js x654)
         | None -> ());
        (match x651 with
         | Some x653 -> Ojs.set_prop_ascii x652 "block" (Ojs.bool_to_js x653)
         | None -> ());
        t_of_js x652
      ;;
    end

    let replace : Replace_spec.t -> t =
      fun (x658 : Replace_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "replace"
           [| Replace_spec.t_to_js x658 |])
    ;;

    module Line_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x660 : Ojs.t) -> x660
      and t_to_js : t -> Ojs.t = fun (x659 : Ojs.t) -> x659

      let create : ?attributes:Ojs.t -> ?class_:string -> unit -> t =
        fun ?attributes:(x661 : Ojs.t option) ?class_:(x662 : string option) () ->
        let x663 = Ojs.empty_obj () in
        (match x661 with
         | Some x665 -> Ojs.set_prop_ascii x663 "attributes" x665
         | None -> ());
        (match x662 with
         | Some x664 -> Ojs.set_prop_ascii x663 "class" (Ojs.string_to_js x664)
         | None -> ());
        t_of_js x663
      ;;
    end

    let line : Line_spec.t -> t =
      fun (x666 : Line_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "line"
           [| Line_spec.t_to_js x666 |])
    ;;
  end

  module Decoration_set = struct
    type t = Decoration.t State.Range_set.t

    let rec t_of_js : Ojs.t -> t =
      fun (x669 : Ojs.t) -> State.Range_set.t_of_js Decoration.t_of_js x669

    and t_to_js : t -> Ojs.t =
      fun (x667 : Decoration.t State.Range_set.t) ->
      State.Range_set.t_to_js Decoration.t_to_js x667
    ;;
  end

  module Dom_event_handlers = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x672 : Ojs.t) -> x672
    and t_to_js : t -> Ojs.t = fun (x671 : Ojs.t) -> x671

    type handler = Dom_event.t -> editor_view -> unit

    let rec handler_of_js : Ojs.t -> handler =
      fun (x676 : Ojs.t) (x677 : Dom_event.t) (x678 : editor_view) ->
      (ignore : _) (Ojs.apply x676 [| Dom_event.t_to_js x677; editor_view_to_js x678 |])

    and handler_to_js : handler -> Ojs.t =
      fun (x673 : Dom_event.t -> editor_view -> unit) ->
      Ojs.fun_to_js 2 (fun (x674 : Ojs.t) (x675 : Ojs.t) ->
        x673 (Dom_event.t_of_js x674) (editor_view_of_js x675))
    ;;

    let create : ?paste:handler -> ?drop:handler -> unit -> t =
      fun ?paste:(x679 : handler option) ?drop:(x680 : handler option) () ->
      let x681 = Ojs.empty_obj () in
      (match x679 with
       | Some x683 -> Ojs.set_prop_ascii x681 "paste" (handler_to_js x683)
       | None -> ());
      (match x680 with
       | Some x682 -> Ojs.set_prop_ascii x681 "drop" (handler_to_js x682)
       | None -> ());
      t_of_js x681
    ;;
  end

  module Editor_view = struct
    type t = editor_view

    let rec t_of_js : Ojs.t -> t = fun (x685 : Ojs.t) -> editor_view_of_js x685
    and t_to_js : t -> Ojs.t = fun (x684 : editor_view) -> editor_view_to_js x684

    let create : Config.t -> t =
      fun (x686 : Config.t) ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           [| Config.t_to_js x686 |])
    ;;

    let dom : t -> Dom_html_element.t =
      fun (x687 : t) -> Dom_html_element.t_of_js (Ojs.get_prop_ascii (t_to_js x687) "dom")
    ;;

    let content_dom : t -> Dom_html_element.t =
      fun (x688 : t) ->
      Dom_html_element.t_of_js (Ojs.get_prop_ascii (t_to_js x688) "contentDOM")
    ;;

    let update_listener : (View_update.t -> unit) State.Facet.multi_out =
      State.Facet.multi_out_of_js
        (fun (x689 : Ojs.t) (x690 : View_update.t) ->
          (ignore : _) (Ojs.apply x689 [| View_update.t_to_js x690 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "updateListener")
    ;;

    let update : t -> State.Transaction.t list -> unit =
      fun (x693 : t) (x691 : State.Transaction.t list) ->
      (ignore : _)
        (Ojs.call
           (t_to_js x693)
           "update"
           [| Ojs.list_to_js State.Transaction.t_to_js x691 |])
    ;;

    let dispatch : t -> State.Transaction.t -> unit =
      fun (x695 : t) (x694 : State.Transaction.t) ->
      (ignore : _)
        (Ojs.call (t_to_js x695) "dispatch" [| State.Transaction.t_to_js x694 |])
    ;;

    let dispatch_specs : t -> State.Transaction_spec.t -> unit =
      fun (x697 : t) (x696 : State.Transaction_spec.t) ->
      (ignore : _)
        (Ojs.call (t_to_js x697) "dispatch" [| State.Transaction_spec.t_to_js x696 |])
    ;;

    let set_state : t -> State.Editor_state.t -> unit =
      fun (x699 : t) (x698 : State.Editor_state.t) ->
      (ignore : _)
        (Ojs.call (t_to_js x699) "setState" [| State.Editor_state.t_to_js x698 |])
    ;;

    let set_tab_focus_mode : t -> bool -> unit =
      fun (x701 : t) (x700 : bool) ->
      (ignore : _) (Ojs.call (t_to_js x701) "setTabFocusMode" [| Ojs.bool_to_js x700 |])
    ;;

    let state : t -> State.Editor_state.t =
      fun (x702 : t) ->
      State.Editor_state.t_of_js (Ojs.get_prop_ascii (t_to_js x702) "state")
    ;;

    let focus : t -> unit =
      fun (x703 : t) -> (ignore : _) (Ojs.call (t_to_js x703) "focus" [||])
    ;;

    let has_focus : t -> bool =
      fun (x704 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x704) "hasFocus")
    ;;

    let destroy : t -> unit =
      fun (x705 : t) -> (ignore : _) (Ojs.call (t_to_js x705) "destroy" [||])
    ;;

    let line_wrapping : State.Extension.t =
      State.Extension.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "lineWrapping")
    ;;

    let dom_event_handlers : Dom_event_handlers.t -> State.Extension.t =
      fun (x706 : Dom_event_handlers.t) ->
      State.Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "domEventHandlers"
           [| Dom_event_handlers.t_to_js x706 |])
    ;;

    let editable : (bool, bool) State.Facet.t =
      State.Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "editable")
    ;;

    let dark_theme : (bool, bool) State.Facet.t =
      State.Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "darkTheme")
    ;;

    let decorations : (Decoration_set.t, Decoration_set.t) State.Facet.t =
      State.Facet.t_of_js
        Decoration_set.t_of_js
        Decoration_set.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "decorations")
    ;;

    let decorations'
      : ( (editor_view -> Decoration_set.t) Callback.t
          , (editor_view -> Decoration_set.t) Callback.t )
          State.Facet.t
      =
      State.Facet.t_of_js
        (fun (x713 : Ojs.t) ->
          Callback.t_of_js
            (fun (x714 : Ojs.t) (x715 : editor_view) ->
              Decoration_set.t_of_js (Ojs.apply x714 [| editor_view_to_js x715 |]))
            x713)
        (fun (x716 : Ojs.t) ->
          Callback.t_of_js
            (fun (x717 : Ojs.t) (x718 : editor_view) ->
              Decoration_set.t_of_js (Ojs.apply x717 [| editor_view_to_js x718 |]))
            x716)
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "decorations")
    ;;

    let content_attributes : (Ojs.t, Ojs.t) State.Facet.t =
      State.Facet.t_of_js
        (fun (x719 : Ojs.t) -> x719)
        (fun (x720 : Ojs.t) -> x720)
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "contentAttributes")
    ;;

    module Viewport = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x722 : Ojs.t) -> x722
      and t_to_js : t -> Ojs.t = fun (x721 : Ojs.t) -> x721

      let from : t -> int =
        fun (x723 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x723) "from")
      ;;

      let to_ : t -> int =
        fun (x724 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x724) "to")
      ;;
    end

    let viewport : t -> Viewport.t =
      fun (x725 : t) -> Viewport.t_of_js (Ojs.get_prop_ascii (t_to_js x725) "viewport")
    ;;

    module Scroll_into_view_options = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x727 : Ojs.t) -> x727
      and t_to_js : t -> Ojs.t = fun (x726 : Ojs.t) -> x726

      let create : ?y:string -> unit -> t =
        fun ?y:(x728 : string option) () ->
        let x729 = Ojs.empty_obj () in
        (match x728 with
         | Some x730 -> Ojs.set_prop_ascii x729 "y" (Ojs.string_to_js x730)
         | None -> ());
        t_of_js x729
      ;;
    end

    let scroll_into_view
      : pos:int -> ?options:Scroll_into_view_options.t -> unit -> State.State_effect.t
      =
      fun ~pos:(x731 : int) ?options:(x732 : Scroll_into_view_options.t option) () ->
      State.State_effect.t_of_js
        (let x735 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
             "EditorView"
         in
         Ojs.call
           (Ojs.get_prop_ascii x735 "scrollIntoView")
           "apply"
           [| x735
            ; (let x733 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x733 "push" [| Ojs.int_to_js x731 |]);
               (match x732 with
                | Some x734 ->
                  (ignore : _)
                    (Ojs.call x733 "push" [| Scroll_into_view_options.t_to_js x734 |])
                | None -> ());
               x733)
           |])
    ;;

    module Theme_options = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x737 : Ojs.t) -> x737
      and t_to_js : t -> Ojs.t = fun (x736 : Ojs.t) -> x736

      let create : ?dark:bool -> unit -> t =
        fun ?dark:(x738 : bool option) () ->
        let x739 = Ojs.empty_obj () in
        (match x738 with
         | Some x740 -> Ojs.set_prop_ascii x739 "dark" (Ojs.bool_to_js x740)
         | None -> ());
        t_of_js x739
      ;;
    end

    let theme : spec:Ojs.t -> ?options:Theme_options.t -> unit -> State.Extension.t =
      fun ~spec:(x741 : Ojs.t) ?options:(x742 : Theme_options.t option) () ->
      State.Extension.t_of_js
        (let x745 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
             "EditorView"
         in
         Ojs.call
           (Ojs.get_prop_ascii x745 "theme")
           "apply"
           [| x745
            ; (let x743 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x743 "push" [| x741 |]);
               (match x742 with
                | Some x744 ->
                  (ignore : _) (Ojs.call x743 "push" [| Theme_options.t_to_js x744 |])
                | None -> ());
               x743)
           |])
    ;;

    let find_from_dom : Dom_html_element.t -> t option =
      fun (x746 : Dom_html_element.t) ->
      Ojs.option_of_js
        t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "findFromDOM"
           [| Dom_html_element.t_to_js x746 |])
    ;;
  end

  module Plugin_value = struct
    type 'v t =
      { update : (View_update.t -> unit) option
      ; destroy : (unit -> unit) option
      ; custom_state : 'v
      }

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x752 : Ojs.t) ->
      { update =
          Ojs.option_of_js
            (fun (x753 : Ojs.t) (x754 : View_update.t) ->
              (ignore : _) (Ojs.apply x753 [| View_update.t_to_js x754 |]))
            (Ojs.get_prop_ascii x752 "update")
      ; destroy =
          Ojs.option_of_js
            (fun (x755 : Ojs.t) () -> (ignore : _) (Ojs.apply x755 [||]))
            (Ojs.get_prop_ascii x752 "destroy")
      ; custom_state = __v_of_js (Ojs.get_prop_ascii x752 "customState")
      }

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x748 : __v t) ->
      Ojs.obj
        [| ( "update"
           , Ojs.option_to_js
               (fun (x749 : View_update.t -> unit) ->
                 Ojs.fun_to_js 1 (fun (x750 : Ojs.t) -> x749 (View_update.t_of_js x750)))
               x748.update )
         ; ( "destroy"
           , Ojs.option_to_js
               (fun (x751 : unit -> unit) -> Ojs.fun_to_js 1 (fun _ -> x751 ()))
               x748.destroy )
         ; "customState", __v_to_js x748.custom_state
        |]
    ;;
  end

  module Plugin_spec = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x757 : Ojs.t) -> x757

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x756 : Ojs.t) -> x756
    ;;

    let create : decorations:('v Plugin_value.t -> Decoration_set.t) option -> 'v t =
      fun ~decorations:(x758 : ('v Plugin_value.t -> Decoration_set.t) option) ->
      let x759 = Ojs.empty_obj () in
      Ojs.set_prop_ascii
        x759
        "decorations"
        (Ojs.option_to_js
           (fun (x761 : 'v Plugin_value.t -> Decoration_set.t) ->
             Ojs.fun_to_js 1 (fun (x762 : Ojs.t) ->
               Decoration_set.t_to_js (x761 (Plugin_value.t_of_js Obj.magic x762))))
           x758);
      t_of_js Obj.magic x759
    ;;
  end

  module View_plugin = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x765 : Ojs.t) -> x765

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x764 : Ojs.t) -> x764
    ;;

    let extension : 'v t -> State.Extension.t =
      fun (x766 : 'v t) ->
      State.Extension.t_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x766) "extension")
    ;;

    let define
      :  create:(Editor_view.t -> 'v Plugin_value.t) -> ?spec:'v Plugin_spec.t -> unit
      -> 'v t
      =
      fun ~create:(x768 : Editor_view.t -> 'v Plugin_value.t)
        ?spec:(x769 : 'v Plugin_spec.t option)
        () ->
      t_of_js
        Obj.magic
        (let x775 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
             "ViewPlugin"
         in
         Ojs.call
           (Ojs.get_prop_ascii x775 "define")
           "apply"
           [| x775
            ; (let x770 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _)
                 (Ojs.call
                    x770
                    "push"
                    [| Ojs.fun_to_js 1 (fun (x773 : Ojs.t) ->
                         Plugin_value.t_to_js Obj.magic (x768 (Editor_view.t_of_js x773)))
                    |]);
               (match x769 with
                | Some x771 ->
                  (ignore : _)
                    (Ojs.call x770 "push" [| Plugin_spec.t_to_js Obj.magic x771 |])
                | None -> ());
               x770)
           |])
    ;;
  end

  module Match_decorator = struct
    module Config = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x778 : Ojs.t) -> x778
      and t_to_js : t -> Ojs.t = fun (x777 : Ojs.t) -> x777

      let create
        :  regexp:RegExp.t -> ?decoration:Decoration.t
        -> ?decorate:
             (add:(from:int -> to_:int -> Decoration.t -> unit)
              -> from:int
              -> to_:int
              -> string option list
              -> Editor_view.t
              -> unit)
        -> ?max_length:int -> unit -> t
        =
        fun ~regexp:(x779 : RegExp.t)
          ?decoration:(x780 : Decoration.t option)
          ?decorate:
            (x781 :
               (add:(from:int -> to_:int -> Decoration.t -> unit)
                -> from:int
                -> to_:int
                -> string option list
                -> Editor_view.t
                -> unit)
                 option)
          ?max_length:(x782 : int option)
          () ->
        let x783 = Ojs.empty_obj () in
        Ojs.set_prop_ascii x783 "regexp" (RegExp.t_to_js x779);
        (match x780 with
         | Some x796 -> Ojs.set_prop_ascii x783 "decoration" (Decoration.t_to_js x796)
         | None -> ());
        (match x781 with
         | Some x785 ->
           Ojs.set_prop_ascii
             x783
             "decorate"
             (Ojs.fun_to_js
                5
                (fun
                    (x786 : Ojs.t)
                    (x790 : Ojs.t)
                    (x791 : Ojs.t)
                    (x792 : Ojs.t)
                    (x795 : Ojs.t)
                  ->
                   x785
                     ~add:
                       (fun
                         ~from:(x787 : int) ~to_:(x788 : int) (x789 : Decoration.t) ->
                       (ignore : _)
                         (Ojs.apply
                            x786
                            [| Ojs.int_to_js x787
                             ; Ojs.int_to_js x788
                             ; Decoration.t_to_js x789
                            |]))
                     ~from:(Ojs.int_of_js x790)
                     ~to_:(Ojs.int_of_js x791)
                     (Ojs.list_of_js
                        (fun (x793 : Ojs.t) -> Ojs.option_of_js Ojs.string_of_js x793)
                        x792)
                     (Editor_view.t_of_js x795)))
         | None -> ());
        (match x782 with
         | Some x784 -> Ojs.set_prop_ascii x783 "maxLength" (Ojs.int_to_js x784)
         | None -> ());
        t_of_js x783
      ;;
    end

    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x798 : Ojs.t) -> x798
    and t_to_js : t -> Ojs.t = fun (x797 : Ojs.t) -> x797

    let create : Config.t -> t =
      fun (x799 : Config.t) ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "MatchDecorator")
           [| Config.t_to_js x799 |])
    ;;

    let create_deco : t -> Editor_view.t -> Decoration_set.t =
      fun (x801 : t) (x800 : Editor_view.t) ->
      Decoration_set.t_of_js
        (Ojs.call (t_to_js x801) "createDeco" [| Editor_view.t_to_js x800 |])
    ;;
  end

  module Command = struct
    type t = Editor_view.t -> bool

    let rec t_of_js : Ojs.t -> t =
      fun (x804 : Ojs.t) (x805 : Editor_view.t) ->
      Ojs.bool_of_js (Ojs.apply x804 [| Editor_view.t_to_js x805 |])

    and t_to_js : t -> Ojs.t =
      fun (x802 : Editor_view.t -> bool) ->
      Ojs.fun_to_js 1 (fun (x803 : Ojs.t) ->
        Ojs.bool_to_js (x802 (Editor_view.t_of_js x803)))
    ;;
  end

  module Key_binding = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x807 : Ojs.t) -> x807
    and t_to_js : t -> Ojs.t = fun (x806 : Ojs.t) -> x806

    let create
      :  ?key:string -> ?mac:string -> ?win:string -> ?linux:string -> run:Command.t
      -> ?shift:Command.t -> ?scope:string -> ?prevent_default:bool
      -> ?stop_propagation:bool -> unit -> t
      =
      fun ?key:(x808 : string option)
        ?mac:(x809 : string option)
        ?win:(x810 : string option)
        ?linux:(x811 : string option)
        ~run:(x812 : Command.t)
        ?shift:(x813 : Command.t option)
        ?scope:(x814 : string option)
        ?prevent_default:(x815 : bool option)
        ?stop_propagation:(x816 : bool option)
        () ->
      let x817 = Ojs.empty_obj () in
      (match x808 with
       | Some x825 -> Ojs.set_prop_ascii x817 "key" (Ojs.string_to_js x825)
       | None -> ());
      (match x809 with
       | Some x824 -> Ojs.set_prop_ascii x817 "mac" (Ojs.string_to_js x824)
       | None -> ());
      (match x810 with
       | Some x823 -> Ojs.set_prop_ascii x817 "win" (Ojs.string_to_js x823)
       | None -> ());
      (match x811 with
       | Some x822 -> Ojs.set_prop_ascii x817 "linux" (Ojs.string_to_js x822)
       | None -> ());
      Ojs.set_prop_ascii x817 "run" (Command.t_to_js x812);
      (match x813 with
       | Some x821 -> Ojs.set_prop_ascii x817 "shift" (Command.t_to_js x821)
       | None -> ());
      (match x814 with
       | Some x820 -> Ojs.set_prop_ascii x817 "scope" (Ojs.string_to_js x820)
       | None -> ());
      (match x815 with
       | Some x819 -> Ojs.set_prop_ascii x817 "preventDefault" (Ojs.bool_to_js x819)
       | None -> ());
      (match x816 with
       | Some x818 -> Ojs.set_prop_ascii x817 "stopPropagation" (Ojs.bool_to_js x818)
       | None -> ());
      t_of_js x817
    ;;
  end

  let keymap : Key_binding.t list State.Facet.multi_out =
    State.Facet.multi_out_of_js
      (fun (x826 : Ojs.t) -> Ojs.list_of_js Key_binding.t_of_js x826)
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "keymap")
  ;;

  module Tooltip_view = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x829 : Ojs.t) -> x829
    and t_to_js : t -> Ojs.t = fun (x828 : Ojs.t) -> x828

    module Offset = struct
      type t =
        { x : int
        ; y : int
        }

      let rec t_of_js : Ojs.t -> t =
        fun (x831 : Ojs.t) ->
        { x = Ojs.int_of_js (Ojs.get_prop_ascii x831 "x")
        ; y = Ojs.int_of_js (Ojs.get_prop_ascii x831 "y")
        }

      and t_to_js : t -> Ojs.t =
        fun (x830 : t) ->
        Ojs.obj [| "x", Ojs.int_to_js x830.x; "y", Ojs.int_to_js x830.y |]
      ;;
    end

    let create
      :  dom:Dom_html_element.t -> ?offset:Offset.t -> ?overlap:bool -> ?resize:bool
      -> ?destroy:(unit -> unit) -> unit -> t
      =
      fun ~dom:(x832 : Dom_html_element.t)
        ?offset:(x833 : Offset.t option)
        ?overlap:(x834 : bool option)
        ?resize:(x835 : bool option)
        ?destroy:(x836 : (unit -> unit) option)
        () ->
      let x837 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x837 "dom" (Dom_html_element.t_to_js x832);
      (match x833 with
       | Some x841 -> Ojs.set_prop_ascii x837 "offset" (Offset.t_to_js x841)
       | None -> ());
      (match x834 with
       | Some x840 -> Ojs.set_prop_ascii x837 "overlap" (Ojs.bool_to_js x840)
       | None -> ());
      (match x835 with
       | Some x839 -> Ojs.set_prop_ascii x837 "resize" (Ojs.bool_to_js x839)
       | None -> ());
      (match x836 with
       | Some x838 ->
         Ojs.set_prop_ascii x837 "destroy" (Ojs.fun_to_js 1 (fun _ -> x838 ()))
       | None -> ());
      t_of_js x837
    ;;
  end

  module Tooltip = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x843 : Ojs.t) -> x843
    and t_to_js : t -> Ojs.t = fun (x842 : Ojs.t) -> x842

    let create
      :  pos:int -> ?end_:int -> create:(view:Editor_view.t -> Tooltip_view.t)
      -> ?above:bool -> ?strict_side:bool -> ?arrow:bool -> unit -> t
      =
      fun ~pos:(x844 : int)
        ?end_:(x845 : int option)
        ~create:(x846 : view:Editor_view.t -> Tooltip_view.t)
        ?above:(x847 : bool option)
        ?strict_side:(x848 : bool option)
        ?arrow:(x849 : bool option)
        () ->
      let x850 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x850 "pos" (Ojs.int_to_js x844);
      (match x845 with
       | Some x855 -> Ojs.set_prop_ascii x850 "end" (Ojs.int_to_js x855)
       | None -> ());
      Ojs.set_prop_ascii
        x850
        "create"
        (Ojs.fun_to_js 1 (fun (x854 : Ojs.t) ->
           Tooltip_view.t_to_js (x846 ~view:(Editor_view.t_of_js x854))));
      (match x847 with
       | Some x853 -> Ojs.set_prop_ascii x850 "above" (Ojs.bool_to_js x853)
       | None -> ());
      (match x848 with
       | Some x852 -> Ojs.set_prop_ascii x850 "strictSide" (Ojs.bool_to_js x852)
       | None -> ());
      (match x849 with
       | Some x851 -> Ojs.set_prop_ascii x850 "arrow" (Ojs.bool_to_js x851)
       | None -> ());
      t_of_js x850
    ;;

    let pos : t -> int =
      fun (x856 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x856) "pos")
    ;;

    let end_ : t -> int option =
      fun (x857 : t) ->
      Ojs.option_of_js Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x857) "end")
    ;;
  end

  module Hover_tooltip_source = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x860 : Ojs.t) -> x860
    and t_to_js : t -> Ojs.t = fun (x859 : Ojs.t) -> x859

    let of_sync_fn : (view:Editor_view.t -> pos:int -> side:int -> Tooltip.t option) -> t =
      fun (x861 : view:Editor_view.t -> pos:int -> side:int -> Tooltip.t option) ->
      t_of_js
        (Ojs.fun_to_js 3 (fun (x862 : Ojs.t) (x863 : Ojs.t) (x864 : Ojs.t) ->
           Ojs.option_to_js
             Tooltip.t_to_js
             (x861
                ~view:(Editor_view.t_of_js x862)
                ~pos:(Ojs.int_of_js x863)
                ~side:(Ojs.int_of_js x864))))
    ;;

    let of_async_fn
      :  (view:Editor_view.t
          -> pos:int
          -> side:int
          -> (Tooltip.t option With_conversion.t, 'e) Promise.t)
      -> t
      =
      fun (x866 :
            view:Editor_view.t
            -> pos:int
            -> side:int
            -> (Tooltip.t option With_conversion.t, 'e) Promise.t) ->
      t_of_js
        (Ojs.fun_to_js 3 (fun (x867 : Ojs.t) (x868 : Ojs.t) (x869 : Ojs.t) ->
           Promise.t_to_js
             (fun (x870 : Tooltip.t option With_conversion.t) ->
               With_conversion.t_to_js
                 (fun (x871 : Tooltip.t option) -> Ojs.option_to_js Tooltip.t_to_js x871)
                 x870)
             Obj.magic
             (x866
                ~view:(Editor_view.t_of_js x867)
                ~pos:(Ojs.int_of_js x868)
                ~side:(Ojs.int_of_js x869))))
    ;;
  end

  module Hover_tooltip_options = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x875 : Ojs.t) -> x875
    and t_to_js : t -> Ojs.t = fun (x874 : Ojs.t) -> x874

    let create : ?hide_on_change:bool -> ?hover_time:int -> unit -> t =
      fun ?hide_on_change:(x876 : bool option) ?hover_time:(x877 : int option) () ->
      let x878 = Ojs.empty_obj () in
      (match x876 with
       | Some x880 -> Ojs.set_prop_ascii x878 "hideOnChange" (Ojs.bool_to_js x880)
       | None -> ());
      (match x877 with
       | Some x879 -> Ojs.set_prop_ascii x878 "hoverTime" (Ojs.int_to_js x879)
       | None -> ());
      t_of_js x878
    ;;
  end

  let hover_tooltip
    :  source:Hover_tooltip_source.t -> ?options:Hover_tooltip_options.t -> unit
    -> State.Extension.t
    =
    fun ~source:(x881 : Hover_tooltip_source.t)
      ?options:(x882 : Hover_tooltip_options.t option)
      () ->
    State.Extension.t_of_js
      (let x885 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View"
       in
       Ojs.call
         (Ojs.get_prop_ascii x885 "hoverTooltip")
         "apply"
         [| x885
          ; (let x883 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (ignore : _) (Ojs.call x883 "push" [| Hover_tooltip_source.t_to_js x881 |]);
             (match x882 with
              | Some x884 ->
                (ignore : _)
                  (Ojs.call x883 "push" [| Hover_tooltip_options.t_to_js x884 |])
              | None -> ());
             x883)
         |])
  ;;

  let show_tooltip : Tooltip.t option State.Facet.multi_out =
    State.Facet.multi_out_of_js
      (fun (x886 : Ojs.t) -> Ojs.option_of_js Tooltip.t_of_js x886)
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "showTooltip")
  ;;

  module Layer_marker = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x889 : Ojs.t) -> x889
    and t_to_js : t -> Ojs.t = fun (x888 : Ojs.t) -> x888

    let create
      :  eq:(other:t -> bool) -> draw:(unit -> Dom_html_element.t)
      -> ?update:(Dom_html_element.t -> old_marker:t -> bool) -> unit -> t
      =
      fun ~eq:(x890 : other:t -> bool)
        ~draw:(x891 : unit -> Dom_html_element.t)
        ?update:(x892 : (Dom_html_element.t -> old_marker:t -> bool) option)
        () ->
      let x893 = Ojs.empty_obj () in
      Ojs.set_prop_ascii
        x893
        "eq"
        (Ojs.fun_to_js 1 (fun (x897 : Ojs.t) ->
           Ojs.bool_to_js (x890 ~other:(t_of_js x897))));
      Ojs.set_prop_ascii
        x893
        "draw"
        (Ojs.fun_to_js 1 (fun _ -> Dom_html_element.t_to_js (x891 ())));
      (match x892 with
       | Some x894 ->
         Ojs.set_prop_ascii
           x893
           "update"
           (Ojs.fun_to_js 2 (fun (x895 : Ojs.t) (x896 : Ojs.t) ->
              Ojs.bool_to_js
                (x894 (Dom_html_element.t_of_js x895) ~old_marker:(t_of_js x896))))
       | None -> ());
      t_of_js x893
    ;;
  end

  module Rectangle_marker = struct
    type t = Layer_marker.t

    let rec t_of_js : Ojs.t -> t = fun (x899 : Ojs.t) -> Layer_marker.t_of_js x899
    and t_to_js : t -> Ojs.t = fun (x898 : Layer_marker.t) -> Layer_marker.t_to_js x898

    let create
      :  class_name:string -> left:float -> top:float -> ?width:float -> height:float
      -> unit -> t
      =
      fun ~class_name:(x900 : string)
        ~left:(x901 : float)
        ~top:(x902 : float)
        ?width:(x903 : float option)
        ~height:(x904 : float)
        () ->
      t_of_js
        (Ojs.new_obj_arr
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "RectangleMarker")
           (let x905 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
            (ignore : _) (Ojs.call x905 "push" [| Ojs.string_to_js x900 |]);
            (ignore : _) (Ojs.call x905 "push" [| Ojs.float_to_js x901 |]);
            (ignore : _) (Ojs.call x905 "push" [| Ojs.float_to_js x902 |]);
            (match x903 with
             | Some x906 -> (ignore : _) (Ojs.call x905 "push" [| Ojs.float_to_js x906 |])
             | None -> ());
            (ignore : _) (Ojs.call x905 "push" [| Ojs.float_to_js x904 |]);
            x905))
    ;;

    let left : t -> float =
      fun (x907 : t) -> Ojs.float_of_js (Ojs.get_prop_ascii (t_to_js x907) "left")
    ;;

    let top : t -> float =
      fun (x908 : t) -> Ojs.float_of_js (Ojs.get_prop_ascii (t_to_js x908) "top")
    ;;

    let width : t -> float option =
      fun (x909 : t) ->
      Ojs.option_of_js Ojs.float_of_js (Ojs.get_prop_ascii (t_to_js x909) "width")
    ;;

    let height : t -> float =
      fun (x911 : t) -> Ojs.float_of_js (Ojs.get_prop_ascii (t_to_js x911) "height")
    ;;

    let for_range
      : view:editor_view -> class_name:string -> range:State.Selection_range.t -> t list
      =
      fun ~view:(x912 : editor_view)
        ~class_name:(x913 : string)
        ~range:(x914 : State.Selection_range.t) ->
      Ojs.list_of_js
        t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "RectangleMarker")
           "forRange"
           [| editor_view_to_js x912
            ; Ojs.string_to_js x913
            ; State.Selection_range.t_to_js x914
           |])
    ;;
  end

  module Layer_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x917 : Ojs.t) -> x917
    and t_to_js : t -> Ojs.t = fun (x916 : Ojs.t) -> x916

    let create
      :  ?above:bool -> ?class_:string
      -> update:(update:View_update.t -> layer:Dom_html_element.t -> bool)
      -> ?update_on_doc_view_update:bool
      -> markers:(view:editor_view -> Layer_marker.t list)
      -> ?mount:(layer:Dom_html_element.t -> view:editor_view -> unit)
      -> ?destroy:(layer:Dom_html_element.t -> view:editor_view -> unit) -> unit -> t
      =
      fun ?above:(x918 : bool option)
        ?class_:(x919 : string option)
        ~update:(x920 : update:View_update.t -> layer:Dom_html_element.t -> bool)
        ?update_on_doc_view_update:(x921 : bool option)
        ~markers:(x922 : view:editor_view -> Layer_marker.t list)
        ?mount:(x923 : (layer:Dom_html_element.t -> view:editor_view -> unit) option)
        ?destroy:(x924 : (layer:Dom_html_element.t -> view:editor_view -> unit) option)
        () ->
      let x925 = Ojs.empty_obj () in
      (match x918 with
       | Some x938 -> Ojs.set_prop_ascii x925 "above" (Ojs.bool_to_js x938)
       | None -> ());
      (match x919 with
       | Some x937 -> Ojs.set_prop_ascii x925 "class" (Ojs.string_to_js x937)
       | None -> ());
      Ojs.set_prop_ascii
        x925
        "update"
        (Ojs.fun_to_js 2 (fun (x935 : Ojs.t) (x936 : Ojs.t) ->
           Ojs.bool_to_js
             (x920
                ~update:(View_update.t_of_js x935)
                ~layer:(Dom_html_element.t_of_js x936))));
      (match x921 with
       | Some x934 ->
         Ojs.set_prop_ascii x925 "updateOnDocViewUpdate" (Ojs.bool_to_js x934)
       | None -> ());
      Ojs.set_prop_ascii
        x925
        "markers"
        (Ojs.fun_to_js 1 (fun (x932 : Ojs.t) ->
           Ojs.list_to_js Layer_marker.t_to_js (x922 ~view:(editor_view_of_js x932))));
      (match x923 with
       | Some x929 ->
         Ojs.set_prop_ascii
           x925
           "mount"
           (Ojs.fun_to_js 2 (fun (x930 : Ojs.t) (x931 : Ojs.t) ->
              x929 ~layer:(Dom_html_element.t_of_js x930) ~view:(editor_view_of_js x931)))
       | None -> ());
      (match x924 with
       | Some x926 ->
         Ojs.set_prop_ascii
           x925
           "destroy"
           (Ojs.fun_to_js 2 (fun (x927 : Ojs.t) (x928 : Ojs.t) ->
              x926 ~layer:(Dom_html_element.t_of_js x927) ~view:(editor_view_of_js x928)))
       | None -> ());
      t_of_js x925
    ;;
  end

  let layer : Layer_config.t -> State.Extension.t =
    fun (x939 : Layer_config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "layer"
         [| Layer_config.t_to_js x939 |])
  ;;
end

module Autocomplete = struct
  module Completion = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x941 : Ojs.t) -> x941
    and t_to_js : t -> Ojs.t = fun (x940 : Ojs.t) -> x940

    let create
      :  label:string -> ?detail:string
      -> ?info:[ `Str of string | `Dom of t -> Dom_html_element.t ] -> ?type_:string
      -> ?boost:int
      -> ?apply:
           [ `Str of string
           | `Fn of view:View.Editor_view.t -> completion:t -> from:int -> to_:int -> unit
           ]
      -> unit -> t
      =
      fun ~label:(x942 : string)
        ?detail:(x943 : string option)
        ?info:(x944 : [ `Str of string | `Dom of t -> Dom_html_element.t ] option)
        ?type_:(x945 : string option)
        ?boost:(x946 : int option)
        ?apply:
          (x947 :
             [ `Str of string
             | `Fn of
               view:View.Editor_view.t -> completion:t -> from:int -> to_:int -> unit
             ]
               option)
        () ->
      let x948 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x948 "label" (Ojs.string_to_js x942);
      (match x943 with
       | Some x962 -> Ojs.set_prop_ascii x948 "detail" (Ojs.string_to_js x962)
       | None -> ());
      (match x944 with
       | Some x958 ->
         Ojs.set_prop_ascii
           x948
           "info"
           (match x958 with
            | `Str x959 -> Ojs.string_to_js x959
            | `Dom x960 ->
              Ojs.fun_to_js 1 (fun (x961 : Ojs.t) ->
                Dom_html_element.t_to_js (x960 (t_of_js x961))))
       | None -> ());
      (match x945 with
       | Some x957 -> Ojs.set_prop_ascii x948 "type" (Ojs.string_to_js x957)
       | None -> ());
      (match x946 with
       | Some x956 -> Ojs.set_prop_ascii x948 "boost" (Ojs.int_to_js x956)
       | None -> ());
      (match x947 with
       | Some x949 ->
         Ojs.set_prop_ascii
           x948
           "apply"
           (match x949 with
            | `Str x950 -> Ojs.string_to_js x950
            | `Fn x951 ->
              Ojs.fun_to_js
                4
                (fun (x952 : Ojs.t) (x953 : Ojs.t) (x954 : Ojs.t) (x955 : Ojs.t) ->
                   x951
                     ~view:(View.Editor_view.t_of_js x952)
                     ~completion:(t_of_js x953)
                     ~from:(Ojs.int_of_js x954)
                     ~to_:(Ojs.int_of_js x955)))
       | None -> ());
      t_of_js x948
    ;;

    let label : t -> string =
      fun (x963 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x963) "label")
    ;;

    let type_ : t -> string option =
      fun (x964 : t) ->
      Ojs.option_of_js Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x964) "type")
    ;;
  end

  module CompletionContext = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x967 : Ojs.t) -> x967
    and t_to_js : t -> Ojs.t = fun (x966 : Ojs.t) -> x966

    let state : t -> State.Editor_state.t =
      fun (x968 : t) ->
      State.Editor_state.t_of_js (Ojs.get_prop_ascii (t_to_js x968) "state")
    ;;

    let pos : t -> int =
      fun (x969 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x969) "pos")
    ;;

    let explicit : t -> bool =
      fun (x970 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x970) "explicit")
    ;;
  end

  module CompletionResult = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x972 : Ojs.t) -> x972
    and t_to_js : t -> Ojs.t = fun (x971 : Ojs.t) -> x971

    let create
      :  from:int -> ?to_:int -> options:Completion.t list
      -> ?valid_for:
           [ `Regex of RegExp.t
           | `Fn of string -> from:int -> to_:int -> State.Editor_state.t -> bool
           ]
      -> ?filter:bool -> unit -> t
      =
      fun ~from:(x973 : int)
        ?to_:(x974 : int option)
        ~options:(x975 : Completion.t list)
        ?valid_for:
          (x976 :
             [ `Regex of RegExp.t
             | `Fn of string -> from:int -> to_:int -> State.Editor_state.t -> bool
             ]
               option)
        ?filter:(x977 : bool option)
        () ->
      let x978 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x978 "from" (Ojs.int_to_js x973);
      (match x974 with
       | Some x988 -> Ojs.set_prop_ascii x978 "to" (Ojs.int_to_js x988)
       | None -> ());
      Ojs.set_prop_ascii x978 "options" (Ojs.list_to_js Completion.t_to_js x975);
      (match x976 with
       | Some x980 ->
         Ojs.set_prop_ascii
           x978
           "validFor"
           (match x980 with
            | `Regex x981 -> RegExp.t_to_js x981
            | `Fn x982 ->
              Ojs.fun_to_js
                4
                (fun (x983 : Ojs.t) (x984 : Ojs.t) (x985 : Ojs.t) (x986 : Ojs.t) ->
                   Ojs.bool_to_js
                     (x982
                        (Ojs.string_of_js x983)
                        ~from:(Ojs.int_of_js x984)
                        ~to_:(Ojs.int_of_js x985)
                        (State.Editor_state.t_of_js x986))))
       | None -> ());
      (match x977 with
       | Some x979 -> Ojs.set_prop_ascii x978 "filter" (Ojs.bool_to_js x979)
       | None -> ());
      t_of_js x978
    ;;
  end

  module CompletionSource = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x990 : Ojs.t) -> x990
    and t_to_js : t -> Ojs.t = fun (x989 : Ojs.t) -> x989

    let of_sync_fun : (CompletionContext.t -> CompletionResult.t) -> t =
      fun (x991 : CompletionContext.t -> CompletionResult.t) ->
      t_of_js
        (Ojs.fun_to_js 1 (fun (x992 : Ojs.t) ->
           CompletionResult.t_to_js (x991 (CompletionContext.t_of_js x992))))
    ;;

    let of_promise_fun
      : (CompletionContext.t -> (CompletionResult.t, 'e) Promise.t option) -> t
      =
      fun (x993 : CompletionContext.t -> (CompletionResult.t, 'e) Promise.t option) ->
      t_of_js
        (Ojs.fun_to_js 1 (fun (x994 : Ojs.t) ->
           Ojs.option_to_js
             (fun (x995 : (CompletionResult.t, 'e) Promise.t) ->
               Promise.t_to_js CompletionResult.t_to_js Obj.magic x995)
             (x993 (CompletionContext.t_of_js x994))))
    ;;
  end

  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x999 : Ojs.t) -> x999
    and t_to_js : t -> Ojs.t = fun (x998 : Ojs.t) -> x998

    module Add_to_options_parameters = struct
      type t =
        { render : Completion.t -> State.Editor_state.t -> Dom_html_element.t option
        ; position : int
        }

      let rec t_of_js : Ojs.t -> t =
        fun (x1004 : Ojs.t) ->
        { render =
            (fun (x1005 : Completion.t) (x1006 : State.Editor_state.t) ->
              Ojs.option_of_js
                Dom_html_element.t_of_js
                (Ojs.apply
                   (Ojs.get_prop_ascii x1004 "render")
                   [| Completion.t_to_js x1005; State.Editor_state.t_to_js x1006 |]))
        ; position = Ojs.int_of_js (Ojs.get_prop_ascii x1004 "position")
        }

      and t_to_js : t -> Ojs.t =
        fun (x1000 : t) ->
        Ojs.obj
          [| ( "render"
             , Ojs.fun_to_js 2 (fun (x1001 : Ojs.t) (x1002 : Ojs.t) ->
                 Ojs.option_to_js
                   Dom_html_element.t_to_js
                   (x1000.render
                      (Completion.t_of_js x1001)
                      (State.Editor_state.t_of_js x1002))) )
           ; "position", Ojs.int_to_js x1000.position
          |]
      ;;
    end

    let create
      :  ?activate_on_typing:bool -> ?override:CompletionSource.t list
      -> ?max_rendered_options:int -> ?default_keymap:bool -> ?icons:bool
      -> ?add_to_options:Add_to_options_parameters.t list -> unit -> t
      =
      fun ?activate_on_typing:(x1008 : bool option)
        ?override:(x1009 : CompletionSource.t list option)
        ?max_rendered_options:(x1010 : int option)
        ?default_keymap:(x1011 : bool option)
        ?icons:(x1012 : bool option)
        ?add_to_options:(x1013 : Add_to_options_parameters.t list option)
        () ->
      let x1014 = Ojs.empty_obj () in
      (match x1008 with
       | Some x1022 -> Ojs.set_prop_ascii x1014 "activateOnTyping" (Ojs.bool_to_js x1022)
       | None -> ());
      (match x1009 with
       | Some x1020 ->
         Ojs.set_prop_ascii
           x1014
           "override"
           (Ojs.list_to_js CompletionSource.t_to_js x1020)
       | None -> ());
      (match x1010 with
       | Some x1019 -> Ojs.set_prop_ascii x1014 "maxRenderedOptions" (Ojs.int_to_js x1019)
       | None -> ());
      (match x1011 with
       | Some x1018 -> Ojs.set_prop_ascii x1014 "defaultKeymap" (Ojs.bool_to_js x1018)
       | None -> ());
      (match x1012 with
       | Some x1017 -> Ojs.set_prop_ascii x1014 "icons" (Ojs.bool_to_js x1017)
       | None -> ());
      (match x1013 with
       | Some x1015 ->
         Ojs.set_prop_ascii
           x1014
           "addToOptions"
           (Ojs.list_to_js Add_to_options_parameters.t_to_js x1015)
       | None -> ());
      t_of_js x1014
    ;;
  end

  module Move_completion_selection_by = struct
    type t =
      | Option
      | Page

    let rec t_of_js : Ojs.t -> t =
      fun (x1024 : Ojs.t) ->
      let x1025 = x1024 in
      match Ojs.string_of_js x1025 with
      | "option" -> Option
      | "page" -> Page
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x1023 : t) ->
      match x1023 with
      | Option -> Ojs.string_to_js "option"
      | Page -> Ojs.string_to_js "page"
    ;;
  end

  let autocompletion : Config.t -> State.Extension.t =
    fun (x1026 : Config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "autocompletion"
         [| Config.t_to_js x1026 |])
  ;;

  let completion_status : State.Editor_state.t -> string option =
    fun (x1027 : State.Editor_state.t) ->
    Ojs.option_of_js
      Ojs.string_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "completionStatus"
         [| State.Editor_state.t_to_js x1027 |])
  ;;

  let start_completion : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "startCompletion")
  ;;

  let close_completion : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "closeCompletion")
  ;;

  let accept_completion : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "acceptCompletion")
  ;;

  let move_completion_selection
    : forward:bool -> ?by:Move_completion_selection_by.t -> unit -> View.Command.t
    =
    fun ~forward:(x1029 : bool) ?by:(x1030 : Move_completion_selection_by.t option) () ->
    View.Command.t_of_js
      (let x1033 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete"
       in
       Ojs.call
         (Ojs.get_prop_ascii x1033 "moveCompletionSelection")
         "apply"
         [| x1033
          ; (let x1031 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (ignore : _) (Ojs.call x1031 "push" [| Ojs.bool_to_js x1029 |]);
             (match x1030 with
              | Some x1032 ->
                (ignore : _)
                  (Ojs.call x1031 "push" [| Move_completion_selection_by.t_to_js x1032 |])
              | None -> ());
             x1031)
         |])
  ;;

  let completion_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "completionKeymap")
  ;;
end

module Lint = struct
  module Diagnostic = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1036 : Ojs.t) -> x1036
    and t_to_js : t -> Ojs.t = fun (x1035 : Ojs.t) -> x1035

    module Severity = struct
      type t =
        | Error
        | Hint
        | Info
        | Warning

      let rec t_of_js : Ojs.t -> t =
        fun (x1038 : Ojs.t) ->
        let x1039 = x1038 in
        match Ojs.string_of_js x1039 with
        | "error" -> Error
        | "hint" -> Hint
        | "info" -> Info
        | "warning" -> Warning
        | _ -> assert false

      and t_to_js : t -> Ojs.t =
        fun (x1037 : t) ->
        match x1037 with
        | Error -> Ojs.string_to_js "error"
        | Hint -> Ojs.string_to_js "hint"
        | Info -> Ojs.string_to_js "info"
        | Warning -> Ojs.string_to_js "warning"
      ;;
    end

    let create
      :  from:int -> to_:int -> severity:Severity.t -> ?mark_class:string
      -> ?source:string -> message:string -> unit -> t
      =
      fun ~from:(x1040 : int)
        ~to_:(x1041 : int)
        ~severity:(x1042 : Severity.t)
        ?mark_class:(x1043 : string option)
        ?source:(x1044 : string option)
        ~message:(x1045 : string)
        () ->
      let x1046 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x1046 "from" (Ojs.int_to_js x1040);
      Ojs.set_prop_ascii x1046 "to" (Ojs.int_to_js x1041);
      Ojs.set_prop_ascii x1046 "severity" (Severity.t_to_js x1042);
      (match x1043 with
       | Some x1048 -> Ojs.set_prop_ascii x1046 "markClass" (Ojs.string_to_js x1048)
       | None -> ());
      (match x1044 with
       | Some x1047 -> Ojs.set_prop_ascii x1046 "source" (Ojs.string_to_js x1047)
       | None -> ());
      Ojs.set_prop_ascii x1046 "message" (Ojs.string_to_js x1045);
      t_of_js x1046
    ;;
  end

  let set_diagnostics
    :  state:State.Editor_state.t -> diagnostics:Diagnostic.t list
    -> State.Transaction_spec.t
    =
    fun ~state:(x1049 : State.Editor_state.t) ~diagnostics:(x1050 : Diagnostic.t list) ->
    State.Transaction_spec.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lint")
         "setDiagnostics"
         [| State.Editor_state.t_to_js x1049; Ojs.list_to_js Diagnostic.t_to_js x1050 |])
  ;;

  let diagnostic_count : State.Editor_state.t -> int =
    fun (x1052 : State.Editor_state.t) ->
    Ojs.int_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lint")
         "diagnosticCount"
         [| State.Editor_state.t_to_js x1052 |])
  ;;

  let lint_gutter : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lint")
         "lintGutter"
         [||])
  ;;
end

module Commands = struct
  let standard_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "standardKeymap")
  ;;

  let default_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "defaultKeymap")
  ;;

  let emacs_style_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "emacsStyleKeymap")
  ;;

  let cursor_char_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorCharLeft")
  ;;

  let select_char_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectCharLeft")
  ;;

  let cursor_group_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorGroupLeft")
  ;;

  let select_group_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectGroupLeft")
  ;;

  let cursor_char_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorCharRight")
  ;;

  let select_char_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectCharRight")
  ;;

  let cursor_group_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorGroupRight")
  ;;

  let select_group_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectGroupRight")
  ;;

  let cursor_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineUp")
  ;;

  let select_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineUp")
  ;;

  let cursor_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineDown")
  ;;

  let select_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineDown")
  ;;

  let cursor_page_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorPageUp")
  ;;

  let select_page_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectPageUp")
  ;;

  let cursor_page_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorPageDown")
  ;;

  let select_page_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectPageDown")
  ;;

  let cursor_line_boundary_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineBoundaryBackward")
  ;;

  let select_line_boundary_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineBoundaryBackward")
  ;;

  let cursor_doc_start : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorDocStart")
  ;;

  let select_doc_start : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectDocStart")
  ;;

  let cursor_line_boundary_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineBoundaryForward")
  ;;

  let select_line_boundary_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineBoundaryForward")
  ;;

  let cursor_doc_end : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorDocEnd")
  ;;

  let select_doc_end : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectDocEnd")
  ;;

  let insert_newline_and_indent : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "insertNewlineAndIndent")
  ;;

  let insert_blank_line : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "insertBlankLine")
  ;;

  let select_all : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectAll")
  ;;

  let delete_char_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteCharBackward")
  ;;

  let delete_char_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteCharForward")
  ;;

  let delete_group_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteGroupBackward")
  ;;

  let delete_group_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteGroupForward")
  ;;

  let cursor_syntax_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorSyntaxLeft")
  ;;

  let select_syntax_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectSyntaxLeft")
  ;;

  let cursor_syntax_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorSyntaxRight")
  ;;

  let select_syntax_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectSyntaxRight")
  ;;

  let move_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "moveLineUp")
  ;;

  let copy_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "copyLineUp")
  ;;

  let move_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "moveLineDown")
  ;;

  let copy_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "copyLineDown")
  ;;

  let simplify_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "simplifySelection")
  ;;

  let select_line : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLine")
  ;;

  let select_parent_syntax : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectParentSyntax")
  ;;

  let indent_less : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "indentLess")
  ;;

  let indent_more : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "indentMore")
  ;;

  let indent_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "indentSelection")
  ;;

  let delete_line : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteLine")
  ;;

  let cursor_matching_bracket : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorMatchingBracket")
  ;;

  let toggle_comment : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "toggleComment")
  ;;
end

module Gutter = struct
  module Block_info = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1057 : Ojs.t) -> x1057
    and t_to_js : t -> Ojs.t = fun (x1056 : Ojs.t) -> x1056

    let from : t -> int =
      fun (x1058 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1058) "from")
    ;;

    let length : t -> int =
      fun (x1059 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1059) "length")
    ;;

    let top : t -> int =
      fun (x1060 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1060) "top")
    ;;

    let height : t -> int =
      fun (x1061 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1061) "height")
    ;;

    let to_ : t -> int =
      fun (x1062 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1062) "to")
    ;;

    let bottom : t -> int =
      fun (x1063 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1063) "bottom")
    ;;
  end

  module Line_numbers_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1065 : Ojs.t) -> x1065
    and t_to_js : t -> Ojs.t = fun (x1064 : Ojs.t) -> x1064

    module Dom_event_handlers = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x1067 : Ojs.t) -> x1067
      and t_to_js : t -> Ojs.t = fun (x1066 : Ojs.t) -> x1066

      let create : ?mousedown:(View.Editor_view.t -> Block_info.t -> unit) -> unit -> t =
        fun ?mousedown:(x1068 : (View.Editor_view.t -> Block_info.t -> unit) option) () ->
        let x1069 = Ojs.empty_obj () in
        (match x1068 with
         | Some x1070 ->
           Ojs.set_prop_ascii
             x1069
             "mousedown"
             (Ojs.fun_to_js 2 (fun (x1071 : Ojs.t) (x1072 : Ojs.t) ->
                x1070 (View.Editor_view.t_of_js x1071) (Block_info.t_of_js x1072)))
         | None -> ());
        t_of_js x1069
      ;;
    end

    let create
      :  ?format_number:(int -> State.Editor_state.t -> string)
      -> ?dom_event_handlers:Dom_event_handlers.t -> unit -> t
      =
      fun ?format_number:(x1073 : (int -> State.Editor_state.t -> string) option)
        ?dom_event_handlers:(x1074 : Dom_event_handlers.t option)
        () ->
      let x1075 = Ojs.empty_obj () in
      (match x1073 with
       | Some x1077 ->
         Ojs.set_prop_ascii
           x1075
           "formatNumber"
           (Ojs.fun_to_js 2 (fun (x1078 : Ojs.t) (x1079 : Ojs.t) ->
              Ojs.string_to_js
                (x1077 (Ojs.int_of_js x1078) (State.Editor_state.t_of_js x1079))))
       | None -> ());
      (match x1074 with
       | Some x1076 ->
         Ojs.set_prop_ascii x1075 "domEventHandlers" (Dom_event_handlers.t_to_js x1076)
       | None -> ());
      t_of_js x1075
    ;;
  end

  let line_numbers : Line_numbers_config.t -> State.Extension.t =
    fun (x1080 : Line_numbers_config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "lineNumbers"
         [| Line_numbers_config.t_to_js x1080 |])
  ;;

  let highlight_active_line_gutter : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "highlightActiveLineGutter"
         [||])
  ;;

  module Gutter_marker = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1082 : Ojs.t) -> x1082
    and t_to_js : t -> Ojs.t = fun (x1081 : Ojs.t) -> x1081
  end

  module Gutter_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1084 : Ojs.t) -> x1084
    and t_to_js : t -> Ojs.t = fun (x1083 : Ojs.t) -> x1083

    let create
      :  ?class_:string -> ?render_empty_elements:bool
      -> ?markers:(View.Editor_view.t -> Gutter_marker.t State.Range_set.t)
      -> ?line_marker:(View.Editor_view.t -> Block_info.t -> Gutter_marker.t option)
      -> ?line_marker_change:(View.View_update.t -> bool)
      -> ?initial_spacer:(View.Editor_view.t -> Gutter_marker.t)
      -> ?update_spacer:
           (spacer:Gutter_marker.t -> update:View.View_update.t -> Gutter_marker.t)
      -> ?dom_event_handlers:Line_numbers_config.Dom_event_handlers.t -> unit -> t
      =
      fun ?class_:(x1085 : string option)
        ?render_empty_elements:(x1086 : bool option)
        ?markers:
          (x1087 : (View.Editor_view.t -> Gutter_marker.t State.Range_set.t) option)
        ?line_marker:
          (x1088 : (View.Editor_view.t -> Block_info.t -> Gutter_marker.t option) option)
        ?line_marker_change:(x1089 : (View.View_update.t -> bool) option)
        ?initial_spacer:(x1090 : (View.Editor_view.t -> Gutter_marker.t) option)
        ?update_spacer:
          (x1091 :
             (spacer:Gutter_marker.t -> update:View.View_update.t -> Gutter_marker.t)
               option)
        ?dom_event_handlers:(x1092 : Line_numbers_config.Dom_event_handlers.t option)
        () ->
      let x1093 = Ojs.empty_obj () in
      (match x1085 with
       | Some x1110 -> Ojs.set_prop_ascii x1093 "class" (Ojs.string_to_js x1110)
       | None -> ());
      (match x1086 with
       | Some x1109 ->
         Ojs.set_prop_ascii x1093 "renderEmptyElements" (Ojs.bool_to_js x1109)
       | None -> ());
      (match x1087 with
       | Some x1106 ->
         Ojs.set_prop_ascii
           x1093
           "markers"
           (Ojs.fun_to_js 1 (fun (x1107 : Ojs.t) ->
              State.Range_set.t_to_js
                Gutter_marker.t_to_js
                (x1106 (View.Editor_view.t_of_js x1107))))
       | None -> ());
      (match x1088 with
       | Some x1102 ->
         Ojs.set_prop_ascii
           x1093
           "lineMarker"
           (Ojs.fun_to_js 2 (fun (x1103 : Ojs.t) (x1104 : Ojs.t) ->
              Ojs.option_to_js
                Gutter_marker.t_to_js
                (x1102 (View.Editor_view.t_of_js x1103) (Block_info.t_of_js x1104))))
       | None -> ());
      (match x1089 with
       | Some x1100 ->
         Ojs.set_prop_ascii
           x1093
           "lineMarkerChange"
           (Ojs.fun_to_js 1 (fun (x1101 : Ojs.t) ->
              Ojs.bool_to_js (x1100 (View.View_update.t_of_js x1101))))
       | None -> ());
      (match x1090 with
       | Some x1098 ->
         Ojs.set_prop_ascii
           x1093
           "initialSpacer"
           (Ojs.fun_to_js 1 (fun (x1099 : Ojs.t) ->
              Gutter_marker.t_to_js (x1098 (View.Editor_view.t_of_js x1099))))
       | None -> ());
      (match x1091 with
       | Some x1095 ->
         Ojs.set_prop_ascii
           x1093
           "updateSpacer"
           (Ojs.fun_to_js 2 (fun (x1096 : Ojs.t) (x1097 : Ojs.t) ->
              Gutter_marker.t_to_js
                (x1095
                   ~spacer:(Gutter_marker.t_of_js x1096)
                   ~update:(View.View_update.t_of_js x1097))))
       | None -> ());
      (match x1092 with
       | Some x1094 ->
         Ojs.set_prop_ascii
           x1093
           "domEventHandlers"
           (Line_numbers_config.Dom_event_handlers.t_to_js x1094)
       | None -> ());
      t_of_js x1093
    ;;
  end

  let gutter : Gutter_config.t -> State.Extension.t =
    fun (x1111 : Gutter_config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "gutter"
         [| Gutter_config.t_to_js x1111 |])
  ;;
end

module History = struct
  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1113 : Ojs.t) -> x1113
    and t_to_js : t -> Ojs.t = fun (x1112 : Ojs.t) -> x1112

    let create : ?min_depth:int -> ?new_group_delay:int -> unit -> t =
      fun ?min_depth:(x1114 : int option) ?new_group_delay:(x1115 : int option) () ->
      let x1116 = Ojs.empty_obj () in
      (match x1114 with
       | Some x1118 -> Ojs.set_prop_ascii x1116 "minDepth" (Ojs.int_to_js x1118)
       | None -> ());
      (match x1115 with
       | Some x1117 -> Ojs.set_prop_ascii x1116 "newGroupDelay" (Ojs.int_to_js x1117)
       | None -> ());
      t_of_js x1116
    ;;
  end

  let history : Config.t -> State.Extension.t =
    fun (x1119 : Config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "history"
         [| Config.t_to_js x1119 |])
  ;;

  let undo : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "undo")
  ;;

  let redo : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "redo")
  ;;

  let undo_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "undoSelection")
  ;;

  let redo_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "redoSelection")
  ;;

  let history_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "historyKeymap")
  ;;
end

module Search = struct
  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1122 : Ojs.t) -> x1122
    and t_to_js : t -> Ojs.t = fun (x1121 : Ojs.t) -> x1121

    let create : ?top:bool -> ?match_case:bool -> unit -> t =
      fun ?top:(x1123 : bool option) ?match_case:(x1124 : bool option) () ->
      let x1125 = Ojs.empty_obj () in
      (match x1123 with
       | Some x1127 -> Ojs.set_prop_ascii x1125 "top" (Ojs.bool_to_js x1127)
       | None -> ());
      (match x1124 with
       | Some x1126 -> Ojs.set_prop_ascii x1125 "matchCase" (Ojs.bool_to_js x1126)
       | None -> ());
      t_of_js x1125
    ;;
  end

  let search : Config.t -> State.Extension.t =
    fun (x1128 : Config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "search"
         [| Config.t_to_js x1128 |])
  ;;

  let find_next : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "findNext")
  ;;

  let find_previous : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "findPrevious")
  ;;

  let select_matches : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "selectMatches")
  ;;

  let replace_next : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "replaceNext")
  ;;

  let replace_all : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "replaceAll")
  ;;

  let open_search_panel : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "openSearchPanel")
  ;;

  let close_search_panel : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "closeSearchPanel")
  ;;

  let goto_line : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "gotoLine")
  ;;
end

module Basic_setup = struct
  let basic_setup : State.Extension.t =
    State.Extension.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Basic_setup")
         "basicSetup")
  ;;

  let minimal_setup : State.Extension.t =
    State.Extension.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Basic_setup")
         "minimalSetup")
  ;;
end

module Language = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1130 : Ojs.t) -> x1130
  and t_to_js : t -> Ojs.t = fun (x1129 : Ojs.t) -> x1129

  let extension : t -> State.Extension.t =
    fun (x1131 : t) ->
    State.Extension.t_of_js (Ojs.get_prop_ascii (t_to_js x1131) "extension")
  ;;
end

module Stream_parser = struct
  module String_stream = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1133 : Ojs.t) -> x1133
    and t_to_js : t -> Ojs.t = fun (x1132 : Ojs.t) -> x1132

    let new_string_stream : string:string -> tab_size:int -> indent_unit:int -> t =
      fun ~string:(x1134 : string) ~tab_size:(x1135 : int) ~indent_unit:(x1136 : int) ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
              "StringStream")
           [| Ojs.string_to_js x1134; Ojs.int_to_js x1135; Ojs.int_to_js x1136 |])
    ;;

    let pos : t -> int =
      fun (x1137 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1137) "pos")
    ;;

    let set_pos : t -> int -> unit =
      fun (x1138 : t) (x1139 : int) ->
      Ojs.set_prop_ascii (t_to_js x1138) "pos" (Ojs.int_to_js x1139)
    ;;

    let start : t -> int =
      fun (x1140 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1140) "start")
    ;;

    let string : t -> string =
      fun (x1141 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x1141) "string")
    ;;

    let eol : t -> bool =
      fun (x1142 : t) -> Ojs.bool_of_js (Ojs.call (t_to_js x1142) "eol" [||])
    ;;

    let sol : t -> bool =
      fun (x1143 : t) -> Ojs.bool_of_js (Ojs.call (t_to_js x1143) "sol" [||])
    ;;

    let peek : t -> string option =
      fun (x1144 : t) ->
      Ojs.option_of_js Ojs.string_of_js (Ojs.call (t_to_js x1144) "peek" [||])
    ;;

    let next : t -> string option =
      fun (x1146 : t) ->
      Ojs.option_of_js Ojs.string_of_js (Ojs.call (t_to_js x1146) "next" [||])
    ;;

    let current : t -> string =
      fun (x1148 : t) -> Ojs.string_of_js (Ojs.call (t_to_js x1148) "current" [||])
    ;;

    let skip_to_end : t -> unit =
      fun (x1149 : t) -> (ignore : _) (Ojs.call (t_to_js x1149) "skipToEnd" [||])
    ;;

    let eat_space : t -> bool =
      fun (x1150 : t) -> Ojs.bool_of_js (Ojs.call (t_to_js x1150) "eatSpace" [||])
    ;;

    let eat : t -> match_:string -> string option =
      fun (x1152 : t) ~match_:(x1151 : string) ->
      Ojs.option_of_js
        Ojs.string_of_js
        (Ojs.call (t_to_js x1152) "eat" [| Ojs.string_to_js x1151 |])
    ;;

    let eat_regex : t -> match_:RegExp.t -> string option =
      fun (x1155 : t) ~match_:(x1154 : RegExp.t) ->
      Ojs.option_of_js
        Ojs.string_of_js
        (Ojs.call (t_to_js x1155) "eat" [| RegExp.t_to_js x1154 |])
    ;;

    let eat_while : t -> match_:string -> bool =
      fun (x1158 : t) ~match_:(x1157 : string) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x1158) "eatWhile" [| Ojs.string_to_js x1157 |])
    ;;

    let eat_while_regex : t -> match_:RegExp.t -> bool =
      fun (x1160 : t) ~match_:(x1159 : RegExp.t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x1160) "eatWhile" [| RegExp.t_to_js x1159 |])
    ;;

    let match_
      : t -> pattern:string -> ?consume:bool -> ?case_insensitive:bool -> unit -> bool
      =
      fun (x1167 : t)
        ~pattern:(x1161 : string)
        ?consume:(x1162 : bool option)
        ?case_insensitive:(x1163 : bool option)
        () ->
      Ojs.bool_of_js
        (let x1168 = t_to_js x1167 in
         Ojs.call
           (Ojs.get_prop_ascii x1168 "match")
           "apply"
           [| x1168
            ; (let x1164 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x1164 "push" [| Ojs.string_to_js x1161 |]);
               (match x1162 with
                | Some x1166 ->
                  (ignore : _) (Ojs.call x1164 "push" [| Ojs.bool_to_js x1166 |])
                | None -> ());
               (match x1163 with
                | Some x1165 ->
                  (ignore : _) (Ojs.call x1164 "push" [| Ojs.bool_to_js x1165 |])
                | None -> ());
               x1164)
           |])
    ;;

    let match_regex
      :  t -> pattern:RegExp.t -> ?consume:bool -> ?case_insensitive:bool -> unit
      -> string list option
      =
      fun (x1175 : t)
        ~pattern:(x1169 : RegExp.t)
        ?consume:(x1170 : bool option)
        ?case_insensitive:(x1171 : bool option)
        () ->
      Ojs.option_of_js
        (fun (x1177 : Ojs.t) -> Ojs.list_of_js Ojs.string_of_js x1177)
        (let x1176 = t_to_js x1175 in
         Ojs.call
           (Ojs.get_prop_ascii x1176 "match")
           "apply"
           [| x1176
            ; (let x1172 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x1172 "push" [| RegExp.t_to_js x1169 |]);
               (match x1170 with
                | Some x1174 ->
                  (ignore : _) (Ojs.call x1172 "push" [| Ojs.bool_to_js x1174 |])
                | None -> ());
               (match x1171 with
                | Some x1173 ->
                  (ignore : _) (Ojs.call x1172 "push" [| Ojs.bool_to_js x1173 |])
                | None -> ());
               x1172)
           |])
    ;;
  end

  module Stream_parser = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1180 : Ojs.t) -> x1180
    and t_to_js : t -> Ojs.t = fun (x1179 : Ojs.t) -> x1179

    let create
      :  ?language_data:Ojs.t -> start_state:(unit -> 'state)
      -> token:(String_stream.t -> 'state -> string option) -> unit -> t
      =
      fun ?language_data:(x1181 : Ojs.t option)
        ~start_state:(x1182 : unit -> 'state)
        ~token:(x1183 : String_stream.t -> 'state -> string option)
        () ->
      let x1184 = Ojs.empty_obj () in
      (match x1181 with
       | Some x1188 -> Ojs.set_prop_ascii x1184 "languageData" x1188
       | None -> ());
      Ojs.set_prop_ascii
        x1184
        "startState"
        (Ojs.fun_to_js 1 (fun _ -> Obj.magic (x1182 ())));
      Ojs.set_prop_ascii
        x1184
        "token"
        (Ojs.fun_to_js 2 (fun (x1185 : Ojs.t) (x1186 : Ojs.t) ->
           Ojs.option_to_js
             Ojs.string_to_js
             (x1183 (String_stream.t_of_js x1185) (Obj.magic x1186))));
      t_of_js x1184
    ;;
  end

  module Stream_language = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1190 : Ojs.t) -> x1190
    and t_to_js : t -> Ojs.t = fun (x1189 : Ojs.t) -> x1189

    let define : Stream_parser.t -> t =
      fun (x1191 : Stream_parser.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
              "StreamLanguage")
           "define"
           [| Stream_parser.t_to_js x1191 |])
    ;;

    let to_language : t -> Language.t =
      fun (x1192 : t) -> Language.t_of_js (t_to_js x1192)
    ;;
  end
end

module Mllike = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1194 : Ojs.t) -> x1194
  and t_to_js : t -> Ojs.t = fun (x1193 : Ojs.t) -> x1193

  let fsharp : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_mllike")
         "fSharp")
  ;;

  let sml : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_mllike")
         "sml")
  ;;
end

module Diff = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1196 : Ojs.t) -> x1196
  and t_to_js : t -> Ojs.t = fun (x1195 : Ojs.t) -> x1195

  let diff : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_diff")
         "diff")
  ;;
end

module Commonlisp = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1198 : Ojs.t) -> x1198
  and t_to_js : t -> Ojs.t = fun (x1197 : Ojs.t) -> x1197

  let common_lisp : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_commonlisp")
         "commonLisp")
  ;;
end

module Scheme = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1200 : Ojs.t) -> x1200
  and t_to_js : t -> Ojs.t = fun (x1199 : Ojs.t) -> x1199

  let scheme : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_scheme")
         "scheme")
  ;;
end

module Lezer_highlight = struct
  module Highlighter = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1202 : Ojs.t) -> x1202
    and t_to_js : t -> Ojs.t = fun (x1201 : Ojs.t) -> x1201
  end

  module Tag = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1204 : Ojs.t) -> x1204
    and t_to_js : t -> Ojs.t = fun (x1203 : Ojs.t) -> x1203
  end

  module Tags = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1206 : Ojs.t) -> x1206
    and t_to_js : t -> Ojs.t = fun (x1205 : Ojs.t) -> x1205

    let arithmetic_operator : t -> Tag.t =
      fun (x1207 : t) ->
      Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1207) "arithmeticOperator")
    ;;

    let atom : t -> Tag.t =
      fun (x1208 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1208) "atom")
    ;;

    let bool : t -> Tag.t =
      fun (x1209 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1209) "bool")
    ;;

    let block_comment : t -> Tag.t =
      fun (x1210 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1210) "blockComment")
    ;;

    let bracket : t -> Tag.t =
      fun (x1211 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1211) "bracket")
    ;;

    let character : t -> Tag.t =
      fun (x1212 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1212) "character")
    ;;

    let comment : t -> Tag.t =
      fun (x1213 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1213) "comment")
    ;;

    let compare_operator : t -> Tag.t =
      fun (x1214 : t) ->
      Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1214) "compareOperator")
    ;;

    let content : t -> Tag.t =
      fun (x1215 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1215) "content")
    ;;

    let control_keyword : t -> Tag.t =
      fun (x1216 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1216) "controlKeyword")
    ;;

    let definition_keyword : t -> Tag.t =
      fun (x1217 : t) ->
      Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1217) "definitionKeyword")
    ;;

    let doc_comment : t -> Tag.t =
      fun (x1218 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1218) "docComment")
    ;;

    let float : t -> Tag.t =
      fun (x1219 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1219) "float")
    ;;

    let integer : t -> Tag.t =
      fun (x1220 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1220) "integer")
    ;;

    let invalid : t -> Tag.t =
      fun (x1221 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1221) "invalid")
    ;;

    let keyword : t -> Tag.t =
      fun (x1222 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1222) "keyword")
    ;;

    let line_comment : t -> Tag.t =
      fun (x1223 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1223) "lineComment")
    ;;

    let literal : t -> Tag.t =
      fun (x1224 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1224) "literal")
    ;;

    let logic_operator : t -> Tag.t =
      fun (x1225 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1225) "logicOperator")
    ;;

    let macro_name : t -> Tag.t =
      fun (x1226 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1226) "macroName")
    ;;

    let name : t -> Tag.t =
      fun (x1227 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1227) "name")
    ;;

    let number : t -> Tag.t =
      fun (x1228 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1228) "number")
    ;;

    let operator : t -> Tag.t =
      fun (x1229 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1229) "operator")
    ;;

    let paren : t -> Tag.t =
      fun (x1230 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1230) "paren")
    ;;

    let property_name : t -> Tag.t =
      fun (x1231 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1231) "propertyName")
    ;;

    let punctuation : t -> Tag.t =
      fun (x1232 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1232) "punctuation")
    ;;

    let string : t -> Tag.t =
      fun (x1233 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1233) "string")
    ;;

    let type_name : t -> Tag.t =
      fun (x1234 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1234) "typeName")
    ;;

    let variable_name : t -> Tag.t =
      fun (x1235 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1235) "variableName")
    ;;

    let special : t -> Tag.t -> Tag.t =
      fun (x1237 : t) (x1236 : Tag.t) ->
      Tag.t_of_js (Ojs.call (t_to_js x1237) "special" [| Tag.t_to_js x1236 |])
    ;;
  end

  let tags : Tags.t =
    Tags.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Lezer_highlight")
         "tags")
  ;;

  let class_highlighter : Highlighter.t =
    Highlighter.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Lezer_highlight")
         "classHighlighter")
  ;;
end

module Highlight = struct
  module Syntax_highlighting_options = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1239 : Ojs.t) -> x1239
    and t_to_js : t -> Ojs.t = fun (x1238 : Ojs.t) -> x1238

    let create : ?fallback:bool -> unit -> t =
      fun ?fallback:(x1240 : bool option) () ->
      let x1241 = Ojs.empty_obj () in
      (match x1240 with
       | Some x1242 -> Ojs.set_prop_ascii x1241 "fallback" (Ojs.bool_to_js x1242)
       | None -> ());
      t_of_js x1241
    ;;
  end

  module Highlight_style = struct
    let define : specs:Ojs.t list -> Lezer_highlight.Highlighter.t =
      fun ~specs:(x1243 : Ojs.t list) ->
      Lezer_highlight.Highlighter.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
              "HighlightStyle")
           "define"
           [| Ojs.list_to_js (fun (x1244 : Ojs.t) -> x1244) x1243 |])
    ;;
  end

  let syntax_highlighting
    :  Lezer_highlight.Highlighter.t -> ?options:Syntax_highlighting_options.t -> unit
    -> State.Extension.t
    =
    fun (x1245 : Lezer_highlight.Highlighter.t)
      ?options:(x1246 : Syntax_highlighting_options.t option)
      () ->
    State.Extension.t_of_js
      (let x1249 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language"
       in
       Ojs.call
         (Ojs.get_prop_ascii x1249 "syntaxHighlighting")
         "apply"
         [| x1249
          ; (let x1247 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (ignore : _)
               (Ojs.call x1247 "push" [| Lezer_highlight.Highlighter.t_to_js x1245 |]);
             (match x1246 with
              | Some x1248 ->
                (ignore : _)
                  (Ojs.call x1247 "push" [| Syntax_highlighting_options.t_to_js x1248 |])
              | None -> ());
             x1247)
         |])
  ;;

  let highlighting_for
    : State.Editor_state.t -> tags:Lezer_highlight.Tag.t list -> string option
    =
    fun (x1250 : State.Editor_state.t) ~tags:(x1251 : Lezer_highlight.Tag.t list) ->
    Ojs.option_of_js
      Ojs.string_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "highlightingFor"
         [| State.Editor_state.t_to_js x1250
          ; Ojs.list_to_js Lezer_highlight.Tag.t_to_js x1251
         |])
  ;;

  let default_highlight_style : Lezer_highlight.Highlighter.t =
    Lezer_highlight.Highlighter.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "defaultHighlightStyle")
  ;;
end

module Folding = struct
  module Fold = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1255 : Ojs.t) -> x1255
    and t_to_js : t -> Ojs.t = fun (x1254 : Ojs.t) -> x1254

    let create : from:int -> to_:int -> t =
      fun ~from:(x1256 : int) ~to_:(x1257 : int) ->
      let x1258 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x1258 "from" (Ojs.int_to_js x1256);
      Ojs.set_prop_ascii x1258 "to" (Ojs.int_to_js x1257);
      t_of_js x1258
    ;;
  end

  module Fold_service_callback = struct
    type t = State.Editor_state.t -> line_start:int -> line_end:int -> Fold.t option

    let rec t_of_js : Ojs.t -> t =
      fun (x1264 : Ojs.t)
        (x1265 : State.Editor_state.t)
        ~line_start:(x1266 : int)
        ~line_end:(x1267 : int) ->
      Ojs.option_of_js
        Fold.t_of_js
        (Ojs.apply
           x1264
           [| State.Editor_state.t_to_js x1265
            ; Ojs.int_to_js x1266
            ; Ojs.int_to_js x1267
           |])

    and t_to_js : t -> Ojs.t =
      fun (x1259 :
            State.Editor_state.t -> line_start:int -> line_end:int -> Fold.t option) ->
      Ojs.fun_to_js 3 (fun (x1260 : Ojs.t) (x1261 : Ojs.t) (x1262 : Ojs.t) ->
        Ojs.option_to_js
          Fold.t_to_js
          (x1259
             (State.Editor_state.t_of_js x1260)
             ~line_start:(Ojs.int_of_js x1261)
             ~line_end:(Ojs.int_of_js x1262)))
    ;;
  end

  let fold_service : (Fold_service_callback.t, Fold_service_callback.t) State.Facet.t =
    State.Facet.t_of_js
      Fold_service_callback.t_of_js
      Fold_service_callback.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "foldService")
  ;;

  let fold_gutter : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "foldGutter"
         [||])
  ;;
end

module Matchbrackets = struct
  let bracket_matching : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "bracketMatching"
         [||])
  ;;
end

module Lang_markdown = struct
  let markdown : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_markdown")
         "markdown"
         [||])
  ;;
end

module Lang_python = struct
  let python : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_python")
         "python"
         [||])
  ;;
end

module Lang_sql = struct
  module Sql_dialect_spec = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1272 : Ojs.t) -> x1272
    and t_to_js : t -> Ojs.t = fun (x1271 : Ojs.t) -> x1271

    let create
      :  ?keywords:string -> ?builtin:string -> ?types:string -> ?backslash_escapes:string
      -> ?hash_comments:bool -> ?slash_comments:bool -> ?space_after_dashes:bool
      -> ?double_quoted_strings:bool -> ?char_set_casts:bool -> ?operator_chars:string
      -> ?special_var:string -> ?identifier_quotes:string -> unit -> t
      =
      fun ?keywords:(x1273 : string option)
        ?builtin:(x1274 : string option)
        ?types:(x1275 : string option)
        ?backslash_escapes:(x1276 : string option)
        ?hash_comments:(x1277 : bool option)
        ?slash_comments:(x1278 : bool option)
        ?space_after_dashes:(x1279 : bool option)
        ?double_quoted_strings:(x1280 : bool option)
        ?char_set_casts:(x1281 : bool option)
        ?operator_chars:(x1282 : string option)
        ?special_var:(x1283 : string option)
        ?identifier_quotes:(x1284 : string option)
        () ->
      let x1285 = Ojs.empty_obj () in
      (match x1273 with
       | Some x1297 -> Ojs.set_prop_ascii x1285 "keywords" (Ojs.string_to_js x1297)
       | None -> ());
      (match x1274 with
       | Some x1296 -> Ojs.set_prop_ascii x1285 "builtin" (Ojs.string_to_js x1296)
       | None -> ());
      (match x1275 with
       | Some x1295 -> Ojs.set_prop_ascii x1285 "types" (Ojs.string_to_js x1295)
       | None -> ());
      (match x1276 with
       | Some x1294 ->
         Ojs.set_prop_ascii x1285 "backslashEscapes" (Ojs.string_to_js x1294)
       | None -> ());
      (match x1277 with
       | Some x1293 -> Ojs.set_prop_ascii x1285 "hashComments" (Ojs.bool_to_js x1293)
       | None -> ());
      (match x1278 with
       | Some x1292 -> Ojs.set_prop_ascii x1285 "slashComments" (Ojs.bool_to_js x1292)
       | None -> ());
      (match x1279 with
       | Some x1291 -> Ojs.set_prop_ascii x1285 "spaceAfterDashes" (Ojs.bool_to_js x1291)
       | None -> ());
      (match x1280 with
       | Some x1290 ->
         Ojs.set_prop_ascii x1285 "doubleQuotedStrings" (Ojs.bool_to_js x1290)
       | None -> ());
      (match x1281 with
       | Some x1289 -> Ojs.set_prop_ascii x1285 "charSetCasts" (Ojs.bool_to_js x1289)
       | None -> ());
      (match x1282 with
       | Some x1288 -> Ojs.set_prop_ascii x1285 "operatorChars" (Ojs.string_to_js x1288)
       | None -> ());
      (match x1283 with
       | Some x1287 -> Ojs.set_prop_ascii x1285 "specialVar" (Ojs.string_to_js x1287)
       | None -> ());
      (match x1284 with
       | Some x1286 ->
         Ojs.set_prop_ascii x1285 "identifierQuotes" (Ojs.string_to_js x1286)
       | None -> ());
      t_of_js x1285
    ;;
  end

  module Sql_dialect = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1299 : Ojs.t) -> x1299
    and t_to_js : t -> Ojs.t = fun (x1298 : Ojs.t) -> x1298

    let define : spec:Sql_dialect_spec.t -> t =
      fun ~spec:(x1300 : Sql_dialect_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_sql")
              "SQLDialect")
           "define"
           [| Sql_dialect_spec.t_to_js x1300 |])
    ;;
  end

  module Sql_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1302 : Ojs.t) -> x1302
    and t_to_js : t -> Ojs.t = fun (x1301 : Ojs.t) -> x1301

    let create
      :  ?dialect:Sql_dialect.t -> ?upper_case_keywords:bool
      -> ?tables:Autocomplete.Completion.t list -> ?default_table:int -> ?schema:Ojs.t
      -> unit -> t
      =
      fun ?dialect:(x1303 : Sql_dialect.t option)
        ?upper_case_keywords:(x1304 : bool option)
        ?tables:(x1305 : Autocomplete.Completion.t list option)
        ?default_table:(x1306 : int option)
        ?schema:(x1307 : Ojs.t option)
        () ->
      let x1308 = Ojs.empty_obj () in
      (match x1303 with
       | Some x1314 -> Ojs.set_prop_ascii x1308 "dialect" (Sql_dialect.t_to_js x1314)
       | None -> ());
      (match x1304 with
       | Some x1313 -> Ojs.set_prop_ascii x1308 "upperCaseKeywords" (Ojs.bool_to_js x1313)
       | None -> ());
      (match x1305 with
       | Some x1311 ->
         Ojs.set_prop_ascii
           x1308
           "tables"
           (Ojs.list_to_js Autocomplete.Completion.t_to_js x1311)
       | None -> ());
      (match x1306 with
       | Some x1310 -> Ojs.set_prop_ascii x1308 "defaultTable" (Ojs.int_to_js x1310)
       | None -> ());
      (match x1307 with
       | Some x1309 -> Ojs.set_prop_ascii x1308 "schema" x1309
       | None -> ());
      t_of_js x1308
    ;;
  end

  let postgresql : Sql_dialect.t =
    Sql_dialect.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_sql")
         "PostgreSQL")
  ;;

  let sql : ?config:Sql_config.t -> unit -> Language.t =
    fun ?config:(x1315 : Sql_config.t option) () ->
    Language.t_of_js
      (let x1318 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_sql"
       in
       Ojs.call
         (Ojs.get_prop_ascii x1318 "sql")
         "apply"
         [| x1318
          ; (let x1316 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (match x1315 with
              | Some x1317 ->
                (ignore : _) (Ojs.call x1316 "push" [| Sql_config.t_to_js x1317 |])
              | None -> ());
             x1316)
         |])
  ;;
end

module Lang_html = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1320 : Ojs.t) -> x1320
  and t_to_js : t -> Ojs.t = fun (x1319 : Ojs.t) -> x1319

  let html : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_html")
         "html"
         [||])
  ;;
end

module Lang_css = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1322 : Ojs.t) -> x1322
  and t_to_js : t -> Ojs.t = fun (x1321 : Ojs.t) -> x1321

  let css : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_css")
         "css"
         [||])
  ;;
end

module Lang_javascript = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1324 : Ojs.t) -> x1324
  and t_to_js : t -> Ojs.t = fun (x1323 : Ojs.t) -> x1323

  let javascript : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Lang_javascript")
         "javascript"
         [||])
  ;;
end

module Lang_php = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1326 : Ojs.t) -> x1326
  and t_to_js : t -> Ojs.t = fun (x1325 : Ojs.t) -> x1325

  let php : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_php")
         "php"
         [||])
  ;;
end

module Lang_rust = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1328 : Ojs.t) -> x1328
  and t_to_js : t -> Ojs.t = fun (x1327 : Ojs.t) -> x1327

  let rust : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_rust")
         "rust"
         [||])
  ;;
end

module Lang_xml = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1330 : Ojs.t) -> x1330
  and t_to_js : t -> Ojs.t = fun (x1329 : Ojs.t) -> x1329

  let xml : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_xml")
         "xml"
         [||])
  ;;
end

module Merge = struct
  module Unified_merge_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1332 : Ojs.t) -> x1332
    and t_to_js : t -> Ojs.t = fun (x1331 : Ojs.t) -> x1331

    let create_from_string
      :  ?highlight_changes:bool -> ?gutter:bool -> ?syntax_highlight_deletions:bool
      -> ?merge_controls:bool -> string -> t
      =
      fun ?highlight_changes:(x1333 : bool option)
        ?gutter:(x1334 : bool option)
        ?syntax_highlight_deletions:(x1335 : bool option)
        ?merge_controls:(x1336 : bool option)
        (x1337 : string) ->
      let x1338 = Ojs.empty_obj () in
      (match x1333 with
       | Some x1342 -> Ojs.set_prop_ascii x1338 "highlightChanges" (Ojs.bool_to_js x1342)
       | None -> ());
      (match x1334 with
       | Some x1341 -> Ojs.set_prop_ascii x1338 "gutter" (Ojs.bool_to_js x1341)
       | None -> ());
      (match x1335 with
       | Some x1340 ->
         Ojs.set_prop_ascii x1338 "syntaxHighlightDeletions" (Ojs.bool_to_js x1340)
       | None -> ());
      (match x1336 with
       | Some x1339 -> Ojs.set_prop_ascii x1338 "mergeControls" (Ojs.bool_to_js x1339)
       | None -> ());
      Ojs.set_prop_ascii x1338 "original" (Ojs.string_to_js x1337);
      t_of_js x1338
    ;;

    let create_from_text
      :  ?highlight_changes:bool -> ?gutter:bool -> ?syntax_highlight_deletions:bool
      -> ?merge_controls:bool -> Text.Text.t -> t
      =
      fun ?highlight_changes:(x1343 : bool option)
        ?gutter:(x1344 : bool option)
        ?syntax_highlight_deletions:(x1345 : bool option)
        ?merge_controls:(x1346 : bool option)
        (x1347 : Text.Text.t) ->
      let x1348 = Ojs.empty_obj () in
      (match x1343 with
       | Some x1352 -> Ojs.set_prop_ascii x1348 "highlightChanges" (Ojs.bool_to_js x1352)
       | None -> ());
      (match x1344 with
       | Some x1351 -> Ojs.set_prop_ascii x1348 "gutter" (Ojs.bool_to_js x1351)
       | None -> ());
      (match x1345 with
       | Some x1350 ->
         Ojs.set_prop_ascii x1348 "syntaxHighlightDeletions" (Ojs.bool_to_js x1350)
       | None -> ());
      (match x1346 with
       | Some x1349 -> Ojs.set_prop_ascii x1348 "mergeControls" (Ojs.bool_to_js x1349)
       | None -> ());
      Ojs.set_prop_ascii x1348 "original" (Text.Text.t_to_js x1347);
      t_of_js x1348
    ;;
  end

  let unified_merge_view : Unified_merge_config.t -> State.Extension.t =
    fun (x1353 : Unified_merge_config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Merge")
         "unifiedMergeView"
         [| Unified_merge_config.t_to_js x1353 |])
  ;;
end
