# Testing

Traditional approaches for testing web applications can be infuriating.
With tools like selenium or puppeteer, there's an entire headless
browser running in the background, and not only do you need to find a
way to reconfigure the app or library for testing, slow test execution
and race condition-related bugs are a constant companion.

Bonsai web apps compute a declarative `Vdom.Node.t`, which serves as the
source of truth for how the web UI should look at any given time.

The `Bonsai_web_test` library provides tools to compute and test the
`Vdom.Node.t` generated by any `local_ graph -> Bonsai.t`, so we can use
`ppx_expect_test` and all the other OCaml testing tools we know and
love.

## Getting Ready For Testing

Testing a program built using Js_of_ocaml involves a few changes to your
normal workflow.

    (library (
      (name my_ui_test)
      (js_of_ocaml ())                   ; Test library must be marked with js_of_ocaml
      (libraries (core my_ui))
      (inline_tests (                    ; Native tests must be disabled
        (native     dont_build_dont_run)
        (javascript build_and_run)))))

Your jenga start-file also needs to specify the `javascript-runtest`
alias for the project.

    (alias ((name build) (deps (
      (alias %{root}/app/my-app/test/javascript-runtest)
      ; ... your other build targets here...
    ))))

## Basics of testing: printing Vdom

Let's say we have some constant Vdom we'd like to test:

```{=html}
<!-- $MDX file=../../examples/bonsai_guide_code/lib/testing_examples.ml,part=hello-world -->
```
``` ocaml
let hello_world = Vdom.Node.span [ Vdom.Node.text "hello world" ]
```

There are a few tools we'll use:

-   `Result_spec.t` is a first class module containing:
    -   How to turn some `t` into a string "view" we can show in expect
        tests
    -   How to convert an "incoming" value (passed in by testing code)
        into an `Effect.t` how to display it, and any inputs needed.
-   `Handle.t` wraps a `local_ graph -> 'a Bonsai.t`, and provides APIs
    for:
    -   Evaluating it and printing the result (`Handle.show`).
    -   Injecting some value of type `incoming`, which the
        `Result_spec.t` will convert into a `unit Effect.t` and run
        (`Handle.do_actions`).
    -   Triggering event listeners (`Handle.click_on`,
        `Handle.input_text`, etc.).

`Result_spec.vdom` is a helper for generating
`Vdom.Node.t Result_spec.t`s:

```{=html}
<!-- $MDX file=../../examples/bonsai_guide_code/lib/testing_examples.ml,part=hello-world-test -->
```
``` ocaml
module Handle = Bonsai_web_test.Handle
module Result_spec = Bonsai_web_test.Result_spec

let%expect_test "it shows hello world" =
  let handle = Handle.create (Result_spec.vdom Fn.id) (fun _ -> return hello_world) in
  Handle.show handle;
  [%expect {| <span> hello world </span> |}]
;;
```

Some `Bonsai.t`s return a `Vdom.Node.t` *and* something else.
`Result_spec.vdom`'s first argument is a function to pull out the
`Vdom.Node.t` part.

We'll make our own `Result_spec.t`s for things other than `Vdom.Node.t`
later.

```{=html}
<aside>
```
Because we have a `Vdom.Node.t`, and not a
`local_ Bonsai.graph -> Vdom.Node.t Bonsai.t`, we need to wrap
`hello_world`.
```{=html}
</aside>
```
## Testing dynamic inputs

What if we want to test a `'a Bonsai.t -> 'b Bonsai.t`?

```{=html}
<!-- $MDX file=../../examples/bonsai_guide_code/lib/testing_examples.ml,part=hello-user -->
```
``` ocaml
let hello_user (name : string Bonsai.t) : Vdom.Node.t Bonsai.t =
  let%arr name = name in
  Vdom.Node.span [ Vdom.Node.textf "hello %s" name ]
;;
```

```{=html}
```
We can use `Bonsai.Var.t` to get a mutable handle on a `Bonsai.t`:

```{=html}
<!-- $MDX file=../../examples/bonsai_guide_code/lib/testing_examples.ml,part=hello-user-test -->
```
``` ocaml
let%expect_test "shows hello to a user" =
  let user_var = Bonsai.Expert.Var.create "Bob" in
  let user = Bonsai.Expert.Var.value user_var in
  let handle = Handle.create (Result_spec.vdom Fn.id) (fun _ -> hello_user user) in
  Handle.show handle;
  [%expect {| <span> hello Bob </span> |}];
  Bonsai.Expert.Var.set user_var "Alice";
  Handle.show handle;
  [%expect {| <span> hello Alice </span> |}]
;;
```

As expected, after changing the `Var.t`, the contents in the DOM are
updated!

## Testing with diffs

If we only want to see what changed between two versions of the view, we
can use `Handle.show_diff`:

```{=html}
<!-- $MDX file=../../examples/bonsai_guide_code/lib/testing_examples.ml,part=hello-user-diff-test -->
```
``` ocaml
let%expect_test "shows hello to a user" =
  let user_var = Bonsai.Expert.Var.create "Bob" in
  let user = Bonsai.Expert.Var.value user_var in
  let handle = Handle.create (Result_spec.vdom Fn.id) (fun _ -> hello_user user) in
  Handle.show handle;
  [%expect {| <span> hello Bob </span> |}];
  Bonsai.Expert.Var.set user_var "Alice";
  Handle.show_diff handle;
  [%expect
    {|
    -|<span> hello Bob </span>
    +|<span> hello Alice </span>
    |}]
;;
```

While the diff in this instance isn't particularly illuminating, when
testing UI components that produce hundreds of lines of output, it can
be *much* easier to only review the diff.

## Testing interactivity

Most useful web UIs store internal state, which can be updated in
response to user interactions.

Here, we actually use the `hello_user` we defined previously, but the
`string Bonsai.t` comes from internal state instead of being passed in
by the caller:

```{=html}
<!-- $MDX file=../../examples/bonsai_guide_code/lib/testing_examples.ml,part=hello-text-box -->
```
``` ocaml
let hello_textbox (local_ graph) : Vdom.Node.t Bonsai.t =
  let state, set = Bonsai.state "" graph in
  let%arr message = hello_user state
  and set = set in
  Vdom.Node.div
    [ Vdom.Node.input ~attrs:[ Vdom.Attr.on_input (fun _ text -> set text) ] (); message ]
;;
```

This is fully self-contained: its interior state is only changeable by
typing into the `<input>` text-box.

Event listeners added via `Vdom.Attr.*` are testable with Bonsai! We can
use `Handle.input_text` to simulate interacting with the `<input />` DOM
element:

```{=html}
<!-- $MDX file=../../examples/bonsai_guide_code/lib/testing_examples.ml,part=hello-text-box-diff-test -->
```
``` ocaml
let%expect_test "shows hello to a specified user" =
  let handle = Handle.create (Result_spec.vdom Fn.id) hello_textbox in
  Handle.show handle;
  [%expect
    {|
    <div>
      <input oninput> </input>
      <span> hello  </span>
    </div>
    |}];
  Handle.input_text handle ~get_vdom:Fn.id ~selector:"input" ~text:"Bob";
  Handle.show_diff handle;
  [%expect
    {|
      <div>
        <input oninput> </input>
    -|  <span> hello  </span>
    +|  <span> hello Bob </span>
      </div>
    |}];
  Handle.input_text handle ~get_vdom:Fn.id ~selector:"input" ~text:"Alice";
  Handle.show_diff handle;
  [%expect
    {|
      <div>
        <input oninput> </input>
    -|  <span> hello Bob </span>
    +|  <span> hello Alice </span>
      </div>
    |}]
;;
```

We just have to provide a valid CSS selector via the `~selector`
argument.

```{=html}
<aside>
```
Just like with `Result_spec.vdom`, `Handle.input_text` takes a function
to extract the `Vdom.Node.t` from a `'a Bonsai.t` via `~get_vdom`.
```{=html}
</aside>
```
## Testing state transitions directly

Many Bonsai functions expose a `'a -> unit Effect.t` that can be used to
set some internal state, or apply an action to a state machine. An
example is the second part of `Bonsai.state`'s output:

```{=html}
<!-- $MDX skip -->
```
``` ocaml
('model Bonsai.t * ('model -> unit Effect.t) Bonsai.t)
```

Testing `Bonsai.state` or anything that exposes an injection function
will usually require a custom `Result_spec.t` and a new `Handle`
function.

We can use `val Handle.do_actions : Handle.t -> incoming list -> unit`
to inject actions:

```{=html}
<!-- $MDX file=../../examples/bonsai_guide_code/lib/testing_examples.ml,part=state-test -->
```
``` ocaml
module State_view_spec = struct
  type t = string * (string -> unit Effect.t)
  type incoming = string

  let view : t -> string = fun (view, _) -> view
  let incoming : t -> incoming -> unit Effect.t = fun (_, incoming) -> incoming
end

let%expect_test "test Bonsai.state" =
  let state_single_bonsai (local_ graph)
    : (string * (string -> unit Vdom.Effect.t)) Bonsai.t
    =
    let state, inject = Bonsai.state "hello" graph in
    Bonsai.both state inject
  in
  let handle = Handle.create (module State_view_spec) state_single_bonsai in
  Handle.show handle;
  [%expect {| hello |}];
  Handle.do_actions handle [ "world" ];
  Handle.show handle;
  [%expect {| world |}]
;;
```

`Bonsai_web_test` only supports creating handles for a single
`'a Bonsai.t`, so we need to combine the 2 outputs of `Bonsai.state`.

Instead of using the `Result_spec.vdom` helper function like before, we
need to define our view-spec module that caters specifically to the type
`t` returned by `state`. We also define a `type incoming`, which
represents "input events" we can inject.

## Mocking time in tests

In the [how-to on time](./time.mdx), we wrote a UI that depends on time:

```{=html}
<!-- $MDX file=../../examples/bonsai_guide_code/lib/time_examples.ml,part=clock_now -->
```
``` ocaml
let current_time (local_ graph) =
  let%arr now = Bonsai.Clock.now graph in
  Vdom.Node.text (Time_ns.to_string_utc now)
;;
```

```{=html}
<iframe data-external="1" src="https://bonsai:8535#clock_now">
```
```{=html}
</iframe>
```
We can use `Handle.advance_clock_by` to mock time in tests:

```{=html}
<!-- $MDX file=../../examples/bonsai_guide_code/lib/testing_examples.ml,part=test-clock -->
```
``` ocaml
let%expect_test "test clock" =
  let handle = Handle.create (Result_spec.vdom Fn.id) Time_examples.current_time in
  Handle.show handle;
  [%expect {| 1970-01-01 00:00:00.000000000Z |}];
  Handle.advance_clock_by handle (Time_ns.Span.of_sec 2.0);
  Handle.show handle;
  [%expect {| 1970-01-01 00:00:02.000000000Z |}]
;;
```

```{=html}
```
