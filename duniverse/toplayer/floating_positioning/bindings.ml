[@@@js.dummy "!! This code has been generated by gen_js_api !!"]
[@@@ocaml.warning "-7-32-39"]

open! Core
open! Js_of_ocaml
open! Gen_js_api
open Custom_converters

module Alignment = struct
  type t =
    | Start
    | End
  [@@deriving sexp, sexp_grammar, equal, compare, enumerate]

  let rec t_of_js : Ojs.t -> t =
    fun (x2 : Ojs.t) ->
    let x3 = x2 in
    match Ojs.string_of_js x3 with
    | "start" -> Start
    | "end" -> End
    | _ -> assert false

  and t_to_js : t -> Ojs.t =
    fun (x1 : t) ->
    match x1 with
    | Start -> Ojs.string_to_js "start"
    | End -> Ojs.string_to_js "end"
  ;;
end

module Placement = struct
  type t =
    | Top
    | Top_start
    | Top_end
    | Bottom
    | Bottom_start
    | Bottom_end
    | Right
    | Right_start
    | Right_end
    | Left
    | Left_start
    | Left_end
  [@@deriving sexp, sexp_grammar, equal, compare, enumerate]

  let rec t_of_js : Ojs.t -> t =
    fun (x5 : Ojs.t) ->
    let x6 = x5 in
    match Ojs.string_of_js x6 with
    | "top" -> Top
    | "top-start" -> Top_start
    | "top-end" -> Top_end
    | "bottom" -> Bottom
    | "bottom-start" -> Bottom_start
    | "bottom-end" -> Bottom_end
    | "right" -> Right
    | "right-start" -> Right_start
    | "right-end" -> Right_end
    | "left" -> Left
    | "left-start" -> Left_start
    | "left-end" -> Left_end
    | _ -> assert false

  and t_to_js : t -> Ojs.t =
    fun (x4 : t) ->
    match x4 with
    | Top -> Ojs.string_to_js "top"
    | Top_start -> Ojs.string_to_js "top-start"
    | Top_end -> Ojs.string_to_js "top-end"
    | Bottom -> Ojs.string_to_js "bottom"
    | Bottom_start -> Ojs.string_to_js "bottom-start"
    | Bottom_end -> Ojs.string_to_js "bottom-end"
    | Right -> Ojs.string_to_js "right"
    | Right_start -> Ojs.string_to_js "right-start"
    | Right_end -> Ojs.string_to_js "right-end"
    | Left -> Ojs.string_to_js "left"
    | Left_start -> Ojs.string_to_js "left-start"
    | Left_end -> Ojs.string_to_js "left-end"
  ;;
end

module Strategy = struct
  type t =
    | Absolute
    | Fixed
  [@@deriving sexp, sexp_grammar, equal, compare, enumerate]

  let rec t_of_js : Ojs.t -> t =
    fun (x8 : Ojs.t) ->
    let x9 = x8 in
    match Ojs.string_of_js x9 with
    | "absolute" -> Absolute
    | "fixed" -> Fixed
    | _ -> assert false

  and t_to_js : t -> Ojs.t =
    fun (x7 : t) ->
    match x7 with
    | Absolute -> Ojs.string_to_js "absolute"
    | Fixed -> Ojs.string_to_js "fixed"
  ;;
end

module Offset = struct
  type t =
    { main_axis : float
    ; cross_axis : float
    }
  [@@deriving sexp, sexp_grammar, equal, compare]

  let rec t_of_js : Ojs.t -> t =
    fun (x11 : Ojs.t) ->
    { main_axis = Ojs.float_of_js (Ojs.get_prop_ascii x11 "mainAxis")
    ; cross_axis = Ojs.float_of_js (Ojs.get_prop_ascii x11 "crossAxis")
    }

  and t_to_js : t -> Ojs.t =
    fun (x10 : t) ->
    Ojs.obj
      [| "mainAxis", Ojs.float_to_js x10.main_axis
       ; "crossAxis", Ojs.float_to_js x10.cross_axis
      |]
  ;;
end

module Middleware = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x13 : Ojs.t) -> x13
  and t_to_js : t -> Ojs.t = fun (x12 : Ojs.t) -> x12

  module Offset = struct
    let create : Offset.t -> t =
      fun (x14 : Offset.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
           "offset"
           [| Offset.t_to_js x14 |])
    ;;
  end

  module Size = struct
    module Options = struct
      module Apply_options = struct
        module Rect = struct
          type t =
            { width : float
            ; height : float
            }

          let rec t_of_js : Ojs.t -> t =
            fun (x16 : Ojs.t) ->
            { width = Ojs.float_of_js (Ojs.get_prop_ascii x16 "width")
            ; height = Ojs.float_of_js (Ojs.get_prop_ascii x16 "height")
            }

          and t_to_js : t -> Ojs.t =
            fun (x15 : t) ->
            Ojs.obj
              [| "width", Ojs.float_to_js x15.width
               ; "height", Ojs.float_to_js x15.height
              |]
          ;;
        end

        module Element_rects = struct
          type t =
            { reference : Rect.t
            ; floating : Rect.t
            }

          let rec t_of_js : Ojs.t -> t =
            fun (x18 : Ojs.t) ->
            { reference = Rect.t_of_js (Ojs.get_prop_ascii x18 "reference")
            ; floating = Rect.t_of_js (Ojs.get_prop_ascii x18 "floating")
            }

          and t_to_js : t -> Ojs.t =
            fun (x17 : t) ->
            Ojs.obj
              [| "reference", Rect.t_to_js x17.reference
               ; "floating", Rect.t_to_js x17.floating
              |]
          ;;
        end

        type t =
          { available_width : float
          ; available_height : float
          ; rects : Element_rects.t
          ; placement : Placement.t
          }

        let rec t_of_js : Ojs.t -> t =
          fun (x20 : Ojs.t) ->
          { available_width = Ojs.float_of_js (Ojs.get_prop_ascii x20 "availableWidth")
          ; available_height = Ojs.float_of_js (Ojs.get_prop_ascii x20 "availableHeight")
          ; rects = Element_rects.t_of_js (Ojs.get_prop_ascii x20 "rects")
          ; placement = Placement.t_of_js (Ojs.get_prop_ascii x20 "placement")
          }

        and t_to_js : t -> Ojs.t =
          fun (x19 : t) ->
          Ojs.obj
            [| "availableWidth", Ojs.float_to_js x19.available_width
             ; "availableHeight", Ojs.float_to_js x19.available_height
             ; "rects", Element_rects.t_to_js x19.rects
             ; "placement", Placement.t_to_js x19.placement
            |]
        ;;
      end

      type t = { apply : Apply_options.t -> unit }

      let rec t_of_js : Ojs.t -> t =
        fun (x23 : Ojs.t) ->
        { apply =
            (fun (x24 : Apply_options.t) ->
              (ignore : _)
                (Ojs.apply
                   (Ojs.get_prop_ascii x23 "apply")
                   [| Apply_options.t_to_js x24 |]))
        }

      and t_to_js : t -> Ojs.t =
        fun (x21 : t) ->
        Ojs.obj
          [| ( "apply"
             , Ojs.fun_to_js 1 (fun (x22 : Ojs.t) ->
                 x21.apply (Apply_options.t_of_js x22)) )
          |]
      ;;
    end

    let create : Options.t -> t =
      fun (x25 : Options.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
           "size"
           [| Options.t_to_js x25 |])
    ;;
  end

  module Flip = struct
    module Options = struct
      type t = { padding : float option }

      let rec t_of_js : Ojs.t -> t =
        fun (x28 : Ojs.t) ->
        { padding = Ojs.option_of_js Ojs.float_of_js (Ojs.get_prop_ascii x28 "padding") }

      and t_to_js : t -> Ojs.t =
        fun (x26 : t) ->
        Ojs.obj [| "padding", Ojs.option_to_js Ojs.float_to_js x26.padding |]
      ;;
    end

    let create : Options.t -> t =
      fun (x30 : Options.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
           "flip"
           [| Options.t_to_js x30 |])
    ;;
  end

  module Shift = struct
    module Limiter = struct
      module Options = struct
        type t =
          { main_axis : bool
          ; cross_axis : bool
          }

        let rec t_of_js : Ojs.t -> t =
          fun (x32 : Ojs.t) ->
          { main_axis = Ojs.bool_of_js (Ojs.get_prop_ascii x32 "mainAxis")
          ; cross_axis = Ojs.bool_of_js (Ojs.get_prop_ascii x32 "crossAxis")
          }

        and t_to_js : t -> Ojs.t =
          fun (x31 : t) ->
          Ojs.obj
            [| "mainAxis", Ojs.bool_to_js x31.main_axis
             ; "crossAxis", Ojs.bool_to_js x31.cross_axis
            |]
        ;;
      end

      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x34 : Ojs.t) -> x34
      and t_to_js : t -> Ojs.t = fun (x33 : Ojs.t) -> x33

      let create : Options.t -> t =
        fun (x35 : Options.t) ->
        t_of_js
          (Ojs.call
             (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
             "limitShift"
             [| Options.t_to_js x35 |])
      ;;
    end

    module Options = struct
      type t =
        { padding : float option
        ; limiter : Limiter.t
        }

      let rec t_of_js : Ojs.t -> t =
        fun (x38 : Ojs.t) ->
        { padding = Ojs.option_of_js Ojs.float_of_js (Ojs.get_prop_ascii x38 "padding")
        ; limiter = Limiter.t_of_js (Ojs.get_prop_ascii x38 "limiter")
        }

      and t_to_js : t -> Ojs.t =
        fun (x36 : t) ->
        Ojs.obj
          [| "padding", Ojs.option_to_js Ojs.float_to_js x36.padding
           ; "limiter", Limiter.t_to_js x36.limiter
          |]
      ;;
    end

    let create : Options.t -> t =
      fun (x40 : Options.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
           "shift"
           [| Options.t_to_js x40 |])
    ;;
  end

  module Auto_placement = struct
    module Options = struct
      type t =
        { alignment : Alignment.t option
        ; padding : float option
        }

      let rec t_of_js : Ojs.t -> t =
        fun (x44 : Ojs.t) ->
        { alignment =
            Ojs.option_of_js Alignment.t_of_js (Ojs.get_prop_ascii x44 "alignment")
        ; padding = Ojs.option_of_js Ojs.float_of_js (Ojs.get_prop_ascii x44 "padding")
        }

      and t_to_js : t -> Ojs.t =
        fun (x41 : t) ->
        Ojs.obj
          [| "alignment", Ojs.option_to_js Alignment.t_to_js x41.alignment
           ; "padding", Ojs.option_to_js Ojs.float_to_js x41.padding
          |]
      ;;
    end

    let create : Options.t -> t =
      fun (x47 : Options.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
           "autoPlacement"
           [| Options.t_to_js x47 |])
    ;;
  end

  module Arrow = struct
    module Options = struct
      type t =
        { element : Dom_html.element Js.t
        ; padding : float option
        }

      let rec t_of_js : Ojs.t -> t =
        fun (x51 : Ojs.t) ->
        { element = Js.t_of_js Dom_html.element_of_js (Ojs.get_prop_ascii x51 "element")
        ; padding = Ojs.option_of_js Ojs.float_of_js (Ojs.get_prop_ascii x51 "padding")
        }

      and t_to_js : t -> Ojs.t =
        fun (x48 : t) ->
        Ojs.obj
          [| "element", Js.t_to_js Dom_html.element_to_js x48.element
           ; "padding", Ojs.option_to_js Ojs.float_to_js x48.padding
          |]
      ;;
    end

    let create : Options.t -> t =
      fun (x54 : Options.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
           "arrow"
           [| Options.t_to_js x54 |])
    ;;
  end
end

module Reference_element = struct
  module Client_rect_object = struct
    type t =
      { width : float
      ; height : float
      ; x : float
      ; y : float
      ; top : float
      ; left : float
      ; right : float
      ; bottom : float
      }

    let rec t_of_js : Ojs.t -> t =
      fun (x56 : Ojs.t) ->
      { width = Ojs.float_of_js (Ojs.get_prop_ascii x56 "width")
      ; height = Ojs.float_of_js (Ojs.get_prop_ascii x56 "height")
      ; x = Ojs.float_of_js (Ojs.get_prop_ascii x56 "x")
      ; y = Ojs.float_of_js (Ojs.get_prop_ascii x56 "y")
      ; top = Ojs.float_of_js (Ojs.get_prop_ascii x56 "top")
      ; left = Ojs.float_of_js (Ojs.get_prop_ascii x56 "left")
      ; right = Ojs.float_of_js (Ojs.get_prop_ascii x56 "right")
      ; bottom = Ojs.float_of_js (Ojs.get_prop_ascii x56 "bottom")
      }

    and t_to_js : t -> Ojs.t =
      fun (x55 : t) ->
      Ojs.obj
        [| "width", Ojs.float_to_js x55.width
         ; "height", Ojs.float_to_js x55.height
         ; "x", Ojs.float_to_js x55.x
         ; "y", Ojs.float_to_js x55.y
         ; "top", Ojs.float_to_js x55.top
         ; "left", Ojs.float_to_js x55.left
         ; "right", Ojs.float_to_js x55.right
         ; "bottom", Ojs.float_to_js x55.bottom
        |]
    ;;
  end

  module Virtual_element = struct
    type t = { get_bounding_client_rect : unit -> Client_rect_object.t }

    let rec t_of_js : Ojs.t -> t =
      fun (x58 : Ojs.t) ->
      { get_bounding_client_rect =
          (fun () ->
            Client_rect_object.t_of_js
              (Ojs.apply (Ojs.get_prop_ascii x58 "getBoundingClientRect") [||]))
      }

    and t_to_js : t -> Ojs.t =
      fun (x57 : t) ->
      Ojs.obj
        [| ( "getBoundingClientRect"
           , Ojs.fun_to_js 1 (fun _ ->
               Client_rect_object.t_to_js (x57.get_bounding_client_rect ())) )
        |]
    ;;
  end

  type t =
    [ `Virtual of Virtual_element.t
    | `Dom of Dom_html.element Js.t
    ]

  let rec t_to_js : t -> Ojs.t =
    fun (x59 : [ `Virtual of Virtual_element.t | `Dom of Dom_html.element Js.t ]) ->
    match x59 with
    | `Virtual x60 -> Virtual_element.t_to_js x60
    | `Dom x61 -> Js.t_to_js Dom_html.element_to_js x61
  ;;
end

module Compute_position = struct
  module Options = struct
    type t =
      { placement : Placement.t option
      ; strategy : Strategy.t
      ; middleware : Middleware.t list
      }

    let rec t_of_js : Ojs.t -> t =
      fun (x69 : Ojs.t) ->
      { placement =
          Ojs.option_of_js Placement.t_of_js (Ojs.get_prop_ascii x69 "placement")
      ; strategy = Strategy.t_of_js (Ojs.get_prop_ascii x69 "strategy")
      ; middleware =
          Ojs.list_of_js Middleware.t_of_js (Ojs.get_prop_ascii x69 "middleware")
      }

    and t_to_js : t -> Ojs.t =
      fun (x66 : t) ->
      Ojs.obj
        [| "placement", Ojs.option_to_js Placement.t_to_js x66.placement
         ; "strategy", Strategy.t_to_js x66.strategy
         ; "middleware", Ojs.list_to_js Middleware.t_to_js x66.middleware
        |]
    ;;
  end

  module Then_args = struct
    type arrow =
      { x : float option
      ; y : float option
      }

    let rec arrow_of_js : Ojs.t -> arrow =
      fun (x75 : Ojs.t) ->
      { x = Ojs.option_of_js Ojs.float_of_js (Ojs.get_prop_ascii x75 "x")
      ; y = Ojs.option_of_js Ojs.float_of_js (Ojs.get_prop_ascii x75 "y")
      }

    and arrow_to_js : arrow -> Ojs.t =
      fun (x72 : arrow) ->
      Ojs.obj
        [| "x", Ojs.option_to_js Ojs.float_to_js x72.x
         ; "y", Ojs.option_to_js Ojs.float_to_js x72.y
        |]
    ;;

    type middleware_data = { arrow : arrow option }

    let rec middleware_data_of_js : Ojs.t -> middleware_data =
      fun (x80 : Ojs.t) ->
      { arrow = Ojs.option_of_js arrow_of_js (Ojs.get_prop_ascii x80 "arrow") }

    and middleware_data_to_js : middleware_data -> Ojs.t =
      fun (x78 : middleware_data) ->
      Ojs.obj [| "arrow", Ojs.option_to_js arrow_to_js x78.arrow |]
    ;;

    type t =
      { x : float
      ; y : float
      ; placement : Placement.t
      ; strategy : Strategy.t
      ; middleware_data : middleware_data option
      }

    let rec t_of_js : Ojs.t -> t =
      fun (x84 : Ojs.t) ->
      { x = Ojs.float_of_js (Ojs.get_prop_ascii x84 "x")
      ; y = Ojs.float_of_js (Ojs.get_prop_ascii x84 "y")
      ; placement = Placement.t_of_js (Ojs.get_prop_ascii x84 "placement")
      ; strategy = Strategy.t_of_js (Ojs.get_prop_ascii x84 "strategy")
      ; middleware_data =
          Ojs.option_of_js middleware_data_of_js (Ojs.get_prop_ascii x84 "middlewareData")
      }

    and t_to_js : t -> Ojs.t =
      fun (x82 : t) ->
      Ojs.obj
        [| "x", Ojs.float_to_js x82.x
         ; "y", Ojs.float_to_js x82.y
         ; "placement", Placement.t_to_js x82.placement
         ; "strategy", Strategy.t_to_js x82.strategy
         ; "middlewareData", Ojs.option_to_js middleware_data_to_js x82.middleware_data
        |]
    ;;
  end

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x87 : Ojs.t) -> x87
  and t_to_js : t -> Ojs.t = fun (x86 : Ojs.t) -> x86

  let then_ : t -> (Then_args.t -> unit) -> unit =
    fun (x90 : t) (x88 : Then_args.t -> unit) ->
    (ignore : _)
      (Ojs.call
         (t_to_js x90)
         "then"
         [| Ojs.fun_to_js 1 (fun (x89 : Ojs.t) -> x88 (Then_args.t_of_js x89)) |])
  ;;

  let create
    : anchor:Reference_element.t -> floating:Dom_html.element Js.t -> Options.t -> t
    =
    fun ~anchor:(x91 : Reference_element.t)
      ~floating:(x92 : Dom_html.element Js.t)
      (x94 : Options.t) ->
    t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
         "computePosition"
         [| Reference_element.t_to_js x91
          ; Js.t_to_js Dom_html.element_to_js x92
          ; Options.t_to_js x94
         |])
  ;;
end

module Auto_update_handle = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x96 : Ojs.t) -> x96
  and t_to_js : t -> Ojs.t = fun (x95 : Ojs.t) -> x95

  let create
    :  anchor:Reference_element.t -> floating:Dom_html.element Js.t
    -> update:(unit -> unit) -> t
    =
    fun ~anchor:(x97 : Reference_element.t)
      ~floating:(x98 : Dom_html.element Js.t)
      ~update:(x100 : unit -> unit) ->
    t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii Ojs.global "FloatingUIDOM")
         "autoUpdate"
         [| Reference_element.t_to_js x97
          ; Js.t_to_js Dom_html.element_to_js x98
          ; Ojs.fun_to_js 1 (fun _ -> x100 ())
         |])
  ;;

  let cleanup : t -> unit = fun (x101 : t) -> (ignore : _) (Ojs.apply (t_to_js x101) [||])
end
