@@ portable

open! Base
open! Import
module Hlist = Hlist

(** [t] is the type of implementations of parallelism. Operations that produce parallel
    tasks take a [t] that provides an implementation of parallelism for them to use. *)
type t : value mod contended portable

module Thunk : sig
  type nonrec 'a t = t @ local -> 'a
end

(** [fork_join t fs] runs the functions in the heterogenous list [f] as parallel tasks and
    returns their results. If any task raises, this operation will reraise the leftmost
    exception after all tasks have completed or raised.

    Child tasks must not block on each other or the parent task, but they may take locks. *)
val fork_join
  :  t @ local
  -> 'a Hlist.Gen(Thunk).t @ once portable unyielding
  -> 'a Hlist.t

(* $MDX part-begin=fork_join2 *)

(** [fork_join2 t f g] runs [f] and [g] as parallel tasks and returns their results. If
    either task raises, this operation will reraise the leftmost exception after both
    tasks have completed or raised.

    Child tasks must not block on each other or the parent task, but they may take locks. *)
val fork_join2
  :  t @ local
  -> (t @ local -> 'a) @ local once
  -> (t @ local -> 'b) @ once portable unyielding
  -> #('a * 'b)

(* $MDX part-end *)

(** See {!fork_join2} *)
val fork_join3
  :  t @ local
  -> (t @ local -> 'a) @ local once
  -> (t @ local -> 'b) @ once portable unyielding
  -> (t @ local -> 'c) @ once portable unyielding
  -> #('a * 'b * 'c)

(** See {!fork_join2} *)
val fork_join4
  :  t @ local
  -> (t @ local -> 'a) @ local once
  -> (t @ local -> 'b) @ once portable unyielding
  -> (t @ local -> 'c) @ once portable unyielding
  -> (t @ local -> 'd) @ once portable unyielding
  -> #('a * 'b * 'c * 'd)

(** See {!fork_join2} *)
val fork_join5
  :  t @ local
  -> (t @ local -> 'a) @ local once
  -> (t @ local -> 'b) @ once portable unyielding
  -> (t @ local -> 'c) @ once portable unyielding
  -> (t @ local -> 'd) @ once portable unyielding
  -> (t @ local -> 'e) @ once portable unyielding
  -> #('a * 'b * 'c * 'd * 'e)

(** [for_ ?grain t ~start ~stop ~f] runs [f t i] as a parallel task for each [i] in the
    range [start..stop-1]. If [grain] is specified, blocks of [grain] indices will
    constitute a single parallel task.

    If any invocation of [f] raises, this operation will reraise the leftmost exception.
    If an exception occurs at index [i], [f] may or may not be invoked for any [j > i]. *)
val for_
  :  ?grain:int
  -> t @ local
  -> start:int
  -> stop:int
  -> f:(t @ local -> int -> unit) @ portable unyielding
  -> unit

(** [fold ?grain t ~init ~state ~next ~stop ~fork ~join] folds an accumulator over a
    sequence of states generated by [next]. The initial accumulator is [init ()] and the
    initial state is [state]. At each step, [next t state acc] is applied to get the next
    accumulator and state. When [next] returns [None], the current accumulator is passed
    to [stop] and then returned as the result of [fold]. If [grain] is specified, blocks
    of [grain] indices will constitute a single parallel task.

    [init], [stop], [fork], and [join] allow the scheduler to split states into parts that
    may be folded in parallel, then recombined with [join]. Given a state [s], [fork s]
    returns two states [s0, s1] such that:

    [stop (fold acc s) = join (stop (fold acc s0)) (stop (fold (init ()) s1))]

    The operation implemented by the callbacks must be associative, and [init] must return
    a neutral element. If this is not the case, results will be non-deterministic. *)
val fold
  : ('acc : value mod portable unyielding)
    ('seq : value mod contended portable unyielding) 'ret.
  ?grain:int
  -> t @ local
  -> init:(unit -> 'acc) @ portable unyielding
  -> state:'seq
  -> next:(t @ local -> 'acc -> 'seq -> ('acc, 'seq) Pair_or_null.t) @ portable unyielding
  -> stop:(t @ local -> 'acc -> 'ret) @ portable unyielding
  -> fork:(t @ local -> 'seq -> ('seq, 'seq) Pair_or_null.t) @ portable unyielding
  -> join:(t @ local -> 'ret -> 'ret -> 'ret) @ portable unyielding
  -> 'ret

module Scheduler : sig
  module type S = Parallel_scheduler_intf.S with type parallel := t
  module type S_concurrent = Parallel_scheduler_intf.S_concurrent with type parallel := t

  (** A trivial implementation of parallelism that runs all tasks sequentially. *)
  module Sequential : sig
    include S

    val create : ?max_domains:int -> unit -> t
  end

  (** [heartbeat t ~n] allows [n] jobs to be promoted to parallel tasks. If there are
      fewer than [n] tasks in the current queue, the remaining count will be used to
      eagerly promote new tasks. If [n < 0], the next [n] promotions will be skipped. *)
  val heartbeat : t @ local -> n:int -> unit
end

module For_scheduler : sig
  module Result = Result

  (** [root f ~promote ~wake] creates a top-level, schedulable task representing the full
      execution of [f]. The functions [f], [promote], and [wake] must not raise
      exceptions. All schedulers must use [root] to create the initial portable function
      they inject into the worker pool.

      The functions [promote] and [wake] define the behavior of the scheduler. When the
      heartbeat mechanism determines enough work has occurred to amortize promotion
      overhead, it calls [promote], which gives the scheduler an opportunity to distribute
      tasks to other domains. After promoting [n] tasks, [wake ~n] is called, which tells
      the scheduler how many workers it may want to wake up. *)
  val root
    :  unit Thunk.t @ once portable
    -> promote:((unit -> unit) @ once portable -> unit) @ portable
    -> wake:(n:int -> unit) @ portable
    -> (unit -> unit) @ once portable

  (** [await t trigger] suspends the current task until [trigger] is signaled, at which
      point it will be re-promoted. *)
  val await : t @ local -> Await.Trigger.t -> unit

  (** [with_heartbeat f] assures the heartbeat thread is running for the duration of [f]. *)
  val with_heartbeat : (unit -> unit) @ local once -> unit
end

module For_testing : sig
  module Runqueue : sig
    type t

    val create : unit -> t @ local

    val with_jobs
      :  t @ local
      -> ('l * 'll) Hlist.Gen(Thunk).t @ once portable
      -> f:(t @ local -> unit) @ local
      -> unit

    val promote : t @ local -> n:int -> f:(unit -> unit) @ local -> unit
  end
end
