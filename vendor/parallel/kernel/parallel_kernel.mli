@@ portable

open! Base
open! Import
module Hlist = Hlist

(** [t] is the type of implementations of parallelism. Operations that produce parallel
    tasks take a [t] that provides an implementation of parallelism for them to use. *)
type t : value mod contended portable

module Thunk : sig
  type nonrec 'a t = t @ local -> 'a
end

(** [fork_join t fs] runs the functions in the heterogenous list [f] as parallel tasks and
    returns their results. If any task raises, this operation will reraise the leftmost
    exception after all tasks have completed or raised.

    Child tasks must not block on each other or the parent task, but they may take locks. *)
val fork_join : t @ local -> 'a Hlist.Gen(Thunk).t @ once portable -> 'a Hlist.t

(* $MDX part-begin=fork_join2 *)

(** [fork_join2 t f g] runs [f] and [g] as parallel tasks and returns their results. If
    either task raises, this operation will reraise the leftmost exception after both
    tasks have completed or raised.

    Child tasks must not block on each other or the parent task, but they may take locks. *)
val fork_join2
  :  t @ local
  -> (t @ local -> 'a) @ local once
  -> (t @ local -> 'b) @ once portable
  -> #('a * 'b)

(* $MDX part-end *)

(** See {!fork_join2} *)
val fork_join3
  :  t @ local
  -> (t @ local -> 'a) @ local once
  -> (t @ local -> 'b) @ once portable
  -> (t @ local -> 'c) @ once portable
  -> #('a * 'b * 'c)

(** See {!fork_join2} *)
val fork_join4
  :  t @ local
  -> (t @ local -> 'a) @ local once
  -> (t @ local -> 'b) @ once portable
  -> (t @ local -> 'c) @ once portable
  -> (t @ local -> 'd) @ once portable
  -> #('a * 'b * 'c * 'd)

(** See {!fork_join2} *)
val fork_join5
  :  t @ local
  -> (t @ local -> 'a) @ local once
  -> (t @ local -> 'b) @ once portable
  -> (t @ local -> 'c) @ once portable
  -> (t @ local -> 'd) @ once portable
  -> (t @ local -> 'e) @ once portable
  -> #('a * 'b * 'c * 'd * 'e)

(** [for_ t ~start ~stop ~f] runs [f t i] as a parallel task for each [i] in the range
    [start..stop-1].

    If any invocation of [f] raises, this operation will reraise the leftmost exception.
    If an exception occurs at index [i], [f] may or may not be invoked for any [j > i]. *)
val for_
  :  t @ local
  -> start:int
  -> stop:int
  -> f:(t @ local -> int -> unit) @ portable
  -> unit

(** [fold t ~init ~state ~next ~stop ~fork ~join] folds an accumulator over a sequence of
    states generated by [next]. The initial accumulator is [init ()] and the initial state
    is [state]. At each step, [next t state acc] is applied to get the next accumulator
    and state. When [next] returns [None], the current accumulator is passed to [stop] and
    then returned as the result of [fold].

    [init], [stop], [fork], and [join] allow the scheduler to split states into parts that
    may be folded in parallel, then recombined with [join]. Given a state [s], [fork s]
    returns two states [s0, s1] such that:

    [stop (fold acc s) = join (stop (fold acc s0)) (stop (fold (init ()) s1))]

    The operation implemented by the callbacks must be associative, and [init] must return
    a neutral element. If this is not the case, results will be non-deterministic. *)
val fold
  : ('acc : value mod portable) ('seq : value mod contended portable) 'ret.
  t @ local
  -> init:(unit -> 'acc) @ portable
  -> state:'seq
  -> next:(t @ local -> 'acc -> 'seq -> ('acc, 'seq) Pair_or_null.t) @ portable
  -> stop:(t @ local -> 'acc -> 'ret) @ portable
  -> fork:(t @ local -> 'seq -> ('seq, 'seq) Pair_or_null.t) @ portable
  -> join:(t @ local -> 'ret -> 'ret -> 'ret) @ portable
  -> 'ret

module Scheduler : sig
  module type S = Parallel_scheduler_intf.S with type parallel := t
  module type S_concurrent = Parallel_scheduler_intf.S_concurrent with type parallel := t

  (** A trivial scheduler that runs all parallel tasks sequentially. *)
  module Sequential : S

  (** [heartbeat t ~n] allows [n] jobs to be promoted to parallel tasks. If there are
      fewer than [n] tasks in the current queue, the remaining count will be used to
      eagerly promote new tasks. If [n < 0], the next [n] promotions will be skipped. *)
  val heartbeat : t @ local -> n:int -> unit
end

module For_scheduler : sig
  module Result = Result

  exception Out_of_fibers

  (** [root_exn f ~promote ~wake] creates a top-level, schedulable task representing the
      full execution of [f]. The functions [f], [promote], and [wake] must not raise
      exceptions. All schedulers must use [root_exn] to create the initial portable
      function they inject into the worker pool.

      The functions [promote] and [wake] define the behavior of the scheduler. When the
      heartbeat mechanism determines enough work has occurred to amortize promotion
      overhead, it calls [promote], which gives the scheduler an opportunity to distribute
      tasks to other domains. After promoting [n] tasks, [wake ~n] is called, which tells
      the scheduler how many workers it may want to wake up. If a heartbeat occurs during
      [promote] or [wake], they may be re-entered.

      @raise Out_of_fibers if unable to allocate a fiber. *)
  val root_exn
    :  unit Thunk.t @ once portable
    -> promote:((unit -> unit) @ once portable -> unit) @ portable
    -> wake:(n:int -> unit) @ portable
    -> (unit -> unit) @ once portable

  (** [await t trigger] suspends the current task until [trigger] is signaled, at which
      point it will be re-promoted. *)
  val await : t @ local -> Await.Trigger.t -> unit

  (** [with_heartbeat f] assures the heartbeat thread is running for the duration of [f]. *)
  val with_heartbeat : (unit -> unit) @ local once -> unit

  (** [without_heartbeat f] masks heartbeats for the duration of [f]. *)
  val without_heartbeat : ('a : value_or_null). (unit -> 'a) @ local once unyielding -> 'a
end

module For_testing : sig
  module Runqueue : sig
    type t

    val create : unit -> t @ local
    val tokens : t @ local -> int

    val with_jobs
      :  t @ local
      -> ('l * 'll) Hlist.Gen(Thunk).t @ once portable
      -> f:(t @ local -> unit) @ local
      -> unit

    val promote : t @ local -> n:int -> f:(tokens:int -> unit) @ local -> unit
  end
end
