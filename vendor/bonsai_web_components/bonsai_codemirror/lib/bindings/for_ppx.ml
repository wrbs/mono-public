[@@@js.dummy "!! This code has been generated by gen_js_api !!"]
[@@@ocaml.warning "-7-32-39"]

open! Js_of_ocaml
open! Gen_js_api
open Custom_ojs_converter

module Promise = struct
  type ('a, 'e) t = Ojs.t

  let rec t_of_js : 'a 'e. (Ojs.t -> 'a) -> (Ojs.t -> 'e) -> Ojs.t -> ('a, 'e) t =
    fun (type __a __e) (__a_of_js : Ojs.t -> __a) (__e_of_js : Ojs.t -> __e) (x2 : Ojs.t) ->
    x2

  and t_to_js : 'a 'e. ('a -> Ojs.t) -> ('e -> Ojs.t) -> ('a, 'e) t -> Ojs.t =
    fun (type __a __e) (__a_to_js : __a -> Ojs.t) (__e_to_js : __e -> Ojs.t) (x1 : Ojs.t) ->
    x1
  ;;

  let create : (('a -> unit) -> ('e -> unit) -> unit) -> ('a, 'e) t =
    fun (x3 : ('a -> unit) -> ('e -> unit) -> unit) ->
    t_of_js
      Obj.magic
      Obj.magic
      (Ojs.new_obj
         (Ojs.get_prop_ascii Ojs.global "Promise")
         [| Ojs.fun_to_js 2 (fun (x4 : Ojs.t) (x6 : Ojs.t) ->
              x3
                (fun (x5 : 'a) -> (ignore : _) (Ojs.apply x4 [| Obj.magic x5 |]))
                (fun (x7 : 'e) -> (ignore : _) (Ojs.apply x6 [| Obj.magic x7 |])))
         |])
  ;;
end

module RegExp = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x11 : Ojs.t) -> x11
  and t_to_js : t -> Ojs.t = fun (x10 : Ojs.t) -> x10

  let create : string -> string option -> t =
    fun (x12 : string) (x13 : string option) ->
    t_of_js
      (Ojs.new_obj
         (Ojs.get_prop_ascii Ojs.global "RegExp")
         [| Ojs.string_to_js x12; Ojs.option_to_js Ojs.string_to_js x13 |])
  ;;
end

module Text = struct
  module Line = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x16 : Ojs.t) -> x16
    and t_to_js : t -> Ojs.t = fun (x15 : Ojs.t) -> x15

    let from : t -> int =
      fun (x17 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x17) "from")
    ;;

    let to_ : t -> int =
      fun (x18 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x18) "to")
    ;;

    let number : t -> int =
      fun (x19 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x19) "number")
    ;;

    let text : t -> string =
      fun (x20 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x20) "text")
    ;;

    let length : t -> int =
      fun (x21 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x21) "length")
    ;;
  end

  module Text_iterator = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x23 : Ojs.t) -> x23
    and t_to_js : t -> Ojs.t = fun (x22 : Ojs.t) -> x22

    let next : t -> ?skip:int -> unit -> t =
      fun (x27 : t) ?skip:(x24 : int option) () ->
      t_of_js
        (let x28 = t_to_js x27 in
         Ojs.call
           (Ojs.get_prop_ascii x28 "next")
           "apply"
           [| x28
            ; (let x25 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x24 with
                | Some x26 -> (ignore : _) (Ojs.call x25 "push" [| Ojs.int_to_js x26 |])
                | None -> ());
               x25)
           |])
    ;;

    let value : t -> string =
      fun (x29 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x29) "value")
    ;;

    let done_ : t -> bool =
      fun (x30 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x30) "done")
    ;;

    let line_break : t -> bool =
      fun (x31 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x31) "lineBreak")
    ;;
  end

  module Text = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x33 : Ojs.t) -> x33
    and t_to_js : t -> Ojs.t = fun (x32 : Ojs.t) -> x32

    let length : t -> int =
      fun (x34 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x34) "length")
    ;;

    let lines : t -> int =
      fun (x35 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x35) "lines")
    ;;

    let line_at : t -> int -> Line.t =
      fun (x37 : t) (x36 : int) ->
      Line.t_of_js (Ojs.call (t_to_js x37) "lineAt" [| Ojs.int_to_js x36 |])
    ;;

    let line : t -> int -> Line.t =
      fun (x39 : t) (x38 : int) ->
      Line.t_of_js (Ojs.call (t_to_js x39) "line" [| Ojs.int_to_js x38 |])
    ;;

    let replace : t -> from:int -> to_:int -> with_:t -> t =
      fun (x43 : t) ~from:(x40 : int) ~to_:(x41 : int) ~with_:(x42 : t) ->
      t_of_js
        (Ojs.call
           (t_to_js x43)
           "replace"
           [| Ojs.int_to_js x40; Ojs.int_to_js x41; t_to_js x42 |])
    ;;

    let append : t -> t -> t =
      fun (x45 : t) (x44 : t) ->
      t_of_js (Ojs.call (t_to_js x45) "append" [| t_to_js x44 |])
    ;;

    let slice : t -> from:int -> ?to_:int -> unit -> t =
      fun (x50 : t) ~from:(x46 : int) ?to_:(x47 : int option) () ->
      t_of_js
        (let x51 = t_to_js x50 in
         Ojs.call
           (Ojs.get_prop_ascii x51 "slice")
           "apply"
           [| x51
            ; (let x48 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x48 "push" [| Ojs.int_to_js x46 |]);
               (match x47 with
                | Some x49 -> (ignore : _) (Ojs.call x48 "push" [| Ojs.int_to_js x49 |])
                | None -> ());
               x48)
           |])
    ;;

    let slice_string : t -> from:int -> ?to_:int -> ?line_sep:string -> unit -> string =
      fun (x58 : t)
        ~from:(x52 : int)
        ?to_:(x53 : int option)
        ?line_sep:(x54 : string option)
        () ->
      Ojs.string_of_js
        (let x59 = t_to_js x58 in
         Ojs.call
           (Ojs.get_prop_ascii x59 "sliceString")
           "apply"
           [| x59
            ; (let x55 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x55 "push" [| Ojs.int_to_js x52 |]);
               (match x53 with
                | Some x57 -> (ignore : _) (Ojs.call x55 "push" [| Ojs.int_to_js x57 |])
                | None -> ());
               (match x54 with
                | Some x56 ->
                  (ignore : _) (Ojs.call x55 "push" [| Ojs.string_to_js x56 |])
                | None -> ());
               x55)
           |])
    ;;

    let equal : t -> t -> bool =
      fun (x61 : t) (x60 : t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x61) "eq" [| t_to_js x60 |])
    ;;

    let iter : t -> ?dir:int -> unit -> Text_iterator.t =
      fun (x65 : t) ?dir:(x62 : int option) () ->
      Text_iterator.t_of_js
        (let x66 = t_to_js x65 in
         Ojs.call
           (Ojs.get_prop_ascii x66 "iter")
           "apply"
           [| x66
            ; (let x63 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x62 with
                | Some x64 -> (ignore : _) (Ojs.call x63 "push" [| Ojs.int_to_js x64 |])
                | None -> ());
               x63)
           |])
    ;;

    let iter_range : t -> from:int -> ?to_:int -> unit -> Text_iterator.t =
      fun (x71 : t) ~from:(x67 : int) ?to_:(x68 : int option) () ->
      Text_iterator.t_of_js
        (let x72 = t_to_js x71 in
         Ojs.call
           (Ojs.get_prop_ascii x72 "iterRange")
           "apply"
           [| x72
            ; (let x69 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x69 "push" [| Ojs.int_to_js x67 |]);
               (match x68 with
                | Some x70 -> (ignore : _) (Ojs.call x69 "push" [| Ojs.int_to_js x70 |])
                | None -> ());
               x69)
           |])
    ;;

    let iter_lines : t -> ?from:int -> ?to_:int -> unit -> Text_iterator.t =
      fun (x78 : t) ?from:(x73 : int option) ?to_:(x74 : int option) () ->
      Text_iterator.t_of_js
        (let x79 = t_to_js x78 in
         Ojs.call
           (Ojs.get_prop_ascii x79 "iterLines")
           "apply"
           [| x79
            ; (let x75 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x73 with
                | Some x77 -> (ignore : _) (Ojs.call x75 "push" [| Ojs.int_to_js x77 |])
                | None -> ());
               (match x74 with
                | Some x76 -> (ignore : _) (Ojs.call x75 "push" [| Ojs.int_to_js x76 |])
                | None -> ());
               x75)
           |])
    ;;

    let to_json : t -> string list =
      fun (x80 : t) ->
      Ojs.list_of_js Ojs.string_of_js (Ojs.call (t_to_js x80) "toJSON" [||])
    ;;

    let of_ : string list -> t =
      fun (x82 : string list) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Text")
           "of"
           [| Ojs.list_to_js Ojs.string_to_js x82 |])
    ;;

    let of_array : string array -> t =
      fun (x84 : string array) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Text")
           "of"
           [| Ojs.array_to_js Ojs.string_to_js x84 |])
    ;;

    let empty : t =
      t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Text")
           "empty")
    ;;
  end

  let count_column : string -> n:int -> tab_size:int -> int =
    fun (x88 : string) ~n:(x86 : int) ~tab_size:(x87 : int) ->
    Ojs.int_of_js
      (Ojs.call
         (Ojs.string_to_js x88)
         "countColumn"
         [| Ojs.int_to_js x86; Ojs.int_to_js x87 |])
  ;;

  module Offset_and_left_over = struct
    type t =
      { offset : int
      ; left_over : int
      }

    let rec t_of_js : Ojs.t -> t =
      fun (x90 : Ojs.t) ->
      { offset = Ojs.int_of_js (Ojs.get_prop_ascii x90 "offset")
      ; left_over = Ojs.int_of_js (Ojs.get_prop_ascii x90 "leftOver")
      }

    and t_to_js : t -> Ojs.t =
      fun (x89 : t) ->
      Ojs.obj
        [| "offset", Ojs.int_to_js x89.offset; "leftOver", Ojs.int_to_js x89.left_over |]
    ;;
  end

  let find_column : string -> n:int -> col:int -> tab_size:int -> Offset_and_left_over.t =
    fun (x94 : string) ~n:(x91 : int) ~col:(x92 : int) ~tab_size:(x93 : int) ->
    Offset_and_left_over.t_of_js
      (Ojs.call
         (Ojs.string_to_js x94)
         "findColumn"
         [| Ojs.int_to_js x91; Ojs.int_to_js x92; Ojs.int_to_js x93 |])
  ;;

  let code_point_at : string -> int -> int =
    fun (x96 : string) (x95 : int) ->
    Ojs.int_of_js (Ojs.call (Ojs.string_to_js x96) "codePointAt" [| Ojs.int_to_js x95 |])
  ;;

  let from_code_point : int -> string =
    fun (x97 : int) ->
    Ojs.string_of_js (Ojs.call (Ojs.int_to_js x97) "fromCodePoint" [||])
  ;;

  let code_point_size : int -> int =
    fun (x98 : int) -> Ojs.int_of_js (Ojs.call (Ojs.int_to_js x98) "codePointSize" [||])
  ;;

  let find_cluster_break : string -> int -> ?forward:bool -> unit -> int =
    fun (x103 : string) (x99 : int) ?forward:(x100 : bool option) () ->
    Ojs.int_of_js
      (let x104 = Ojs.string_to_js x103 in
       Ojs.call
         (Ojs.get_prop_ascii x104 "findClusterBreak")
         "apply"
         [| x104
          ; (let x101 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (ignore : _) (Ojs.call x101 "push" [| Ojs.int_to_js x99 |]);
             (match x100 with
              | Some x102 -> (ignore : _) (Ojs.call x101 "push" [| Ojs.bool_to_js x102 |])
              | None -> ());
             x101)
         |])
  ;;
end

module State = struct
  module Extension = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x106 : Ojs.t) -> x106
    and t_to_js : t -> Ojs.t = fun (x105 : Ojs.t) -> x105

    let of_list : t list -> t =
      fun (x107 : t list) -> t_of_js (Ojs.list_to_js t_to_js x107)
    ;;
  end

  module Editor_state_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x110 : Ojs.t) -> x110
    and t_to_js : t -> Ojs.t = fun (x109 : Ojs.t) -> x109

    let create : ?doc:string -> ?extensions:Extension.t list -> unit -> t =
      fun ?doc:(x111 : string option) ?extensions:(x112 : Extension.t list option) () ->
      let x113 = Ojs.empty_obj () in
      (match x111 with
       | Some x116 -> Ojs.set_prop_ascii x113 "doc" (Ojs.string_to_js x116)
       | None -> ());
      (match x112 with
       | Some x114 ->
         Ojs.set_prop_ascii x113 "extensions" (Ojs.list_to_js Extension.t_to_js x114)
       | None -> ());
      t_of_js x113
    ;;
  end

  type state_effect = Ojs.t

  let rec state_effect_of_js : Ojs.t -> state_effect = fun (x118 : Ojs.t) -> x118
  and state_effect_to_js : state_effect -> Ojs.t = fun (x117 : Ojs.t) -> x117

  module State_effect_type = struct
    type 'a t = Ojs.t

    let rec t_of_js : 'a. (Ojs.t -> 'a) -> Ojs.t -> 'a t =
      fun (type __a) (__a_of_js : Ojs.t -> __a) (x120 : Ojs.t) -> x120

    and t_to_js : 'a. ('a -> Ojs.t) -> 'a t -> Ojs.t =
      fun (type __a) (__a_to_js : __a -> Ojs.t) (x119 : Ojs.t) -> x119
    ;;

    let of_ : 'a t -> 'a -> state_effect =
      fun (x122 : 'a t) (x121 : 'a) ->
      state_effect_of_js (Ojs.call (t_to_js Obj.magic x122) "of" [| Obj.magic x121 |])
    ;;
  end

  module State_effect = struct
    type t = state_effect

    let rec t_of_js : Ojs.t -> t = fun (x125 : Ojs.t) -> state_effect_of_js x125
    and t_to_js : t -> Ojs.t = fun (x124 : state_effect) -> state_effect_to_js x124

    let value : t -> 'a =
      fun (x126 : t) -> Obj.magic (Ojs.get_prop_ascii (t_to_js x126) "value")
    ;;

    let is : t -> type_:'a State_effect_type.t -> bool =
      fun (x129 : t) ~type_:(x127 : 'a State_effect_type.t) ->
      Ojs.bool_of_js
        (Ojs.call (t_to_js x129) "is" [| State_effect_type.t_to_js Obj.magic x127 |])
    ;;

    let define : unit -> 'a State_effect_type.t =
      fun () ->
      State_effect_type.t_of_js
        Obj.magic
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "StateEffect")
           "define"
           [||])
    ;;

    let reconfigure : Extension.t State_effect_type.t =
      State_effect_type.t_of_js
        Extension.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "StateEffect")
           "reconfigure")
    ;;
  end

  module Annotation = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x133 : Ojs.t) -> x133
    and t_to_js : t -> Ojs.t = fun (x132 : Ojs.t) -> x132
  end

  module Effects_and_annotation = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x135 : Ojs.t) -> x135
    and t_to_js : t -> Ojs.t = fun (x134 : Ojs.t) -> x134

    let create
      : ?effects:State_effect.t list -> ?annotations:Annotation.t list -> unit -> t
      =
      fun ?effects:(x136 : State_effect.t list option)
        ?annotations:(x137 : Annotation.t list option)
        () ->
      let x138 = Ojs.empty_obj () in
      (match x136 with
       | Some x141 ->
         Ojs.set_prop_ascii x138 "effects" (Ojs.list_to_js State_effect.t_to_js x141)
       | None -> ());
      (match x137 with
       | Some x139 ->
         Ojs.set_prop_ascii x138 "annotations" (Ojs.list_to_js Annotation.t_to_js x139)
       | None -> ());
      t_of_js x138
    ;;
  end

  type change_set = Ojs.t

  let rec change_set_of_js : Ojs.t -> change_set = fun (x144 : Ojs.t) -> x144
  and change_set_to_js : change_set -> Ojs.t = fun (x143 : Ojs.t) -> x143

  module Change_spec = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x146 : Ojs.t) -> x146
    and t_to_js : t -> Ojs.t = fun (x145 : Ojs.t) -> x145

    let single : ?from:int -> ?to_:int -> ?insert:Text.Text.t -> unit -> t =
      fun ?from:(x147 : int option)
        ?to_:(x148 : int option)
        ?insert:(x149 : Text.Text.t option)
        () ->
      let x150 = Ojs.empty_obj () in
      (match x147 with
       | Some x153 -> Ojs.set_prop_ascii x150 "from" (Ojs.int_to_js x153)
       | None -> ());
      (match x148 with
       | Some x152 -> Ojs.set_prop_ascii x150 "to" (Ojs.int_to_js x152)
       | None -> ());
      (match x149 with
       | Some x151 -> Ojs.set_prop_ascii x150 "insert" (Text.Text.t_to_js x151)
       | None -> ());
      t_of_js x150
    ;;

    let change_set : change_set -> t =
      fun (x154 : change_set) -> t_of_js (change_set_to_js x154)
    ;;

    let many : t list -> t = fun (x155 : t list) -> t_of_js (Ojs.list_to_js t_to_js x155)
  end

  module Map_mode = struct
    type t =
      | Simple
      | TrackDel
      | TrackBefore
      | TrackAfter

    let rec t_of_js : Ojs.t -> t =
      fun (x158 : Ojs.t) ->
      let x159 = x158 in
      match Ojs.string_of_js x159 with
      | "Simple" -> Simple
      | "TrackDel" -> TrackDel
      | "TrackBefore" -> TrackBefore
      | "TrackAfter" -> TrackAfter
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x157 : t) ->
      match x157 with
      | Simple -> Ojs.string_to_js "Simple"
      | TrackDel -> Ojs.string_to_js "TrackDel"
      | TrackBefore -> Ojs.string_to_js "TrackBefore"
      | TrackAfter -> Ojs.string_to_js "TrackAfter"
    ;;
  end

  module Cursor_association = struct
    type t =
      | Left
      | None
      | Right

    let rec t_of_js : Ojs.t -> t =
      fun (x161 : Ojs.t) ->
      let x162 = x161 in
      match Ojs.int_of_js x162 with
      | -1 -> Left
      | 0 -> None
      | 1 -> Right
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x160 : t) ->
      match x160 with
      | Left -> Ojs.int_to_js (-1)
      | None -> Ojs.int_to_js 0
      | Right -> Ojs.int_to_js 1
    ;;
  end

  module Touches_range = struct
    type t =
      | True
      | False
      | Cover

    let rec t_of_js : Ojs.t -> t =
      fun (x164 : Ojs.t) ->
      let x165 = x164 in
      match Ojs.type_of x165 with
      | "string" ->
        (match Ojs.string_of_js x165 with
         | "cover" -> Cover
         | _ -> assert false)
      | "boolean" ->
        (match Ojs.bool_of_js x165 with
         | true -> True
         | false -> False)
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x163 : t) ->
      match x163 with
      | True -> Ojs.bool_to_js true
      | False -> Ojs.bool_to_js false
      | Cover -> Ojs.string_to_js "cover"
    ;;
  end

  module Change_desc = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x167 : Ojs.t) -> x167
    and t_to_js : t -> Ojs.t = fun (x166 : Ojs.t) -> x166

    let length : t -> int =
      fun (x168 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x168) "length")
    ;;

    let new_length : t -> int =
      fun (x169 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x169) "newLength")
    ;;

    let empty : t -> bool =
      fun (x170 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x170) "empty")
    ;;

    let iter_gaps : t -> f:(a:int -> b:int -> length:int -> unit) -> unit =
      fun (x175 : t) ~f:(x171 : a:int -> b:int -> length:int -> unit) ->
      (ignore : _)
        (Ojs.call
           (t_to_js x175)
           "iterGaps"
           [| Ojs.fun_to_js 3 (fun (x172 : Ojs.t) (x173 : Ojs.t) (x174 : Ojs.t) ->
                x171
                  ~a:(Ojs.int_of_js x172)
                  ~b:(Ojs.int_of_js x173)
                  ~length:(Ojs.int_of_js x174))
           |])
    ;;

    let iter_changed_ranges
      : t -> f:(from_a:int -> to_a:int -> from_b:int -> to_b:int -> unit) -> unit
      =
      fun (x181 : t) ~f:(x176 : from_a:int -> to_a:int -> from_b:int -> to_b:int -> unit) ->
      (ignore : _)
        (Ojs.call
           (t_to_js x181)
           "iterChangedRanges"
           [| Ojs.fun_to_js
                4
                (fun (x177 : Ojs.t) (x178 : Ojs.t) (x179 : Ojs.t) (x180 : Ojs.t) ->
                   x176
                     ~from_a:(Ojs.int_of_js x177)
                     ~to_a:(Ojs.int_of_js x178)
                     ~from_b:(Ojs.int_of_js x179)
                     ~to_b:(Ojs.int_of_js x180))
           |])
    ;;

    let inverted_desc : t -> t =
      fun (x182 : t) -> t_of_js (Ojs.get_prop_ascii (t_to_js x182) "invertedDesc")
    ;;

    let compose_desc : t -> t -> t =
      fun (x184 : t) (x183 : t) ->
      t_of_js (Ojs.call (t_to_js x184) "composeDesc" [| t_to_js x183 |])
    ;;

    let map_desc : t -> t -> ?before:bool -> unit -> t =
      fun (x189 : t) (x185 : t) ?before:(x186 : bool option) () ->
      t_of_js
        (let x190 = t_to_js x189 in
         Ojs.call
           (Ojs.get_prop_ascii x190 "mapDesc")
           "apply"
           [| x190
            ; (let x187 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x187 "push" [| t_to_js x185 |]);
               (match x186 with
                | Some x188 ->
                  (ignore : _) (Ojs.call x187 "push" [| Ojs.bool_to_js x188 |])
                | None -> ());
               x187)
           |])
    ;;

    let map_pos : t -> int -> assoc:Cursor_association.t -> mode:Map_mode.t -> int option =
      fun (x194 : t)
        (x191 : int)
        ~assoc:(x192 : Cursor_association.t)
        ~mode:(x193 : Map_mode.t) ->
      Ojs.option_of_js
        Ojs.int_of_js
        (Ojs.call
           (t_to_js x194)
           "mapPos"
           [| Ojs.int_to_js x191
            ; Cursor_association.t_to_js x192
            ; Map_mode.t_to_js x193
           |])
    ;;

    let touches_range : t -> from:int -> ?to_:int -> unit -> Touches_range.t =
      fun (x200 : t) ~from:(x196 : int) ?to_:(x197 : int option) () ->
      Touches_range.t_of_js
        (let x201 = t_to_js x200 in
         Ojs.call
           (Ojs.get_prop_ascii x201 "touchesRange")
           "apply"
           [| x201
            ; (let x198 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x198 "push" [| Ojs.int_to_js x196 |]);
               (match x197 with
                | Some x199 ->
                  (ignore : _) (Ojs.call x198 "push" [| Ojs.int_to_js x199 |])
                | None -> ());
               x198)
           |])
    ;;
  end

  module Selection_range = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x203 : Ojs.t) -> x203
    and t_to_js : t -> Ojs.t = fun (x202 : Ojs.t) -> x202

    let from : t -> int =
      fun (x204 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x204) "from")
    ;;

    let to_ : t -> int =
      fun (x205 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x205) "to")
    ;;

    let anchor : t -> int =
      fun (x206 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x206) "anchor")
    ;;

    let head : t -> int =
      fun (x207 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x207) "head")
    ;;

    let empty : t -> bool =
      fun (x208 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x208) "empty")
    ;;

    let assoc : t -> Cursor_association.t =
      fun (x209 : t) ->
      Cursor_association.t_of_js (Ojs.get_prop_ascii (t_to_js x209) "assoc")
    ;;

    let bidi_level : t -> int option =
      fun (x210 : t) ->
      Ojs.option_of_js Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x210) "bidiLevel")
    ;;

    let goal_column : t -> int option =
      fun (x212 : t) ->
      Ojs.option_of_js Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x212) "goalColumn")
    ;;

    let map : t -> Change_desc.t -> ?assoc:Cursor_association.t -> unit -> t =
      fun (x218 : t) (x214 : Change_desc.t) ?assoc:(x215 : Cursor_association.t option) () ->
      t_of_js
        (let x219 = t_to_js x218 in
         Ojs.call
           (Ojs.get_prop_ascii x219 "map")
           "apply"
           [| x219
            ; (let x216 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x216 "push" [| Change_desc.t_to_js x214 |]);
               (match x215 with
                | Some x217 ->
                  (ignore : _)
                    (Ojs.call x216 "push" [| Cursor_association.t_to_js x217 |])
                | None -> ());
               x216)
           |])
    ;;

    let extend : t -> from:int -> ?to_:int -> unit -> t =
      fun (x224 : t) ~from:(x220 : int) ?to_:(x221 : int option) () ->
      t_of_js
        (let x225 = t_to_js x224 in
         Ojs.call
           (Ojs.get_prop_ascii x225 "extend")
           "apply"
           [| x225
            ; (let x222 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x222 "push" [| Ojs.int_to_js x220 |]);
               (match x221 with
                | Some x223 ->
                  (ignore : _) (Ojs.call x222 "push" [| Ojs.int_to_js x223 |])
                | None -> ());
               x222)
           |])
    ;;

    let equal : t -> t -> bool =
      fun (x227 : t) (x226 : t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x227) "eq" [| t_to_js x226 |])
    ;;

    let to_json : t -> Ojs.t = fun (x228 : t) -> Ojs.call (t_to_js x228) "toJSON" [||]

    let from_json : Ojs.t -> t =
      fun (x229 : Ojs.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "SelectionRange")
           "fromJSON"
           [| x229 |])
    ;;
  end

  module Editor_selection = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x231 : Ojs.t) -> x231
    and t_to_js : t -> Ojs.t = fun (x230 : Ojs.t) -> x230

    let ranges : t -> Selection_range.t list =
      fun (x232 : t) ->
      Ojs.list_of_js Selection_range.t_of_js (Ojs.get_prop_ascii (t_to_js x232) "ranges")
    ;;

    let main_index : t -> int =
      fun (x234 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x234) "mainIndex")
    ;;

    let main : t -> Selection_range.t =
      fun (x235 : t) -> Selection_range.t_of_js (Ojs.get_prop_ascii (t_to_js x235) "main")
    ;;

    let map : t -> Change_desc.t -> ?assoc:Cursor_association.t -> unit -> t =
      fun (x240 : t) (x236 : Change_desc.t) ?assoc:(x237 : Cursor_association.t option) () ->
      t_of_js
        (let x241 = t_to_js x240 in
         Ojs.call
           (Ojs.get_prop_ascii x241 "map")
           "apply"
           [| x241
            ; (let x238 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x238 "push" [| Change_desc.t_to_js x236 |]);
               (match x237 with
                | Some x239 ->
                  (ignore : _)
                    (Ojs.call x238 "push" [| Cursor_association.t_to_js x239 |])
                | None -> ());
               x238)
           |])
    ;;

    let equal : t -> t -> bool =
      fun (x243 : t) (x242 : t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x243) "eq" [| t_to_js x242 |])
    ;;

    let as_single : t -> t =
      fun (x244 : t) -> t_of_js (Ojs.call (t_to_js x244) "asSingle" [||])
    ;;

    let add_range : t -> Selection_range.t -> ?main:bool -> unit -> t =
      fun (x249 : t) (x245 : Selection_range.t) ?main:(x246 : bool option) () ->
      t_of_js
        (let x250 = t_to_js x249 in
         Ojs.call
           (Ojs.get_prop_ascii x250 "addRange")
           "apply"
           [| x250
            ; (let x247 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x247 "push" [| Selection_range.t_to_js x245 |]);
               (match x246 with
                | Some x248 ->
                  (ignore : _) (Ojs.call x247 "push" [| Ojs.bool_to_js x248 |])
                | None -> ());
               x247)
           |])
    ;;

    let replace_range : Selection_range.t -> ?which:int -> unit -> t =
      fun (x254 : Selection_range.t) ?which:(x251 : int option) () ->
      t_of_js
        (let x255 = Selection_range.t_to_js x254 in
         Ojs.call
           (Ojs.get_prop_ascii x255 "replaceRange")
           "apply"
           [| x255
            ; (let x252 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x251 with
                | Some x253 ->
                  (ignore : _) (Ojs.call x252 "push" [| Ojs.int_to_js x253 |])
                | None -> ());
               x252)
           |])
    ;;

    let to_json : t -> Ojs.t = fun (x256 : t) -> Ojs.call (t_to_js x256) "toJSON" [||]

    let from_json : Ojs.t -> t =
      fun (x257 : Ojs.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorSelection")
           "fromJSON"
           [| x257 |])
    ;;

    let single : anchor:int -> ?head:int -> unit -> t =
      fun ~anchor:(x258 : int) ?head:(x259 : int option) () ->
      t_of_js
        (let x262 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x262 "single")
           "apply"
           [| x262
            ; (let x260 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x260 "push" [| Ojs.int_to_js x258 |]);
               (match x259 with
                | Some x261 ->
                  (ignore : _) (Ojs.call x260 "push" [| Ojs.int_to_js x261 |])
                | None -> ());
               x260)
           |])
    ;;

    let create : ranges:Selection_range.t list -> ?main_index:int -> unit -> t =
      fun ~ranges:(x263 : Selection_range.t list) ?main_index:(x264 : int option) () ->
      t_of_js
        (let x268 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x268 "create")
           "apply"
           [| x268
            ; (let x265 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _)
                 (Ojs.call x265 "push" [| Ojs.list_to_js Selection_range.t_to_js x263 |]);
               (match x264 with
                | Some x266 ->
                  (ignore : _) (Ojs.call x265 "push" [| Ojs.int_to_js x266 |])
                | None -> ());
               x265)
           |])
    ;;

    let cursor
      :  pos:int -> ?assoc:Cursor_association.t -> ?bidi_level:int -> ?goal_column:int
      -> unit -> Selection_range.t
      =
      fun ~pos:(x269 : int)
        ?assoc:(x270 : Cursor_association.t option)
        ?bidi_level:(x271 : int option)
        ?goal_column:(x272 : int option)
        () ->
      Selection_range.t_of_js
        (let x277 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x277 "cursor")
           "apply"
           [| x277
            ; (let x273 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x273 "push" [| Ojs.int_to_js x269 |]);
               (match x270 with
                | Some x276 ->
                  (ignore : _)
                    (Ojs.call x273 "push" [| Cursor_association.t_to_js x276 |])
                | None -> ());
               (match x271 with
                | Some x275 ->
                  (ignore : _) (Ojs.call x273 "push" [| Ojs.int_to_js x275 |])
                | None -> ());
               (match x272 with
                | Some x274 ->
                  (ignore : _) (Ojs.call x273 "push" [| Ojs.int_to_js x274 |])
                | None -> ());
               x273)
           |])
    ;;

    let range : anchor:int -> head:int -> ?goal_column:int -> unit -> Selection_range.t =
      fun ~anchor:(x278 : int) ~head:(x279 : int) ?goal_column:(x280 : int option) () ->
      Selection_range.t_of_js
        (let x283 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorSelection"
         in
         Ojs.call
           (Ojs.get_prop_ascii x283 "range")
           "apply"
           [| x283
            ; (let x281 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x281 "push" [| Ojs.int_to_js x278 |]);
               (ignore : _) (Ojs.call x281 "push" [| Ojs.int_to_js x279 |]);
               (match x280 with
                | Some x282 ->
                  (ignore : _) (Ojs.call x281 "push" [| Ojs.int_to_js x282 |])
                | None -> ());
               x281)
           |])
    ;;
  end

  module Change_set = struct
    type t = change_set

    let rec t_of_js : Ojs.t -> t = fun (x285 : Ojs.t) -> change_set_of_js x285
    and t_to_js : t -> Ojs.t = fun (x284 : change_set) -> change_set_to_js x284

    let iter_changes
      :  t
      -> f:
           (from_a:int
            -> to_a:int
            -> from_b:int
            -> to_b:int
            -> inserted:Text.Text.t
            -> unit)
      -> unit
      =
      fun (x292 : t)
        ~f:
          (x286 :
            from_a:int
            -> to_a:int
            -> from_b:int
            -> to_b:int
            -> inserted:Text.Text.t
            -> unit) ->
      (ignore : _)
        (Ojs.call
           (t_to_js x292)
           "iterChanges"
           [| Ojs.fun_to_js
                5
                (fun
                    (x287 : Ojs.t)
                    (x288 : Ojs.t)
                    (x289 : Ojs.t)
                    (x290 : Ojs.t)
                    (x291 : Ojs.t)
                  ->
                   x286
                     ~from_a:(Ojs.int_of_js x287)
                     ~to_a:(Ojs.int_of_js x288)
                     ~from_b:(Ojs.int_of_js x289)
                     ~to_b:(Ojs.int_of_js x290)
                     ~inserted:(Text.Text.t_of_js x291))
           |])
    ;;

    let desc : t -> Change_desc.t =
      fun (x293 : t) -> Change_desc.t_of_js (Ojs.get_prop_ascii (t_to_js x293) "desc")
    ;;
  end

  type editor_state = Ojs.t

  let rec editor_state_of_js : Ojs.t -> editor_state = fun (x295 : Ojs.t) -> x295
  and editor_state_to_js : editor_state -> Ojs.t = fun (x294 : Ojs.t) -> x294

  module Annotation_type = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x297 : Ojs.t) -> x297
    and t_to_js : t -> Ojs.t = fun (x296 : Ojs.t) -> x296
  end

  module Transaction = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x299 : Ojs.t) -> x299
    and t_to_js : t -> Ojs.t = fun (x298 : Ojs.t) -> x298

    let start_state : t -> editor_state =
      fun (x300 : t) ->
      editor_state_of_js (Ojs.get_prop_ascii (t_to_js x300) "startState")
    ;;

    let changes : t -> Change_set.t =
      fun (x301 : t) -> Change_set.t_of_js (Ojs.get_prop_ascii (t_to_js x301) "changes")
    ;;

    let selection : t -> Editor_selection.t option =
      fun (x302 : t) ->
      Ojs.option_of_js
        Editor_selection.t_of_js
        (Ojs.get_prop_ascii (t_to_js x302) "selection")
    ;;

    let effects : t -> State_effect.t list =
      fun (x304 : t) ->
      Ojs.list_of_js State_effect.t_of_js (Ojs.get_prop_ascii (t_to_js x304) "effects")
    ;;

    let scroll_into_view : t -> bool =
      fun (x306 : t) ->
      Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x306) "scrollIntoView")
    ;;

    let new_doc : t -> Text.Text.t =
      fun (x307 : t) -> Text.Text.t_of_js (Ojs.get_prop_ascii (t_to_js x307) "newDoc")
    ;;

    let new_selection : t -> Editor_selection.t =
      fun (x308 : t) ->
      Editor_selection.t_of_js (Ojs.get_prop_ascii (t_to_js x308) "newSelection")
    ;;

    let state : t -> editor_state =
      fun (x309 : t) -> editor_state_of_js (Ojs.get_prop_ascii (t_to_js x309) "state")
    ;;

    let doc_changed : t -> bool =
      fun (x310 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x310) "docChanged")
    ;;

    let reconfigured : t -> bool =
      fun (x311 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x311) "reconfigured")
    ;;

    let is_user_event : t -> string -> bool =
      fun (x313 : t) (x312 : string) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x313) "isUserEvent" [| Ojs.string_to_js x312 |])
    ;;

    let time : Annotation_type.t =
      Annotation_type.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Transaction")
           "time")
    ;;

    let user_event : Annotation_type.t =
      Annotation_type.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Transaction")
           "userEvent")
    ;;

    let add_to_history : Annotation_type.t =
      Annotation_type.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Transaction")
           "addToHistory")
    ;;
  end

  module State_field_config = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x315 : Ojs.t) -> x315

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x314 : Ojs.t) -> x314
    ;;

    let create
      :  create:(editor_state -> 'v) -> update:('v -> Transaction.t -> 'v)
      -> compare:('v -> 'v -> bool) option -> 'v t
      =
      fun ~create:(x316 : editor_state -> 'v)
        ~update:(x317 : 'v -> Transaction.t -> 'v)
        ~compare:(x318 : ('v -> 'v -> bool) option) ->
      let x319 = Ojs.empty_obj () in
      Ojs.set_prop_ascii
        x319
        "create"
        (Ojs.fun_to_js 1 (fun (x326 : Ojs.t) ->
           Obj.magic (x316 (editor_state_of_js x326))));
      Ojs.set_prop_ascii
        x319
        "update"
        (Ojs.fun_to_js 2 (fun (x324 : Ojs.t) (x325 : Ojs.t) ->
           Obj.magic (x317 (Obj.magic x324) (Transaction.t_of_js x325))));
      Ojs.set_prop_ascii
        x319
        "compare"
        (Ojs.option_to_js
           (fun (x321 : 'v -> 'v -> bool) ->
             Ojs.fun_to_js 2 (fun (x322 : Ojs.t) (x323 : Ojs.t) ->
               Ojs.bool_to_js (x321 (Obj.magic x322) (Obj.magic x323))))
           x318);
      t_of_js Obj.magic x319
    ;;
  end

  module State_field = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x328 : Ojs.t) -> x328

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x327 : Ojs.t) -> x327
    ;;

    let extension : 'v t -> Extension.t =
      fun (x329 : 'v t) ->
      Extension.t_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x329) "extension")
    ;;

    let init : 'v t -> create:(editor_state -> 'v) -> Extension.t =
      fun (x333 : 'v t) ~create:(x331 : editor_state -> 'v) ->
      Extension.t_of_js
        (Ojs.call
           (t_to_js Obj.magic x333)
           "init"
           [| Ojs.fun_to_js 1 (fun (x332 : Ojs.t) ->
                Obj.magic (x331 (editor_state_of_js x332)))
           |])
    ;;

    let define : config:'v State_field_config.t -> 'v t =
      fun ~config:(x335 : 'v State_field_config.t) ->
      t_of_js
        Obj.magic
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "StateField")
           "define"
           [| State_field_config.t_to_js Obj.magic x335 |])
    ;;
  end

  module Facet = struct
    type ('i, 'o) t = Ojs.t

    let rec t_of_js : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) t =
      fun (type __i __o)
        (__i_of_js : Ojs.t -> __i)
        (__o_of_js : Ojs.t -> __o)
        (x339 : Ojs.t) ->
      x339

    and t_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) t -> Ojs.t =
      fun (type __i __o)
        (__i_to_js : __i -> Ojs.t)
        (__o_to_js : __o -> Ojs.t)
        (x338 : Ojs.t) ->
      x338
    ;;

    type 'i multi_out = ('i, 'i list) t

    let rec multi_out_of_js : 'i. (Ojs.t -> 'i) -> Ojs.t -> 'i multi_out =
      fun (type __i) (__i_of_js : Ojs.t -> __i) (x344 : Ojs.t) ->
      t_of_js __i_of_js (fun (x346 : Ojs.t) -> Ojs.list_of_js __i_of_js x346) x344

    and multi_out_to_js : 'i. ('i -> Ojs.t) -> 'i multi_out -> Ojs.t =
      fun (type __i) (__i_to_js : __i -> Ojs.t) (x340 : (__i, __i list) t) ->
      t_to_js __i_to_js (fun (x342 : __i list) -> Ojs.list_to_js __i_to_js x342) x340
    ;;

    let of_ : ('i, 'o) t -> 'i With_conversion.t -> Extension.t =
      fun (x350 : ('i, 'o) t) (x348 : 'i With_conversion.t) ->
      Extension.t_of_js
        (Ojs.call
           (t_to_js Obj.magic Obj.magic x350)
           "of"
           [| With_conversion.t_to_js Obj.magic x348 |])
    ;;

    module Dep = struct
      type ('i, 'o) facet = ('i, 'o) t

      let rec facet_of_js
        : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) facet
        =
        fun (type __i __o)
          (__i_of_js : Ojs.t -> __i)
          (__o_of_js : Ojs.t -> __o)
          (x356 : Ojs.t) ->
        t_of_js __i_of_js __o_of_js x356

      and facet_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) facet -> Ojs.t =
        fun (type __i __o)
          (__i_to_js : __i -> Ojs.t)
          (__o_to_js : __o -> Ojs.t)
          (x353 : (__i, __o) t) ->
        t_to_js __i_to_js __o_to_js x353
      ;;

      type t =
        | Doc : t
        | Selection : t
        | Facet : ('i, 'o) facet -> t

      let rec t_of_js : Ojs.t -> t =
        let doc_str = Js.string "doc" in
        let selection_str = Js.string "selection" in
        let ojs_equal (x : Ojs.t) (y : Js.js_string Js.t) =
          Js.strict_equals ((Obj.magic : Ojs.t -> Js.js_string Js.t) x) y
        in
        function
        | x when ojs_equal x doc_str -> Doc
        | x when ojs_equal x selection_str -> Selection
        | _ ->
          Core.raise_s
            [%message
              "[Dep.of_js] is only supported for 'doc' and 'selection'"
                ([%here] : Core.Source_code_position.t)]

      and t_to_js : t -> Ojs.t = function
        | Doc -> Ojs.string_to_js "doc"
        | Selection -> Ojs.string_to_js "selection"
        | Facet facet -> (facet : Ojs.t)
      ;;
    end

    let compute : ('i, 'o) t -> deps:Dep.t list -> get:(editor_state -> 'i) -> Extension.t
      =
      fun (x363 : ('i, 'o) t) ~deps:(x359 : Dep.t list) ~get:(x361 : editor_state -> 'i) ->
      Extension.t_of_js
        (Ojs.call
           (t_to_js Obj.magic Obj.magic x363)
           "compute"
           [| Ojs.list_to_js Dep.t_to_js x359
            ; Ojs.fun_to_js 1 (fun (x362 : Ojs.t) ->
                Obj.magic (x361 (editor_state_of_js x362)))
           |])
    ;;

    let from : ('i, 'o) t -> field:'t State_field.t -> get:(value:'t -> 'i) -> Extension.t
      =
      fun (x370 : ('i, 'o) t)
        ~field:(x366 : 't State_field.t)
        ~get:(x368 : value:'t -> 'i) ->
      Extension.t_of_js
        (Ojs.call
           (t_to_js Obj.magic Obj.magic x370)
           "from"
           [| State_field.t_to_js Obj.magic x366
            ; Ojs.fun_to_js 1 (fun (x369 : Ojs.t) ->
                Obj.magic (x368 ~value:(Obj.magic x369)))
           |])
    ;;

    module Config = struct
      type ('i, 'o) facet = ('i, 'o) t

      let rec facet_of_js
        : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) facet
        =
        fun (type __i __o)
          (__i_of_js : Ojs.t -> __i)
          (__o_of_js : Ojs.t -> __o)
          (x376 : Ojs.t) ->
        t_of_js __i_of_js __o_of_js x376

      and facet_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) facet -> Ojs.t =
        fun (type __i __o)
          (__i_to_js : __i -> Ojs.t)
          (__o_to_js : __o -> Ojs.t)
          (x373 : (__i, __o) t) ->
        t_to_js __i_to_js __o_to_js x373
      ;;

      type ('i, 'o) t = Ojs.t

      let rec t_of_js : 'i 'o. (Ojs.t -> 'i) -> (Ojs.t -> 'o) -> Ojs.t -> ('i, 'o) t =
        fun (type __i __o)
          (__i_of_js : Ojs.t -> __i)
          (__o_of_js : Ojs.t -> __o)
          (x380 : Ojs.t) ->
        x380

      and t_to_js : 'i 'o. ('i -> Ojs.t) -> ('o -> Ojs.t) -> ('i, 'o) t -> Ojs.t =
        fun (type __i __o)
          (__i_to_js : __i -> Ojs.t)
          (__o_to_js : __o -> Ojs.t)
          (x379 : Ojs.t) ->
        x379
      ;;

      let create
        :  combine:('i list -> 'o) -> ?compare:('o -> 'o -> bool)
        -> ?compareInput:('i -> 'i -> bool) -> ?static:bool
        -> ?enables:(('i, 'o) facet -> Extension.t) -> unit -> ('i, 'o) t
        =
        fun ~combine:(x381 : 'i list -> 'o)
          ?compare:(x382 : ('o -> 'o -> bool) option)
          ?compareInput:(x383 : ('i -> 'i -> bool) option)
          ?static:(x384 : bool option)
          ?enables:(x385 : (('i, 'o) facet -> Extension.t) option)
          () ->
        let x386 = Ojs.empty_obj () in
        Ojs.set_prop_ascii
          x386
          "combine"
          (Ojs.fun_to_js 1 (fun (x400 : Ojs.t) ->
             Obj.magic (x381 (Ojs.list_of_js Obj.magic x400))));
        (match x382 with
         | Some x397 ->
           Ojs.set_prop_ascii
             x386
             "compare"
             (Ojs.fun_to_js 2 (fun (x398 : Ojs.t) (x399 : Ojs.t) ->
                Ojs.bool_to_js (x397 (Obj.magic x398) (Obj.magic x399))))
         | None -> ());
        (match x383 with
         | Some x394 ->
           Ojs.set_prop_ascii
             x386
             "compareInput"
             (Ojs.fun_to_js 2 (fun (x395 : Ojs.t) (x396 : Ojs.t) ->
                Ojs.bool_to_js (x394 (Obj.magic x395) (Obj.magic x396))))
         | None -> ());
        (match x384 with
         | Some x393 -> Ojs.set_prop_ascii x386 "static" (Ojs.bool_to_js x393)
         | None -> ());
        (match x385 with
         | Some x389 ->
           Ojs.set_prop_ascii
             x386
             "enables"
             (Ojs.fun_to_js 1 (fun (x390 : Ojs.t) ->
                Extension.t_to_js (x389 (facet_of_js Obj.magic Obj.magic x390))))
         | None -> ());
        t_of_js Obj.magic Obj.magic x386
      ;;
    end

    let define : ('i, 'o) Config.t -> ('i, 'o) t =
      fun (x402 : ('i, 'o) Config.t) ->
      t_of_js
        Obj.magic
        Obj.magic
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Facet")
           "define"
           [| Config.t_to_js Obj.magic Obj.magic x402 |])
    ;;
  end

  module Char_category = struct
    type t =
      | Word
      | Space
      | Other

    let rec t_of_js : Ojs.t -> t =
      fun (x408 : Ojs.t) ->
      let x409 = x408 in
      match Ojs.string_of_js x409 with
      | "Word" -> Word
      | "Space" -> Space
      | "Other" -> Other
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x407 : t) ->
      match x407 with
      | Word -> Ojs.string_to_js "Word"
      | Space -> Ojs.string_to_js "Space"
      | Other -> Ojs.string_to_js "Other"
    ;;
  end

  module Change_filter_result = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x411 : Ojs.t) -> x411
    and t_to_js : t -> Ojs.t = fun (x410 : Ojs.t) -> x410

    let bool : bool -> t = fun (x412 : bool) -> t_of_js (Ojs.bool_to_js x412)

    let ranges : int list -> t =
      fun (x413 : int list) -> t_of_js (Ojs.list_to_js Ojs.int_to_js x413)
    ;;
  end

  module Transaction_spec = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x416 : Ojs.t) -> x416
    and t_to_js : t -> Ojs.t = fun (x415 : Ojs.t) -> x415

    let create
      :  ?changes:Change_spec.t -> ?selection:Editor_selection.t
      -> ?effects:State_effect.t list -> ?annotations:Annotation.t list
      -> ?scroll_into_view:bool -> ?filter:bool -> ?sequential:bool -> unit -> t
      =
      fun ?changes:(x417 : Change_spec.t option)
        ?selection:(x418 : Editor_selection.t option)
        ?effects:(x419 : State_effect.t list option)
        ?annotations:(x420 : Annotation.t list option)
        ?scroll_into_view:(x421 : bool option)
        ?filter:(x422 : bool option)
        ?sequential:(x423 : bool option)
        () ->
      let x424 = Ojs.empty_obj () in
      (match x417 with
       | Some x433 -> Ojs.set_prop_ascii x424 "changes" (Change_spec.t_to_js x433)
       | None -> ());
      (match x418 with
       | Some x432 -> Ojs.set_prop_ascii x424 "selection" (Editor_selection.t_to_js x432)
       | None -> ());
      (match x419 with
       | Some x430 ->
         Ojs.set_prop_ascii x424 "effects" (Ojs.list_to_js State_effect.t_to_js x430)
       | None -> ());
      (match x420 with
       | Some x428 ->
         Ojs.set_prop_ascii x424 "annotations" (Ojs.list_to_js Annotation.t_to_js x428)
       | None -> ());
      (match x421 with
       | Some x427 -> Ojs.set_prop_ascii x424 "scrollIntoView" (Ojs.bool_to_js x427)
       | None -> ());
      (match x422 with
       | Some x426 -> Ojs.set_prop_ascii x424 "filter" (Ojs.bool_to_js x426)
       | None -> ());
      (match x423 with
       | Some x425 -> Ojs.set_prop_ascii x424 "sequential" (Ojs.bool_to_js x425)
       | None -> ());
      t_of_js x424
    ;;
  end

  module Compartment = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x435 : Ojs.t) -> x435
    and t_to_js : t -> Ojs.t = fun (x434 : Ojs.t) -> x434

    let create : unit -> t =
      fun () ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Compartment")
           [||])
    ;;

    let of_ : t -> Extension.t -> Extension.t =
      fun (x437 : t) (x436 : Extension.t) ->
      Extension.t_of_js (Ojs.call (t_to_js x437) "of" [| Extension.t_to_js x436 |])
    ;;

    let reconfigure : t -> Extension.t -> state_effect =
      fun (x439 : t) (x438 : Extension.t) ->
      state_effect_of_js
        (Ojs.call (t_to_js x439) "reconfigure" [| Extension.t_to_js x438 |])
    ;;

    let get : t -> editor_state -> Extension.t option =
      fun (x441 : t) (x440 : editor_state) ->
      Ojs.option_of_js
        Extension.t_of_js
        (Ojs.call (t_to_js x441) "get" [| editor_state_to_js x440 |])
    ;;
  end

  module Editor_state = struct
    type t = editor_state

    let rec t_of_js : Ojs.t -> t = fun (x444 : Ojs.t) -> editor_state_of_js x444
    and t_to_js : t -> Ojs.t = fun (x443 : editor_state) -> editor_state_to_js x443

    let doc : t -> Text.Text.t =
      fun (x445 : t) -> Text.Text.t_of_js (Ojs.get_prop_ascii (t_to_js x445) "doc")
    ;;

    let selection : t -> Editor_selection.t =
      fun (x446 : t) ->
      Editor_selection.t_of_js (Ojs.get_prop_ascii (t_to_js x446) "selection")
    ;;

    let field : t -> 'a State_field.t -> 'a option =
      fun (x449 : t) (x447 : 'a State_field.t) ->
      Ojs.option_of_js
        Obj.magic
        (Ojs.call (t_to_js x449) "field" [| State_field.t_to_js Obj.magic x447 |])
    ;;

    let update : t -> Transaction_spec.t list -> Transaction.t =
      fun (x454 : t) (x451 : Transaction_spec.t list) ->
      Transaction.t_of_js
        (let x455 = t_to_js x454 in
         Ojs.call
           (Ojs.get_prop_ascii x455 "update")
           "apply"
           [| x455
            ; (let x452 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               List.iter
                 (fun (x453 : Transaction_spec.t) ->
                   (ignore : _) (Ojs.call x452 "push" [| Transaction_spec.t_to_js x453 |]))
                 x451;
               x452)
           |])
    ;;

    let replace_selection : t -> Text.Text.t -> Transaction_spec.t =
      fun (x457 : t) (x456 : Text.Text.t) ->
      Transaction_spec.t_of_js
        (Ojs.call (t_to_js x457) "replaceSelection" [| Text.Text.t_to_js x456 |])
    ;;

    let change_by_range
      : t -> f:(Selection_range.t -> Transaction_spec.t) -> Transaction_spec.t
      =
      fun (x460 : t) ~f:(x458 : Selection_range.t -> Transaction_spec.t) ->
      Transaction_spec.t_of_js
        (Ojs.call
           (t_to_js x460)
           "changeByRange"
           [| Ojs.fun_to_js 1 (fun (x459 : Ojs.t) ->
                Transaction_spec.t_to_js (x458 (Selection_range.t_of_js x459)))
           |])
    ;;

    let changes : t -> Change_spec.t -> Change_set.t =
      fun (x462 : t) (x461 : Change_spec.t) ->
      Change_set.t_of_js
        (Ojs.call (t_to_js x462) "changes" [| Change_spec.t_to_js x461 |])
    ;;

    let to_text : t -> string -> Text.Text.t =
      fun (x464 : t) (x463 : string) ->
      Text.Text.t_of_js (Ojs.call (t_to_js x464) "toText" [| Ojs.string_to_js x463 |])
    ;;

    let slice_doc : t -> ?from:int -> ?to_:int -> unit -> string =
      fun (x470 : t) ?from:(x465 : int option) ?to_:(x466 : int option) () ->
      Ojs.string_of_js
        (let x471 = t_to_js x470 in
         Ojs.call
           (Ojs.get_prop_ascii x471 "sliceDoc")
           "apply"
           [| x471
            ; (let x467 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (match x465 with
                | Some x469 ->
                  (ignore : _) (Ojs.call x467 "push" [| Ojs.int_to_js x469 |])
                | None -> ());
               (match x466 with
                | Some x468 ->
                  (ignore : _) (Ojs.call x467 "push" [| Ojs.int_to_js x468 |])
                | None -> ());
               x467)
           |])
    ;;

    let word_at : t -> pos:int -> Selection_range.t option =
      fun (x473 : t) ~pos:(x472 : int) ->
      Ojs.option_of_js
        Selection_range.t_of_js
        (Ojs.call (t_to_js x473) "wordAt" [| Ojs.int_to_js x472 |])
    ;;

    let facet : t -> ('i, 'o) Facet.t -> 'o =
      fun (x478 : t) (x475 : ('i, 'o) Facet.t) ->
      Obj.magic
        (Ojs.call (t_to_js x478) "facet" [| Facet.t_to_js Obj.magic Obj.magic x475 |])
    ;;

    let to_json : t -> Ojs.t = fun (x479 : t) -> Ojs.call (t_to_js x479) "toJSON" [||]

    let get_tab_size : t -> int =
      fun (x480 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x480) "tabSize")
    ;;

    let line_break : t -> string =
      fun (x481 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x481) "lineBreak")
    ;;

    let phrase : t -> string -> string =
      fun (x483 : t) (x482 : string) ->
      Ojs.string_of_js (Ojs.call (t_to_js x483) "phrase" [| Ojs.string_to_js x482 |])
    ;;

    let language_data_at : t -> name:string -> pos:int -> Ojs.t list =
      fun (x486 : t) ~name:(x484 : string) ~pos:(x485 : int) ->
      Ojs.list_of_js
        (fun (x487 : Ojs.t) -> x487)
        (Ojs.call
           (t_to_js x486)
           "languageDataAt"
           [| Ojs.string_to_js x484; Ojs.int_to_js x485 |])
    ;;

    let char_categorizer : t -> int -> string -> Char_category.t =
      fun (x490 : t) (x488 : int) (x489 : string) ->
      Char_category.t_of_js
        (Ojs.call
           (t_to_js x490)
           "charCategorizer"
           [| Ojs.int_to_js x488; Ojs.string_to_js x489 |])
    ;;

    let from_json
      : json:Ojs.t -> ?config:Editor_state_config.t -> ?fields:Ojs.t -> unit -> t
      =
      fun ~json:(x491 : Ojs.t)
        ?config:(x492 : Editor_state_config.t option)
        ?fields:(x493 : Ojs.t option)
        () ->
      t_of_js
        (let x497 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
             "EditorState"
         in
         Ojs.call
           (Ojs.get_prop_ascii x497 "fromJSON")
           "apply"
           [| x497
            ; (let x494 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x494 "push" [| x491 |]);
               (match x492 with
                | Some x496 ->
                  (ignore : _)
                    (Ojs.call x494 "push" [| Editor_state_config.t_to_js x496 |])
                | None -> ());
               (match x493 with
                | Some x495 -> (ignore : _) (Ojs.call x494 "push" [| x495 |])
                | None -> ());
               x494)
           |])
    ;;

    let create : Editor_state_config.t -> t =
      fun (x498 : Editor_state_config.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "create"
           [| Editor_state_config.t_to_js x498 |])
    ;;

    let allow_multiple_selections : (bool, bool) Facet.t =
      Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "allowMultipleSelections")
    ;;

    let tab_size : (int, int) Facet.t =
      Facet.t_of_js
        Ojs.int_of_js
        Ojs.int_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "tabSize")
    ;;

    let read_only : (bool, bool) Facet.t =
      Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "readOnly")
    ;;

    let line_separator : (string, string option) Facet.t =
      Facet.t_of_js
        Ojs.string_of_js
        (fun (x506 : Ojs.t) -> Ojs.option_of_js Ojs.string_of_js x506)
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "lineSeparator")
    ;;

    let phrases : Ojs.t Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x508 : Ojs.t) -> x508)
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "phrases")
    ;;

    let language_data : (t -> int -> Ojs.t list) Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x509 : Ojs.t) (x510 : t) (x511 : int) ->
          Ojs.list_of_js
            (fun (x512 : Ojs.t) -> x512)
            (Ojs.apply x509 [| t_to_js x510; Ojs.int_to_js x511 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "languageData")
    ;;

    let change_filter : (Transaction.t -> Change_filter_result.t) Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x513 : Ojs.t) (x514 : Transaction.t) ->
          Change_filter_result.t_of_js (Ojs.apply x513 [| Transaction.t_to_js x514 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "changeFilter")
    ;;

    let transaction_filter : (Transaction.t -> Transaction_spec.t list) Facet.multi_out =
      Facet.multi_out_of_js
        (fun (x515 : Ojs.t) (x516 : Transaction.t) ->
          Ojs.list_of_js
            Transaction_spec.t_of_js
            (Ojs.apply x515 [| Transaction.t_to_js x516 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "transactionFilter")
    ;;

    let transaction_extender : (Transaction.t -> Effects_and_annotation.t) Facet.multi_out
      =
      Facet.multi_out_of_js
        (fun (x518 : Ojs.t) (x519 : Transaction.t) ->
          Effects_and_annotation.t_of_js (Ojs.apply x518 [| Transaction.t_to_js x519 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "EditorState")
           "transactionExtender")
    ;;
  end

  module Range = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x521 : Ojs.t) -> x521

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x520 : Ojs.t) -> x520
    ;;

    let from : 'v t -> int =
      fun (x522 : 'v t) ->
      Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x522) "from")
    ;;

    let to_ : 'v t -> int =
      fun (x524 : 'v t) ->
      Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x524) "to")
    ;;
  end

  module Range_set_update_spec = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x527 : Ojs.t) -> x527

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x526 : Ojs.t) -> x526
    ;;

    let create
      :  add:'v Range.t list -> sort:bool
      -> filter:(from:int -> to_:int -> value:'v -> bool) option -> filter_from:int option
      -> filter_to:int option -> 'v t
      =
      fun ~add:(x528 : 'v Range.t list)
        ~sort:(x529 : bool)
        ~filter:(x530 : (from:int -> to_:int -> value:'v -> bool) option)
        ~filter_from:(x531 : int option)
        ~filter_to:(x532 : int option) ->
      let x533 = Ojs.empty_obj () in
      Ojs.set_prop_ascii
        x533
        "add"
        (Ojs.list_to_js (fun (x541 : 'v Range.t) -> Range.t_to_js Obj.magic x541) x528);
      Ojs.set_prop_ascii x533 "sort" (Ojs.bool_to_js x529);
      Ojs.set_prop_ascii
        x533
        "filter"
        (Ojs.option_to_js
           (fun (x537 : from:int -> to_:int -> value:'v -> bool) ->
             Ojs.fun_to_js 3 (fun (x538 : Ojs.t) (x539 : Ojs.t) (x540 : Ojs.t) ->
               Ojs.bool_to_js
                 (x537
                    ~from:(Ojs.int_of_js x538)
                    ~to_:(Ojs.int_of_js x539)
                    ~value:(Obj.magic x540))))
           x530);
      Ojs.set_prop_ascii x533 "filterFrom" (Ojs.option_to_js Ojs.int_to_js x531);
      Ojs.set_prop_ascii x533 "filterTo" (Ojs.option_to_js Ojs.int_to_js x532);
      t_of_js Obj.magic x533
    ;;
  end

  module Range_set = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x544 : Ojs.t) -> x544

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x543 : Ojs.t) -> x543
    ;;

    let empty : 'v t =
      t_of_js
        Obj.magic
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "RangeSet")
           "empty")
    ;;

    let size : 'v t -> int =
      fun (x546 : 'v t) ->
      Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x546) "size")
    ;;

    let update : 'v t -> update_spec:'v Range_set_update_spec.t -> 'v t =
      fun (x550 : 'v t) ~update_spec:(x548 : 'v Range_set_update_spec.t) ->
      t_of_js
        Obj.magic
        (Ojs.call
           (t_to_js Obj.magic x550)
           "update"
           [| Range_set_update_spec.t_to_js Obj.magic x548 |])
    ;;

    let between
      :  'v t -> from:int -> to_:int -> f:(from:int -> to_:int -> value:'v -> bool option)
      -> unit
      =
      fun (x560 : 'v t)
        ~from:(x553 : int)
        ~to_:(x554 : int)
        ~f:(x555 : from:int -> to_:int -> value:'v -> bool option) ->
      (ignore : _)
        (Ojs.call
           (t_to_js Obj.magic x560)
           "between"
           [| Ojs.int_to_js x553
            ; Ojs.int_to_js x554
            ; Ojs.fun_to_js 3 (fun (x556 : Ojs.t) (x557 : Ojs.t) (x558 : Ojs.t) ->
                Ojs.option_to_js
                  Ojs.bool_to_js
                  (x555
                     ~from:(Ojs.int_of_js x556)
                     ~to_:(Ojs.int_of_js x557)
                     ~value:(Obj.magic x558)))
           |])
    ;;
  end

  module Prec = struct
    let fallback : Extension.t -> Extension.t =
      fun (x562 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "fallback"
           [| Extension.t_to_js x562 |])
    ;;

    let default : Extension.t -> Extension.t =
      fun (x563 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "default"
           [| Extension.t_to_js x563 |])
    ;;

    let extend : Extension.t -> Extension.t =
      fun (x564 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "extend"
           [| Extension.t_to_js x564 |])
    ;;

    let override : Extension.t -> Extension.t =
      fun (x565 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "override"
           [| Extension.t_to_js x565 |])
    ;;

    let high : Extension.t -> Extension.t =
      fun (x566 : Extension.t) ->
      Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "State")
              "Prec")
           "high"
           [| Extension.t_to_js x566 |])
    ;;
  end
end

module View = struct
  type editor_view = Ojs.t

  let rec editor_view_of_js : Ojs.t -> editor_view = fun (x568 : Ojs.t) -> x568
  and editor_view_to_js : editor_view -> Ojs.t = fun (x567 : Ojs.t) -> x567

  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x570 : Ojs.t) -> x570
    and t_to_js : t -> Ojs.t = fun (x569 : Ojs.t) -> x569

    let create
      :  ?state:State.Editor_state.t
      -> ?dispatch:(State.Transaction.t -> editor_view -> unit) Callback.t
      -> ?scroll_to:State.State_effect.t -> unit -> t
      =
      fun ?state:(x571 : State.Editor_state.t option)
        ?dispatch:(x572 : (State.Transaction.t -> editor_view -> unit) Callback.t option)
        ?scroll_to:(x573 : State.State_effect.t option)
        () ->
      let x574 = Ojs.empty_obj () in
      (match x571 with
       | Some x580 -> Ojs.set_prop_ascii x574 "state" (State.Editor_state.t_to_js x580)
       | None -> ());
      (match x572 with
       | Some x576 ->
         Ojs.set_prop_ascii
           x574
           "dispatch"
           (Callback.t_to_js
              (fun (x577 : State.Transaction.t -> editor_view -> unit) ->
                Ojs.fun_to_js 2 (fun (x578 : Ojs.t) (x579 : Ojs.t) ->
                  x577 (State.Transaction.t_of_js x578) (editor_view_of_js x579)))
              x576)
       | None -> ());
      (match x573 with
       | Some x575 -> Ojs.set_prop_ascii x574 "scrollTo" (State.State_effect.t_to_js x575)
       | None -> ());
      t_of_js x574
    ;;
  end

  module View_update = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x582 : Ojs.t) -> x582
    and t_to_js : t -> Ojs.t = fun (x581 : Ojs.t) -> x581

    let changes : t -> State.Change_set.t =
      fun (x583 : t) ->
      State.Change_set.t_of_js (Ojs.get_prop_ascii (t_to_js x583) "changes")
    ;;

    let transactions : t -> State.Transaction.t list =
      fun (x584 : t) ->
      Ojs.list_of_js
        State.Transaction.t_of_js
        (Ojs.get_prop_ascii (t_to_js x584) "transactions")
    ;;

    let state : t -> State.Editor_state.t =
      fun (x586 : t) ->
      State.Editor_state.t_of_js (Ojs.get_prop_ascii (t_to_js x586) "state")
    ;;

    let view : t -> editor_view =
      fun (x587 : t) -> editor_view_of_js (Ojs.get_prop_ascii (t_to_js x587) "view")
    ;;

    let viewport_changed : t -> bool =
      fun (x588 : t) ->
      Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x588) "viewportChanged")
    ;;

    let doc_changed : t -> bool =
      fun (x589 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x589) "docChanged")
    ;;

    let focus_changed : t -> bool =
      fun (x590 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x590) "focusChanged")
    ;;
  end

  let highlight_special_chars : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "highlightSpecialChars"
         [||])
  ;;

  let highlight_active_line : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "highlightActiveLine"
         [||])
  ;;

  let placeholder : content:string -> State.Extension.t =
    fun ~content:(x591 : string) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "placeholder"
         [| Ojs.string_to_js x591 |])
  ;;

  module Draw_selection_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x593 : Ojs.t) -> x593
    and t_to_js : t -> Ojs.t = fun (x592 : Ojs.t) -> x592

    let create : ?cursor_blink_rate:float -> ?draw_range_cursor:bool -> unit -> t =
      fun ?cursor_blink_rate:(x594 : float option)
        ?draw_range_cursor:(x595 : bool option)
        () ->
      let x596 = Ojs.empty_obj () in
      (match x594 with
       | Some x598 -> Ojs.set_prop_ascii x596 "cursorBlinkRate" (Ojs.float_to_js x598)
       | None -> ());
      (match x595 with
       | Some x597 -> Ojs.set_prop_ascii x596 "drawRangeCursor" (Ojs.bool_to_js x597)
       | None -> ());
      t_of_js x596
    ;;
  end

  let draw_selection : ?config:Draw_selection_config.t -> unit -> State.Extension.t =
    fun ?config:(x599 : Draw_selection_config.t option) () ->
    State.Extension.t_of_js
      (let x602 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View"
       in
       Ojs.call
         (Ojs.get_prop_ascii x602 "drawSelection")
         "apply"
         [| x602
          ; (let x600 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (match x599 with
              | Some x601 ->
                (ignore : _)
                  (Ojs.call x600 "push" [| Draw_selection_config.t_to_js x601 |])
              | None -> ());
             x600)
         |])
  ;;

  module Widget_type = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x604 : Ojs.t) -> x604
    and t_to_js : t -> Ojs.t = fun (x603 : Ojs.t) -> x603

    let create : unit -> t =
      fun () ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "WidgetType")
           [||])
    ;;

    let set_to_dom : t -> (unit -> Ojs.t) -> unit =
      fun (x605 : t) (x606 : unit -> Ojs.t) ->
      Ojs.set_prop_ascii (t_to_js x605) "toDOM" (Ojs.fun_to_js 1 (fun _ -> x606 ()))
    ;;
  end

  module Decoration = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x608 : Ojs.t) -> x608
    and t_to_js : t -> Ojs.t = fun (x607 : Ojs.t) -> x607

    let range : t -> from:int -> to_:int -> t State.Range.t =
      fun (x611 : t) ~from:(x609 : int) ~to_:(x610 : int) ->
      State.Range.t_of_js
        t_of_js
        (Ojs.call (t_to_js x611) "range" [| Ojs.int_to_js x609; Ojs.int_to_js x610 |])
    ;;

    let set : t State.Range.t list -> sort:bool -> t State.Range_set.t =
      fun (x613 : t State.Range.t list) ~sort:(x616 : bool) ->
      State.Range_set.t_of_js
        t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "set"
           [| Ojs.list_to_js
                (fun (x614 : t State.Range.t) -> State.Range.t_to_js t_to_js x614)
                x613
            ; Ojs.bool_to_js x616
           |])
    ;;

    let none : t State.Range_set.t =
      State.Range_set.t_of_js
        t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "none")
    ;;

    module Mark_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x620 : Ojs.t) -> x620
      and t_to_js : t -> Ojs.t = fun (x619 : Ojs.t) -> x619

      let create
        :  ?inclusive:bool -> ?inclusive_start:bool -> ?inclusive_end:bool
        -> ?attributes:Ojs.t -> ?class_:string -> ?tag_name:string -> unit -> t
        =
        fun ?inclusive:(x621 : bool option)
          ?inclusive_start:(x622 : bool option)
          ?inclusive_end:(x623 : bool option)
          ?attributes:(x624 : Ojs.t option)
          ?class_:(x625 : string option)
          ?tag_name:(x626 : string option)
          () ->
        let x627 = Ojs.empty_obj () in
        (match x621 with
         | Some x633 -> Ojs.set_prop_ascii x627 "inclusive" (Ojs.bool_to_js x633)
         | None -> ());
        (match x622 with
         | Some x632 -> Ojs.set_prop_ascii x627 "inclusiveStart" (Ojs.bool_to_js x632)
         | None -> ());
        (match x623 with
         | Some x631 -> Ojs.set_prop_ascii x627 "inclusiveEnd" (Ojs.bool_to_js x631)
         | None -> ());
        (match x624 with
         | Some x630 -> Ojs.set_prop_ascii x627 "attributes" x630
         | None -> ());
        (match x625 with
         | Some x629 -> Ojs.set_prop_ascii x627 "class" (Ojs.string_to_js x629)
         | None -> ());
        (match x626 with
         | Some x628 -> Ojs.set_prop_ascii x627 "tagName" (Ojs.string_to_js x628)
         | None -> ());
        t_of_js x627
      ;;
    end

    let mark : Mark_spec.t -> t =
      fun (x634 : Mark_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "mark"
           [| Mark_spec.t_to_js x634 |])
    ;;

    module Widget_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x636 : Ojs.t) -> x636
      and t_to_js : t -> Ojs.t = fun (x635 : Ojs.t) -> x635

      let create
        :  widget:Widget_type.t -> ?side:int -> ?inline_order:bool -> ?block:bool -> unit
        -> t
        =
        fun ~widget:(x637 : Widget_type.t)
          ?side:(x638 : int option)
          ?inline_order:(x639 : bool option)
          ?block:(x640 : bool option)
          () ->
        let x641 = Ojs.empty_obj () in
        Ojs.set_prop_ascii x641 "widget" (Widget_type.t_to_js x637);
        (match x638 with
         | Some x644 -> Ojs.set_prop_ascii x641 "side" (Ojs.int_to_js x644)
         | None -> ());
        (match x639 with
         | Some x643 -> Ojs.set_prop_ascii x641 "inlineOrder" (Ojs.bool_to_js x643)
         | None -> ());
        (match x640 with
         | Some x642 -> Ojs.set_prop_ascii x641 "block" (Ojs.bool_to_js x642)
         | None -> ());
        t_of_js x641
      ;;
    end

    let widget : Widget_spec.t -> t =
      fun (x645 : Widget_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "widget"
           [| Widget_spec.t_to_js x645 |])
    ;;

    module Replace_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x647 : Ojs.t) -> x647
      and t_to_js : t -> Ojs.t = fun (x646 : Ojs.t) -> x646

      let create
        :  ?widget:Widget_type.t -> ?inclusive:bool -> ?inclusive_start:bool
        -> ?inclusive_end:bool -> ?block:bool -> unit -> t
        =
        fun ?widget:(x648 : Widget_type.t option)
          ?inclusive:(x649 : bool option)
          ?inclusive_start:(x650 : bool option)
          ?inclusive_end:(x651 : bool option)
          ?block:(x652 : bool option)
          () ->
        let x653 = Ojs.empty_obj () in
        (match x648 with
         | Some x658 -> Ojs.set_prop_ascii x653 "widget" (Widget_type.t_to_js x658)
         | None -> ());
        (match x649 with
         | Some x657 -> Ojs.set_prop_ascii x653 "inclusive" (Ojs.bool_to_js x657)
         | None -> ());
        (match x650 with
         | Some x656 -> Ojs.set_prop_ascii x653 "inclusiveStart" (Ojs.bool_to_js x656)
         | None -> ());
        (match x651 with
         | Some x655 -> Ojs.set_prop_ascii x653 "inclusiveEnd" (Ojs.bool_to_js x655)
         | None -> ());
        (match x652 with
         | Some x654 -> Ojs.set_prop_ascii x653 "block" (Ojs.bool_to_js x654)
         | None -> ());
        t_of_js x653
      ;;
    end

    let replace : Replace_spec.t -> t =
      fun (x659 : Replace_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "replace"
           [| Replace_spec.t_to_js x659 |])
    ;;

    module Line_spec = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x661 : Ojs.t) -> x661
      and t_to_js : t -> Ojs.t = fun (x660 : Ojs.t) -> x660

      let create : ?attributes:Ojs.t -> ?class_:string -> unit -> t =
        fun ?attributes:(x662 : Ojs.t option) ?class_:(x663 : string option) () ->
        let x664 = Ojs.empty_obj () in
        (match x662 with
         | Some x666 -> Ojs.set_prop_ascii x664 "attributes" x666
         | None -> ());
        (match x663 with
         | Some x665 -> Ojs.set_prop_ascii x664 "class" (Ojs.string_to_js x665)
         | None -> ());
        t_of_js x664
      ;;
    end

    let line : Line_spec.t -> t =
      fun (x667 : Line_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "Decoration")
           "line"
           [| Line_spec.t_to_js x667 |])
    ;;
  end

  module Decoration_set = struct
    type t = Decoration.t State.Range_set.t

    let rec t_of_js : Ojs.t -> t =
      fun (x670 : Ojs.t) -> State.Range_set.t_of_js Decoration.t_of_js x670

    and t_to_js : t -> Ojs.t =
      fun (x668 : Decoration.t State.Range_set.t) ->
      State.Range_set.t_to_js Decoration.t_to_js x668
    ;;
  end

  module Dom_event_handlers = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x673 : Ojs.t) -> x673
    and t_to_js : t -> Ojs.t = fun (x672 : Ojs.t) -> x672

    type handler = Dom_event.t -> editor_view -> unit

    let rec handler_of_js : Ojs.t -> handler =
      fun (x677 : Ojs.t) (x678 : Dom_event.t) (x679 : editor_view) ->
      (ignore : _) (Ojs.apply x677 [| Dom_event.t_to_js x678; editor_view_to_js x679 |])

    and handler_to_js : handler -> Ojs.t =
      fun (x674 : Dom_event.t -> editor_view -> unit) ->
      Ojs.fun_to_js 2 (fun (x675 : Ojs.t) (x676 : Ojs.t) ->
        x674 (Dom_event.t_of_js x675) (editor_view_of_js x676))
    ;;

    let create : ?paste:handler -> ?drop:handler -> unit -> t =
      fun ?paste:(x680 : handler option) ?drop:(x681 : handler option) () ->
      let x682 = Ojs.empty_obj () in
      (match x680 with
       | Some x684 -> Ojs.set_prop_ascii x682 "paste" (handler_to_js x684)
       | None -> ());
      (match x681 with
       | Some x683 -> Ojs.set_prop_ascii x682 "drop" (handler_to_js x683)
       | None -> ());
      t_of_js x682
    ;;
  end

  module Editor_view = struct
    type t = editor_view

    let rec t_of_js : Ojs.t -> t = fun (x686 : Ojs.t) -> editor_view_of_js x686
    and t_to_js : t -> Ojs.t = fun (x685 : editor_view) -> editor_view_to_js x685

    let create : Config.t -> t =
      fun (x687 : Config.t) ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           [| Config.t_to_js x687 |])
    ;;

    let dom : t -> Dom_html_element.t =
      fun (x688 : t) -> Dom_html_element.t_of_js (Ojs.get_prop_ascii (t_to_js x688) "dom")
    ;;

    let content_dom : t -> Dom_html_element.t =
      fun (x689 : t) ->
      Dom_html_element.t_of_js (Ojs.get_prop_ascii (t_to_js x689) "contentDOM")
    ;;

    let update_listener : (View_update.t -> unit) State.Facet.multi_out =
      State.Facet.multi_out_of_js
        (fun (x690 : Ojs.t) (x691 : View_update.t) ->
          (ignore : _) (Ojs.apply x690 [| View_update.t_to_js x691 |]))
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "updateListener")
    ;;

    let update : t -> State.Transaction.t list -> unit =
      fun (x694 : t) (x692 : State.Transaction.t list) ->
      (ignore : _)
        (Ojs.call
           (t_to_js x694)
           "update"
           [| Ojs.list_to_js State.Transaction.t_to_js x692 |])
    ;;

    let dispatch : t -> State.Transaction.t -> unit =
      fun (x696 : t) (x695 : State.Transaction.t) ->
      (ignore : _)
        (Ojs.call (t_to_js x696) "dispatch" [| State.Transaction.t_to_js x695 |])
    ;;

    let dispatch_specs : t -> State.Transaction_spec.t -> unit =
      fun (x698 : t) (x697 : State.Transaction_spec.t) ->
      (ignore : _)
        (Ojs.call (t_to_js x698) "dispatch" [| State.Transaction_spec.t_to_js x697 |])
    ;;

    let set_state : t -> State.Editor_state.t -> unit =
      fun (x700 : t) (x699 : State.Editor_state.t) ->
      (ignore : _)
        (Ojs.call (t_to_js x700) "setState" [| State.Editor_state.t_to_js x699 |])
    ;;

    let set_tab_focus_mode : t -> bool -> unit =
      fun (x702 : t) (x701 : bool) ->
      (ignore : _) (Ojs.call (t_to_js x702) "setTabFocusMode" [| Ojs.bool_to_js x701 |])
    ;;

    let state : t -> State.Editor_state.t =
      fun (x703 : t) ->
      State.Editor_state.t_of_js (Ojs.get_prop_ascii (t_to_js x703) "state")
    ;;

    let focus : t -> unit =
      fun (x704 : t) -> (ignore : _) (Ojs.call (t_to_js x704) "focus" [||])
    ;;

    let has_focus : t -> bool =
      fun (x705 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x705) "hasFocus")
    ;;

    let destroy : t -> unit =
      fun (x706 : t) -> (ignore : _) (Ojs.call (t_to_js x706) "destroy" [||])
    ;;

    let line_wrapping : State.Extension.t =
      State.Extension.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "lineWrapping")
    ;;

    let dom_event_handlers : Dom_event_handlers.t -> State.Extension.t =
      fun (x707 : Dom_event_handlers.t) ->
      State.Extension.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "domEventHandlers"
           [| Dom_event_handlers.t_to_js x707 |])
    ;;

    let editable : (bool, bool) State.Facet.t =
      State.Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "editable")
    ;;

    let dark_theme : (bool, bool) State.Facet.t =
      State.Facet.t_of_js
        Ojs.bool_of_js
        Ojs.bool_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "darkTheme")
    ;;

    let decorations : (Decoration_set.t, Decoration_set.t) State.Facet.t =
      State.Facet.t_of_js
        Decoration_set.t_of_js
        Decoration_set.t_of_js
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "decorations")
    ;;

    let decorations'
      : ( (editor_view -> Decoration_set.t) Callback.t
          , (editor_view -> Decoration_set.t) Callback.t )
          State.Facet.t
      =
      State.Facet.t_of_js
        (fun (x714 : Ojs.t) ->
          Callback.t_of_js
            (fun (x715 : Ojs.t) (x716 : editor_view) ->
              Decoration_set.t_of_js (Ojs.apply x715 [| editor_view_to_js x716 |]))
            x714)
        (fun (x717 : Ojs.t) ->
          Callback.t_of_js
            (fun (x718 : Ojs.t) (x719 : editor_view) ->
              Decoration_set.t_of_js (Ojs.apply x718 [| editor_view_to_js x719 |]))
            x717)
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "decorations")
    ;;

    let content_attributes : (Ojs.t, Ojs.t) State.Facet.t =
      State.Facet.t_of_js
        (fun (x720 : Ojs.t) -> x720)
        (fun (x721 : Ojs.t) -> x721)
        (Ojs.get_prop_ascii
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "contentAttributes")
    ;;

    module Viewport = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x723 : Ojs.t) -> x723
      and t_to_js : t -> Ojs.t = fun (x722 : Ojs.t) -> x722

      let from : t -> int =
        fun (x724 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x724) "from")
      ;;

      let to_ : t -> int =
        fun (x725 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x725) "to")
      ;;
    end

    let viewport : t -> Viewport.t =
      fun (x726 : t) -> Viewport.t_of_js (Ojs.get_prop_ascii (t_to_js x726) "viewport")
    ;;

    module Scroll_into_view_options = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x728 : Ojs.t) -> x728
      and t_to_js : t -> Ojs.t = fun (x727 : Ojs.t) -> x727

      let create : ?y:string -> unit -> t =
        fun ?y:(x729 : string option) () ->
        let x730 = Ojs.empty_obj () in
        (match x729 with
         | Some x731 -> Ojs.set_prop_ascii x730 "y" (Ojs.string_to_js x731)
         | None -> ());
        t_of_js x730
      ;;
    end

    let scroll_into_view
      : pos:int -> ?options:Scroll_into_view_options.t -> unit -> State.State_effect.t
      =
      fun ~pos:(x732 : int) ?options:(x733 : Scroll_into_view_options.t option) () ->
      State.State_effect.t_of_js
        (let x736 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
             "EditorView"
         in
         Ojs.call
           (Ojs.get_prop_ascii x736 "scrollIntoView")
           "apply"
           [| x736
            ; (let x734 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x734 "push" [| Ojs.int_to_js x732 |]);
               (match x733 with
                | Some x735 ->
                  (ignore : _)
                    (Ojs.call x734 "push" [| Scroll_into_view_options.t_to_js x735 |])
                | None -> ());
               x734)
           |])
    ;;

    module Theme_options = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x738 : Ojs.t) -> x738
      and t_to_js : t -> Ojs.t = fun (x737 : Ojs.t) -> x737

      let create : ?dark:bool -> unit -> t =
        fun ?dark:(x739 : bool option) () ->
        let x740 = Ojs.empty_obj () in
        (match x739 with
         | Some x741 -> Ojs.set_prop_ascii x740 "dark" (Ojs.bool_to_js x741)
         | None -> ());
        t_of_js x740
      ;;
    end

    let theme : spec:Ojs.t -> ?options:Theme_options.t -> unit -> State.Extension.t =
      fun ~spec:(x742 : Ojs.t) ?options:(x743 : Theme_options.t option) () ->
      State.Extension.t_of_js
        (let x746 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
             "EditorView"
         in
         Ojs.call
           (Ojs.get_prop_ascii x746 "theme")
           "apply"
           [| x746
            ; (let x744 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x744 "push" [| x742 |]);
               (match x743 with
                | Some x745 ->
                  (ignore : _) (Ojs.call x744 "push" [| Theme_options.t_to_js x745 |])
                | None -> ());
               x744)
           |])
    ;;

    let find_from_dom : Dom_html_element.t -> t option =
      fun (x747 : Dom_html_element.t) ->
      Ojs.option_of_js
        t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "EditorView")
           "findFromDOM"
           [| Dom_html_element.t_to_js x747 |])
    ;;
  end

  module Plugin_value = struct
    type 'v t =
      { update : (View_update.t -> unit) option
      ; destroy : (unit -> unit) option
      ; custom_state : 'v
      }

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x753 : Ojs.t) ->
      { update =
          Ojs.option_of_js
            (fun (x754 : Ojs.t) (x755 : View_update.t) ->
              (ignore : _) (Ojs.apply x754 [| View_update.t_to_js x755 |]))
            (Ojs.get_prop_ascii x753 "update")
      ; destroy =
          Ojs.option_of_js
            (fun (x756 : Ojs.t) () -> (ignore : _) (Ojs.apply x756 [||]))
            (Ojs.get_prop_ascii x753 "destroy")
      ; custom_state = __v_of_js (Ojs.get_prop_ascii x753 "customState")
      }

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x749 : __v t) ->
      Ojs.obj
        [| ( "update"
           , Ojs.option_to_js
               (fun (x750 : View_update.t -> unit) ->
                 Ojs.fun_to_js 1 (fun (x751 : Ojs.t) -> x750 (View_update.t_of_js x751)))
               x749.update )
         ; ( "destroy"
           , Ojs.option_to_js
               (fun (x752 : unit -> unit) -> Ojs.fun_to_js 1 (fun _ -> x752 ()))
               x749.destroy )
         ; "customState", __v_to_js x749.custom_state
        |]
    ;;
  end

  module Plugin_spec = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x758 : Ojs.t) -> x758

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x757 : Ojs.t) -> x757
    ;;

    let create : decorations:('v Plugin_value.t -> Decoration_set.t) option -> 'v t =
      fun ~decorations:(x759 : ('v Plugin_value.t -> Decoration_set.t) option) ->
      let x760 = Ojs.empty_obj () in
      Ojs.set_prop_ascii
        x760
        "decorations"
        (Ojs.option_to_js
           (fun (x762 : 'v Plugin_value.t -> Decoration_set.t) ->
             Ojs.fun_to_js 1 (fun (x763 : Ojs.t) ->
               Decoration_set.t_to_js (x762 (Plugin_value.t_of_js Obj.magic x763))))
           x759);
      t_of_js Obj.magic x760
    ;;
  end

  module View_plugin = struct
    type 'v t = Ojs.t

    let rec t_of_js : 'v. (Ojs.t -> 'v) -> Ojs.t -> 'v t =
      fun (type __v) (__v_of_js : Ojs.t -> __v) (x766 : Ojs.t) -> x766

    and t_to_js : 'v. ('v -> Ojs.t) -> 'v t -> Ojs.t =
      fun (type __v) (__v_to_js : __v -> Ojs.t) (x765 : Ojs.t) -> x765
    ;;

    let extension : 'v t -> State.Extension.t =
      fun (x767 : 'v t) ->
      State.Extension.t_of_js (Ojs.get_prop_ascii (t_to_js Obj.magic x767) "extension")
    ;;

    let define
      :  create:(Editor_view.t -> 'v Plugin_value.t) -> ?spec:'v Plugin_spec.t -> unit
      -> 'v t
      =
      fun ~create:(x769 : Editor_view.t -> 'v Plugin_value.t)
        ?spec:(x770 : 'v Plugin_spec.t option)
        () ->
      t_of_js
        Obj.magic
        (let x776 =
           Ojs.get_prop_ascii
             (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
             "ViewPlugin"
         in
         Ojs.call
           (Ojs.get_prop_ascii x776 "define")
           "apply"
           [| x776
            ; (let x771 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _)
                 (Ojs.call
                    x771
                    "push"
                    [| Ojs.fun_to_js 1 (fun (x774 : Ojs.t) ->
                         Plugin_value.t_to_js Obj.magic (x769 (Editor_view.t_of_js x774)))
                    |]);
               (match x770 with
                | Some x772 ->
                  (ignore : _)
                    (Ojs.call x771 "push" [| Plugin_spec.t_to_js Obj.magic x772 |])
                | None -> ());
               x771)
           |])
    ;;
  end

  module Match_decorator = struct
    module Config = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x779 : Ojs.t) -> x779
      and t_to_js : t -> Ojs.t = fun (x778 : Ojs.t) -> x778

      let create
        :  regexp:RegExp.t -> ?decoration:Decoration.t
        -> ?decorate:
             (add:(from:int -> to_:int -> Decoration.t -> unit)
              -> from:int
              -> to_:int
              -> string option list
              -> Editor_view.t
              -> unit)
        -> ?max_length:int -> unit -> t
        =
        fun ~regexp:(x780 : RegExp.t)
          ?decoration:(x781 : Decoration.t option)
          ?decorate:
            (x782 :
               (add:(from:int -> to_:int -> Decoration.t -> unit)
                -> from:int
                -> to_:int
                -> string option list
                -> Editor_view.t
                -> unit)
                 option)
          ?max_length:(x783 : int option)
          () ->
        let x784 = Ojs.empty_obj () in
        Ojs.set_prop_ascii x784 "regexp" (RegExp.t_to_js x780);
        (match x781 with
         | Some x797 -> Ojs.set_prop_ascii x784 "decoration" (Decoration.t_to_js x797)
         | None -> ());
        (match x782 with
         | Some x786 ->
           Ojs.set_prop_ascii
             x784
             "decorate"
             (Ojs.fun_to_js
                5
                (fun
                    (x787 : Ojs.t)
                    (x791 : Ojs.t)
                    (x792 : Ojs.t)
                    (x793 : Ojs.t)
                    (x796 : Ojs.t)
                  ->
                   x786
                     ~add:
                       (fun
                         ~from:(x788 : int) ~to_:(x789 : int) (x790 : Decoration.t) ->
                       (ignore : _)
                         (Ojs.apply
                            x787
                            [| Ojs.int_to_js x788
                             ; Ojs.int_to_js x789
                             ; Decoration.t_to_js x790
                            |]))
                     ~from:(Ojs.int_of_js x791)
                     ~to_:(Ojs.int_of_js x792)
                     (Ojs.list_of_js
                        (fun (x794 : Ojs.t) -> Ojs.option_of_js Ojs.string_of_js x794)
                        x793)
                     (Editor_view.t_of_js x796)))
         | None -> ());
        (match x783 with
         | Some x785 -> Ojs.set_prop_ascii x784 "maxLength" (Ojs.int_to_js x785)
         | None -> ());
        t_of_js x784
      ;;
    end

    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x799 : Ojs.t) -> x799
    and t_to_js : t -> Ojs.t = fun (x798 : Ojs.t) -> x798

    let create : Config.t -> t =
      fun (x800 : Config.t) ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "MatchDecorator")
           [| Config.t_to_js x800 |])
    ;;

    let create_deco : t -> Editor_view.t -> Decoration_set.t =
      fun (x802 : t) (x801 : Editor_view.t) ->
      Decoration_set.t_of_js
        (Ojs.call (t_to_js x802) "createDeco" [| Editor_view.t_to_js x801 |])
    ;;
  end

  module Command = struct
    type t = Editor_view.t -> bool

    let rec t_of_js : Ojs.t -> t =
      fun (x805 : Ojs.t) (x806 : Editor_view.t) ->
      Ojs.bool_of_js (Ojs.apply x805 [| Editor_view.t_to_js x806 |])

    and t_to_js : t -> Ojs.t =
      fun (x803 : Editor_view.t -> bool) ->
      Ojs.fun_to_js 1 (fun (x804 : Ojs.t) ->
        Ojs.bool_to_js (x803 (Editor_view.t_of_js x804)))
    ;;
  end

  module Key_binding = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x808 : Ojs.t) -> x808
    and t_to_js : t -> Ojs.t = fun (x807 : Ojs.t) -> x807

    let create
      :  ?key:string -> ?mac:string -> ?win:string -> ?linux:string -> run:Command.t
      -> ?shift:Command.t -> ?scope:string -> ?prevent_default:bool
      -> ?stop_propagation:bool -> unit -> t
      =
      fun ?key:(x809 : string option)
        ?mac:(x810 : string option)
        ?win:(x811 : string option)
        ?linux:(x812 : string option)
        ~run:(x813 : Command.t)
        ?shift:(x814 : Command.t option)
        ?scope:(x815 : string option)
        ?prevent_default:(x816 : bool option)
        ?stop_propagation:(x817 : bool option)
        () ->
      let x818 = Ojs.empty_obj () in
      (match x809 with
       | Some x826 -> Ojs.set_prop_ascii x818 "key" (Ojs.string_to_js x826)
       | None -> ());
      (match x810 with
       | Some x825 -> Ojs.set_prop_ascii x818 "mac" (Ojs.string_to_js x825)
       | None -> ());
      (match x811 with
       | Some x824 -> Ojs.set_prop_ascii x818 "win" (Ojs.string_to_js x824)
       | None -> ());
      (match x812 with
       | Some x823 -> Ojs.set_prop_ascii x818 "linux" (Ojs.string_to_js x823)
       | None -> ());
      Ojs.set_prop_ascii x818 "run" (Command.t_to_js x813);
      (match x814 with
       | Some x822 -> Ojs.set_prop_ascii x818 "shift" (Command.t_to_js x822)
       | None -> ());
      (match x815 with
       | Some x821 -> Ojs.set_prop_ascii x818 "scope" (Ojs.string_to_js x821)
       | None -> ());
      (match x816 with
       | Some x820 -> Ojs.set_prop_ascii x818 "preventDefault" (Ojs.bool_to_js x820)
       | None -> ());
      (match x817 with
       | Some x819 -> Ojs.set_prop_ascii x818 "stopPropagation" (Ojs.bool_to_js x819)
       | None -> ());
      t_of_js x818
    ;;
  end

  let keymap : Key_binding.t list State.Facet.multi_out =
    State.Facet.multi_out_of_js
      (fun (x827 : Ojs.t) -> Ojs.list_of_js Key_binding.t_of_js x827)
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "keymap")
  ;;

  module Tooltip_view = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x830 : Ojs.t) -> x830
    and t_to_js : t -> Ojs.t = fun (x829 : Ojs.t) -> x829

    module Offset = struct
      type t =
        { x : int
        ; y : int
        }

      let rec t_of_js : Ojs.t -> t =
        fun (x832 : Ojs.t) ->
        { x = Ojs.int_of_js (Ojs.get_prop_ascii x832 "x")
        ; y = Ojs.int_of_js (Ojs.get_prop_ascii x832 "y")
        }

      and t_to_js : t -> Ojs.t =
        fun (x831 : t) ->
        Ojs.obj [| "x", Ojs.int_to_js x831.x; "y", Ojs.int_to_js x831.y |]
      ;;
    end

    let create
      :  dom:Dom_html_element.t -> ?offset:Offset.t -> ?overlap:bool -> ?resize:bool
      -> ?destroy:(unit -> unit) -> unit -> t
      =
      fun ~dom:(x833 : Dom_html_element.t)
        ?offset:(x834 : Offset.t option)
        ?overlap:(x835 : bool option)
        ?resize:(x836 : bool option)
        ?destroy:(x837 : (unit -> unit) option)
        () ->
      let x838 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x838 "dom" (Dom_html_element.t_to_js x833);
      (match x834 with
       | Some x842 -> Ojs.set_prop_ascii x838 "offset" (Offset.t_to_js x842)
       | None -> ());
      (match x835 with
       | Some x841 -> Ojs.set_prop_ascii x838 "overlap" (Ojs.bool_to_js x841)
       | None -> ());
      (match x836 with
       | Some x840 -> Ojs.set_prop_ascii x838 "resize" (Ojs.bool_to_js x840)
       | None -> ());
      (match x837 with
       | Some x839 ->
         Ojs.set_prop_ascii x838 "destroy" (Ojs.fun_to_js 1 (fun _ -> x839 ()))
       | None -> ());
      t_of_js x838
    ;;
  end

  module Tooltip = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x844 : Ojs.t) -> x844
    and t_to_js : t -> Ojs.t = fun (x843 : Ojs.t) -> x843

    let create
      :  pos:int -> ?end_:int -> create:(view:Editor_view.t -> Tooltip_view.t)
      -> ?above:bool -> ?strict_side:bool -> ?arrow:bool -> unit -> t
      =
      fun ~pos:(x845 : int)
        ?end_:(x846 : int option)
        ~create:(x847 : view:Editor_view.t -> Tooltip_view.t)
        ?above:(x848 : bool option)
        ?strict_side:(x849 : bool option)
        ?arrow:(x850 : bool option)
        () ->
      let x851 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x851 "pos" (Ojs.int_to_js x845);
      (match x846 with
       | Some x856 -> Ojs.set_prop_ascii x851 "end" (Ojs.int_to_js x856)
       | None -> ());
      Ojs.set_prop_ascii
        x851
        "create"
        (Ojs.fun_to_js 1 (fun (x855 : Ojs.t) ->
           Tooltip_view.t_to_js (x847 ~view:(Editor_view.t_of_js x855))));
      (match x848 with
       | Some x854 -> Ojs.set_prop_ascii x851 "above" (Ojs.bool_to_js x854)
       | None -> ());
      (match x849 with
       | Some x853 -> Ojs.set_prop_ascii x851 "strictSide" (Ojs.bool_to_js x853)
       | None -> ());
      (match x850 with
       | Some x852 -> Ojs.set_prop_ascii x851 "arrow" (Ojs.bool_to_js x852)
       | None -> ());
      t_of_js x851
    ;;

    let pos : t -> int =
      fun (x857 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x857) "pos")
    ;;

    let end_ : t -> int option =
      fun (x858 : t) ->
      Ojs.option_of_js Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x858) "end")
    ;;
  end

  module Hover_tooltip_source = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x861 : Ojs.t) -> x861
    and t_to_js : t -> Ojs.t = fun (x860 : Ojs.t) -> x860

    let of_sync_fn : (view:Editor_view.t -> pos:int -> side:int -> Tooltip.t option) -> t =
      fun (x862 : view:Editor_view.t -> pos:int -> side:int -> Tooltip.t option) ->
      t_of_js
        (Ojs.fun_to_js 3 (fun (x863 : Ojs.t) (x864 : Ojs.t) (x865 : Ojs.t) ->
           Ojs.option_to_js
             Tooltip.t_to_js
             (x862
                ~view:(Editor_view.t_of_js x863)
                ~pos:(Ojs.int_of_js x864)
                ~side:(Ojs.int_of_js x865))))
    ;;

    let of_async_fn
      :  (view:Editor_view.t
          -> pos:int
          -> side:int
          -> (Tooltip.t option With_conversion.t, 'e) Promise.t)
      -> t
      =
      fun (x867 :
            view:Editor_view.t
            -> pos:int
            -> side:int
            -> (Tooltip.t option With_conversion.t, 'e) Promise.t) ->
      t_of_js
        (Ojs.fun_to_js 3 (fun (x868 : Ojs.t) (x869 : Ojs.t) (x870 : Ojs.t) ->
           Promise.t_to_js
             (fun (x871 : Tooltip.t option With_conversion.t) ->
               With_conversion.t_to_js
                 (fun (x872 : Tooltip.t option) -> Ojs.option_to_js Tooltip.t_to_js x872)
                 x871)
             Obj.magic
             (x867
                ~view:(Editor_view.t_of_js x868)
                ~pos:(Ojs.int_of_js x869)
                ~side:(Ojs.int_of_js x870))))
    ;;
  end

  module Hover_tooltip_options = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x876 : Ojs.t) -> x876
    and t_to_js : t -> Ojs.t = fun (x875 : Ojs.t) -> x875

    let create : ?hide_on_change:bool -> ?hover_time:int -> unit -> t =
      fun ?hide_on_change:(x877 : bool option) ?hover_time:(x878 : int option) () ->
      let x879 = Ojs.empty_obj () in
      (match x877 with
       | Some x881 -> Ojs.set_prop_ascii x879 "hideOnChange" (Ojs.bool_to_js x881)
       | None -> ());
      (match x878 with
       | Some x880 -> Ojs.set_prop_ascii x879 "hoverTime" (Ojs.int_to_js x880)
       | None -> ());
      t_of_js x879
    ;;
  end

  let hover_tooltip
    :  source:Hover_tooltip_source.t -> ?options:Hover_tooltip_options.t -> unit
    -> State.Extension.t
    =
    fun ~source:(x882 : Hover_tooltip_source.t)
      ?options:(x883 : Hover_tooltip_options.t option)
      () ->
    State.Extension.t_of_js
      (let x886 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View"
       in
       Ojs.call
         (Ojs.get_prop_ascii x886 "hoverTooltip")
         "apply"
         [| x886
          ; (let x884 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (ignore : _) (Ojs.call x884 "push" [| Hover_tooltip_source.t_to_js x882 |]);
             (match x883 with
              | Some x885 ->
                (ignore : _)
                  (Ojs.call x884 "push" [| Hover_tooltip_options.t_to_js x885 |])
              | None -> ());
             x884)
         |])
  ;;

  let show_tooltip : Tooltip.t option State.Facet.multi_out =
    State.Facet.multi_out_of_js
      (fun (x887 : Ojs.t) -> Ojs.option_of_js Tooltip.t_of_js x887)
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "showTooltip")
  ;;

  module Layer_marker = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x890 : Ojs.t) -> x890
    and t_to_js : t -> Ojs.t = fun (x889 : Ojs.t) -> x889

    let create
      :  eq:(other:t -> bool) -> draw:(unit -> Dom_html_element.t)
      -> ?update:(Dom_html_element.t -> old_marker:t -> bool) -> unit -> t
      =
      fun ~eq:(x891 : other:t -> bool)
        ~draw:(x892 : unit -> Dom_html_element.t)
        ?update:(x893 : (Dom_html_element.t -> old_marker:t -> bool) option)
        () ->
      let x894 = Ojs.empty_obj () in
      Ojs.set_prop_ascii
        x894
        "eq"
        (Ojs.fun_to_js 1 (fun (x898 : Ojs.t) ->
           Ojs.bool_to_js (x891 ~other:(t_of_js x898))));
      Ojs.set_prop_ascii
        x894
        "draw"
        (Ojs.fun_to_js 1 (fun _ -> Dom_html_element.t_to_js (x892 ())));
      (match x893 with
       | Some x895 ->
         Ojs.set_prop_ascii
           x894
           "update"
           (Ojs.fun_to_js 2 (fun (x896 : Ojs.t) (x897 : Ojs.t) ->
              Ojs.bool_to_js
                (x895 (Dom_html_element.t_of_js x896) ~old_marker:(t_of_js x897))))
       | None -> ());
      t_of_js x894
    ;;
  end

  module Rectangle_marker = struct
    type t = Layer_marker.t

    let rec t_of_js : Ojs.t -> t = fun (x900 : Ojs.t) -> Layer_marker.t_of_js x900
    and t_to_js : t -> Ojs.t = fun (x899 : Layer_marker.t) -> Layer_marker.t_to_js x899

    let create
      :  class_name:string -> left:float -> top:float -> ?width:float -> height:float
      -> unit -> t
      =
      fun ~class_name:(x901 : string)
        ~left:(x902 : float)
        ~top:(x903 : float)
        ?width:(x904 : float option)
        ~height:(x905 : float)
        () ->
      t_of_js
        (Ojs.new_obj_arr
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "RectangleMarker")
           (let x906 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
            (ignore : _) (Ojs.call x906 "push" [| Ojs.string_to_js x901 |]);
            (ignore : _) (Ojs.call x906 "push" [| Ojs.float_to_js x902 |]);
            (ignore : _) (Ojs.call x906 "push" [| Ojs.float_to_js x903 |]);
            (match x904 with
             | Some x907 -> (ignore : _) (Ojs.call x906 "push" [| Ojs.float_to_js x907 |])
             | None -> ());
            (ignore : _) (Ojs.call x906 "push" [| Ojs.float_to_js x905 |]);
            x906))
    ;;

    let left : t -> float =
      fun (x908 : t) -> Ojs.float_of_js (Ojs.get_prop_ascii (t_to_js x908) "left")
    ;;

    let top : t -> float =
      fun (x909 : t) -> Ojs.float_of_js (Ojs.get_prop_ascii (t_to_js x909) "top")
    ;;

    let width : t -> float option =
      fun (x910 : t) ->
      Ojs.option_of_js Ojs.float_of_js (Ojs.get_prop_ascii (t_to_js x910) "width")
    ;;

    let height : t -> float =
      fun (x912 : t) -> Ojs.float_of_js (Ojs.get_prop_ascii (t_to_js x912) "height")
    ;;

    let for_range
      : view:editor_view -> class_name:string -> range:State.Selection_range.t -> t list
      =
      fun ~view:(x913 : editor_view)
        ~class_name:(x914 : string)
        ~range:(x915 : State.Selection_range.t) ->
      Ojs.list_of_js
        t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
              "RectangleMarker")
           "forRange"
           [| editor_view_to_js x913
            ; Ojs.string_to_js x914
            ; State.Selection_range.t_to_js x915
           |])
    ;;
  end

  module Layer_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x918 : Ojs.t) -> x918
    and t_to_js : t -> Ojs.t = fun (x917 : Ojs.t) -> x917

    let create
      :  ?above:bool -> ?class_:string
      -> update:(update:View_update.t -> layer:Dom_html_element.t -> bool)
      -> ?update_on_doc_view_update:bool
      -> markers:(view:editor_view -> Layer_marker.t list)
      -> ?mount:(layer:Dom_html_element.t -> view:editor_view -> unit)
      -> ?destroy:(layer:Dom_html_element.t -> view:editor_view -> unit) -> unit -> t
      =
      fun ?above:(x919 : bool option)
        ?class_:(x920 : string option)
        ~update:(x921 : update:View_update.t -> layer:Dom_html_element.t -> bool)
        ?update_on_doc_view_update:(x922 : bool option)
        ~markers:(x923 : view:editor_view -> Layer_marker.t list)
        ?mount:(x924 : (layer:Dom_html_element.t -> view:editor_view -> unit) option)
        ?destroy:(x925 : (layer:Dom_html_element.t -> view:editor_view -> unit) option)
        () ->
      let x926 = Ojs.empty_obj () in
      (match x919 with
       | Some x939 -> Ojs.set_prop_ascii x926 "above" (Ojs.bool_to_js x939)
       | None -> ());
      (match x920 with
       | Some x938 -> Ojs.set_prop_ascii x926 "class" (Ojs.string_to_js x938)
       | None -> ());
      Ojs.set_prop_ascii
        x926
        "update"
        (Ojs.fun_to_js 2 (fun (x936 : Ojs.t) (x937 : Ojs.t) ->
           Ojs.bool_to_js
             (x921
                ~update:(View_update.t_of_js x936)
                ~layer:(Dom_html_element.t_of_js x937))));
      (match x922 with
       | Some x935 ->
         Ojs.set_prop_ascii x926 "updateOnDocViewUpdate" (Ojs.bool_to_js x935)
       | None -> ());
      Ojs.set_prop_ascii
        x926
        "markers"
        (Ojs.fun_to_js 1 (fun (x933 : Ojs.t) ->
           Ojs.list_to_js Layer_marker.t_to_js (x923 ~view:(editor_view_of_js x933))));
      (match x924 with
       | Some x930 ->
         Ojs.set_prop_ascii
           x926
           "mount"
           (Ojs.fun_to_js 2 (fun (x931 : Ojs.t) (x932 : Ojs.t) ->
              x930 ~layer:(Dom_html_element.t_of_js x931) ~view:(editor_view_of_js x932)))
       | None -> ());
      (match x925 with
       | Some x927 ->
         Ojs.set_prop_ascii
           x926
           "destroy"
           (Ojs.fun_to_js 2 (fun (x928 : Ojs.t) (x929 : Ojs.t) ->
              x927 ~layer:(Dom_html_element.t_of_js x928) ~view:(editor_view_of_js x929)))
       | None -> ());
      t_of_js x926
    ;;
  end

  let layer : Layer_config.t -> State.Extension.t =
    fun (x940 : Layer_config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "layer"
         [| Layer_config.t_to_js x940 |])
  ;;
end

module Autocomplete = struct
  module Completion = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x942 : Ojs.t) -> x942
    and t_to_js : t -> Ojs.t = fun (x941 : Ojs.t) -> x941

    let create
      :  label:string -> ?detail:string
      -> ?info:[ `Str of string | `Dom of t -> Dom_html_element.t ] -> ?type_:string
      -> ?boost:int
      -> ?apply:
           [ `Str of string
           | `Fn of view:View.Editor_view.t -> completion:t -> from:int -> to_:int -> unit
           ]
      -> unit -> t
      =
      fun ~label:(x943 : string)
        ?detail:(x944 : string option)
        ?info:(x945 : [ `Str of string | `Dom of t -> Dom_html_element.t ] option)
        ?type_:(x946 : string option)
        ?boost:(x947 : int option)
        ?apply:
          (x948 :
             [ `Str of string
             | `Fn of
               view:View.Editor_view.t -> completion:t -> from:int -> to_:int -> unit
             ]
               option)
        () ->
      let x949 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x949 "label" (Ojs.string_to_js x943);
      (match x944 with
       | Some x963 -> Ojs.set_prop_ascii x949 "detail" (Ojs.string_to_js x963)
       | None -> ());
      (match x945 with
       | Some x959 ->
         Ojs.set_prop_ascii
           x949
           "info"
           (match x959 with
            | `Str x960 -> Ojs.string_to_js x960
            | `Dom x961 ->
              Ojs.fun_to_js 1 (fun (x962 : Ojs.t) ->
                Dom_html_element.t_to_js (x961 (t_of_js x962))))
       | None -> ());
      (match x946 with
       | Some x958 -> Ojs.set_prop_ascii x949 "type" (Ojs.string_to_js x958)
       | None -> ());
      (match x947 with
       | Some x957 -> Ojs.set_prop_ascii x949 "boost" (Ojs.int_to_js x957)
       | None -> ());
      (match x948 with
       | Some x950 ->
         Ojs.set_prop_ascii
           x949
           "apply"
           (match x950 with
            | `Str x951 -> Ojs.string_to_js x951
            | `Fn x952 ->
              Ojs.fun_to_js
                4
                (fun (x953 : Ojs.t) (x954 : Ojs.t) (x955 : Ojs.t) (x956 : Ojs.t) ->
                   x952
                     ~view:(View.Editor_view.t_of_js x953)
                     ~completion:(t_of_js x954)
                     ~from:(Ojs.int_of_js x955)
                     ~to_:(Ojs.int_of_js x956)))
       | None -> ());
      t_of_js x949
    ;;

    let label : t -> string =
      fun (x964 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x964) "label")
    ;;

    let type_ : t -> string option =
      fun (x965 : t) ->
      Ojs.option_of_js Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x965) "type")
    ;;
  end

  module CompletionContext = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x968 : Ojs.t) -> x968
    and t_to_js : t -> Ojs.t = fun (x967 : Ojs.t) -> x967

    let state : t -> State.Editor_state.t =
      fun (x969 : t) ->
      State.Editor_state.t_of_js (Ojs.get_prop_ascii (t_to_js x969) "state")
    ;;

    let pos : t -> int =
      fun (x970 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x970) "pos")
    ;;

    let explicit : t -> bool =
      fun (x971 : t) -> Ojs.bool_of_js (Ojs.get_prop_ascii (t_to_js x971) "explicit")
    ;;
  end

  module CompletionResult = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x973 : Ojs.t) -> x973
    and t_to_js : t -> Ojs.t = fun (x972 : Ojs.t) -> x972

    let create
      :  from:int -> ?to_:int -> options:Completion.t list
      -> ?valid_for:
           [ `Regex of RegExp.t
           | `Fn of string -> from:int -> to_:int -> State.Editor_state.t -> bool
           ]
      -> ?filter:bool -> unit -> t
      =
      fun ~from:(x974 : int)
        ?to_:(x975 : int option)
        ~options:(x976 : Completion.t list)
        ?valid_for:
          (x977 :
             [ `Regex of RegExp.t
             | `Fn of string -> from:int -> to_:int -> State.Editor_state.t -> bool
             ]
               option)
        ?filter:(x978 : bool option)
        () ->
      let x979 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x979 "from" (Ojs.int_to_js x974);
      (match x975 with
       | Some x989 -> Ojs.set_prop_ascii x979 "to" (Ojs.int_to_js x989)
       | None -> ());
      Ojs.set_prop_ascii x979 "options" (Ojs.list_to_js Completion.t_to_js x976);
      (match x977 with
       | Some x981 ->
         Ojs.set_prop_ascii
           x979
           "validFor"
           (match x981 with
            | `Regex x982 -> RegExp.t_to_js x982
            | `Fn x983 ->
              Ojs.fun_to_js
                4
                (fun (x984 : Ojs.t) (x985 : Ojs.t) (x986 : Ojs.t) (x987 : Ojs.t) ->
                   Ojs.bool_to_js
                     (x983
                        (Ojs.string_of_js x984)
                        ~from:(Ojs.int_of_js x985)
                        ~to_:(Ojs.int_of_js x986)
                        (State.Editor_state.t_of_js x987))))
       | None -> ());
      (match x978 with
       | Some x980 -> Ojs.set_prop_ascii x979 "filter" (Ojs.bool_to_js x980)
       | None -> ());
      t_of_js x979
    ;;
  end

  module CompletionSource = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x991 : Ojs.t) -> x991
    and t_to_js : t -> Ojs.t = fun (x990 : Ojs.t) -> x990

    let of_sync_fun : (CompletionContext.t -> CompletionResult.t) -> t =
      fun (x992 : CompletionContext.t -> CompletionResult.t) ->
      t_of_js
        (Ojs.fun_to_js 1 (fun (x993 : Ojs.t) ->
           CompletionResult.t_to_js (x992 (CompletionContext.t_of_js x993))))
    ;;

    let of_promise_fun
      : (CompletionContext.t -> (CompletionResult.t, 'e) Promise.t option) -> t
      =
      fun (x994 : CompletionContext.t -> (CompletionResult.t, 'e) Promise.t option) ->
      t_of_js
        (Ojs.fun_to_js 1 (fun (x995 : Ojs.t) ->
           Ojs.option_to_js
             (fun (x996 : (CompletionResult.t, 'e) Promise.t) ->
               Promise.t_to_js CompletionResult.t_to_js Obj.magic x996)
             (x994 (CompletionContext.t_of_js x995))))
    ;;
  end

  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1000 : Ojs.t) -> x1000
    and t_to_js : t -> Ojs.t = fun (x999 : Ojs.t) -> x999

    module Add_to_options_parameters = struct
      type t =
        { render : Completion.t -> State.Editor_state.t -> Dom_html_element.t option
        ; position : int
        }

      let rec t_of_js : Ojs.t -> t =
        fun (x1005 : Ojs.t) ->
        { render =
            (fun (x1006 : Completion.t) (x1007 : State.Editor_state.t) ->
              Ojs.option_of_js
                Dom_html_element.t_of_js
                (Ojs.apply
                   (Ojs.get_prop_ascii x1005 "render")
                   [| Completion.t_to_js x1006; State.Editor_state.t_to_js x1007 |]))
        ; position = Ojs.int_of_js (Ojs.get_prop_ascii x1005 "position")
        }

      and t_to_js : t -> Ojs.t =
        fun (x1001 : t) ->
        Ojs.obj
          [| ( "render"
             , Ojs.fun_to_js 2 (fun (x1002 : Ojs.t) (x1003 : Ojs.t) ->
                 Ojs.option_to_js
                   Dom_html_element.t_to_js
                   (x1001.render
                      (Completion.t_of_js x1002)
                      (State.Editor_state.t_of_js x1003))) )
           ; "position", Ojs.int_to_js x1001.position
          |]
      ;;
    end

    let create
      :  ?activate_on_typing:bool -> ?override:CompletionSource.t list
      -> ?max_rendered_options:int -> ?default_keymap:bool -> ?icons:bool
      -> ?add_to_options:Add_to_options_parameters.t list -> unit -> t
      =
      fun ?activate_on_typing:(x1009 : bool option)
        ?override:(x1010 : CompletionSource.t list option)
        ?max_rendered_options:(x1011 : int option)
        ?default_keymap:(x1012 : bool option)
        ?icons:(x1013 : bool option)
        ?add_to_options:(x1014 : Add_to_options_parameters.t list option)
        () ->
      let x1015 = Ojs.empty_obj () in
      (match x1009 with
       | Some x1023 -> Ojs.set_prop_ascii x1015 "activateOnTyping" (Ojs.bool_to_js x1023)
       | None -> ());
      (match x1010 with
       | Some x1021 ->
         Ojs.set_prop_ascii
           x1015
           "override"
           (Ojs.list_to_js CompletionSource.t_to_js x1021)
       | None -> ());
      (match x1011 with
       | Some x1020 -> Ojs.set_prop_ascii x1015 "maxRenderedOptions" (Ojs.int_to_js x1020)
       | None -> ());
      (match x1012 with
       | Some x1019 -> Ojs.set_prop_ascii x1015 "defaultKeymap" (Ojs.bool_to_js x1019)
       | None -> ());
      (match x1013 with
       | Some x1018 -> Ojs.set_prop_ascii x1015 "icons" (Ojs.bool_to_js x1018)
       | None -> ());
      (match x1014 with
       | Some x1016 ->
         Ojs.set_prop_ascii
           x1015
           "addToOptions"
           (Ojs.list_to_js Add_to_options_parameters.t_to_js x1016)
       | None -> ());
      t_of_js x1015
    ;;
  end

  module Move_completion_selection_by = struct
    type t =
      | Option
      | Page

    let rec t_of_js : Ojs.t -> t =
      fun (x1025 : Ojs.t) ->
      let x1026 = x1025 in
      match Ojs.string_of_js x1026 with
      | "option" -> Option
      | "page" -> Page
      | _ -> assert false

    and t_to_js : t -> Ojs.t =
      fun (x1024 : t) ->
      match x1024 with
      | Option -> Ojs.string_to_js "option"
      | Page -> Ojs.string_to_js "page"
    ;;
  end

  let autocompletion : Config.t -> State.Extension.t =
    fun (x1027 : Config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "autocompletion"
         [| Config.t_to_js x1027 |])
  ;;

  let completion_status : State.Editor_state.t -> string option =
    fun (x1028 : State.Editor_state.t) ->
    Ojs.option_of_js
      Ojs.string_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "completionStatus"
         [| State.Editor_state.t_to_js x1028 |])
  ;;

  let start_completion : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "startCompletion")
  ;;

  let close_completion : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "closeCompletion")
  ;;

  let accept_completion : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "acceptCompletion")
  ;;

  let move_completion_selection
    : forward:bool -> ?by:Move_completion_selection_by.t -> unit -> View.Command.t
    =
    fun ~forward:(x1030 : bool) ?by:(x1031 : Move_completion_selection_by.t option) () ->
    View.Command.t_of_js
      (let x1034 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete"
       in
       Ojs.call
         (Ojs.get_prop_ascii x1034 "moveCompletionSelection")
         "apply"
         [| x1034
          ; (let x1032 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (ignore : _) (Ojs.call x1032 "push" [| Ojs.bool_to_js x1030 |]);
             (match x1031 with
              | Some x1033 ->
                (ignore : _)
                  (Ojs.call x1032 "push" [| Move_completion_selection_by.t_to_js x1033 |])
              | None -> ());
             x1032)
         |])
  ;;

  let completion_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Autocomplete")
         "completionKeymap")
  ;;
end

module Lint = struct
  module Diagnostic = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1037 : Ojs.t) -> x1037
    and t_to_js : t -> Ojs.t = fun (x1036 : Ojs.t) -> x1036

    module Severity = struct
      type t =
        | Error
        | Hint
        | Info
        | Warning

      let rec t_of_js : Ojs.t -> t =
        fun (x1039 : Ojs.t) ->
        let x1040 = x1039 in
        match Ojs.string_of_js x1040 with
        | "error" -> Error
        | "hint" -> Hint
        | "info" -> Info
        | "warning" -> Warning
        | _ -> assert false

      and t_to_js : t -> Ojs.t =
        fun (x1038 : t) ->
        match x1038 with
        | Error -> Ojs.string_to_js "error"
        | Hint -> Ojs.string_to_js "hint"
        | Info -> Ojs.string_to_js "info"
        | Warning -> Ojs.string_to_js "warning"
      ;;
    end

    let create
      :  from:int -> to_:int -> severity:Severity.t -> ?mark_class:string
      -> ?source:string -> message:string -> unit -> t
      =
      fun ~from:(x1041 : int)
        ~to_:(x1042 : int)
        ~severity:(x1043 : Severity.t)
        ?mark_class:(x1044 : string option)
        ?source:(x1045 : string option)
        ~message:(x1046 : string)
        () ->
      let x1047 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x1047 "from" (Ojs.int_to_js x1041);
      Ojs.set_prop_ascii x1047 "to" (Ojs.int_to_js x1042);
      Ojs.set_prop_ascii x1047 "severity" (Severity.t_to_js x1043);
      (match x1044 with
       | Some x1049 -> Ojs.set_prop_ascii x1047 "markClass" (Ojs.string_to_js x1049)
       | None -> ());
      (match x1045 with
       | Some x1048 -> Ojs.set_prop_ascii x1047 "source" (Ojs.string_to_js x1048)
       | None -> ());
      Ojs.set_prop_ascii x1047 "message" (Ojs.string_to_js x1046);
      t_of_js x1047
    ;;
  end

  module Lint_source = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1051 : Ojs.t) -> x1051
    and t_to_js : t -> Ojs.t = fun (x1050 : Ojs.t) -> x1050

    let of_sync_fun : (View.Editor_view.t -> Diagnostic.t list) -> t =
      fun (x1052 : View.Editor_view.t -> Diagnostic.t list) ->
      t_of_js
        (Ojs.fun_to_js 1 (fun (x1053 : Ojs.t) ->
           Ojs.list_to_js Diagnostic.t_to_js (x1052 (View.Editor_view.t_of_js x1053))))
    ;;
  end

  let set_diagnostics
    :  state:State.Editor_state.t -> diagnostics:Diagnostic.t list
    -> State.Transaction_spec.t
    =
    fun ~state:(x1055 : State.Editor_state.t) ~diagnostics:(x1056 : Diagnostic.t list) ->
    State.Transaction_spec.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lint")
         "setDiagnostics"
         [| State.Editor_state.t_to_js x1055; Ojs.list_to_js Diagnostic.t_to_js x1056 |])
  ;;

  let diagnostic_count : State.Editor_state.t -> int =
    fun (x1058 : State.Editor_state.t) ->
    Ojs.int_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lint")
         "diagnosticCount"
         [| State.Editor_state.t_to_js x1058 |])
  ;;

  let lint_gutter : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lint")
         "lintGutter"
         [||])
  ;;

  let lint_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lint")
         "lintKeymap")
  ;;

  let linter : Lint_source.t -> State.Extension.t =
    fun (x1060 : Lint_source.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lint")
         "linter"
         [| Lint_source.t_to_js x1060 |])
  ;;

  let force_linting : View.Editor_view.t -> unit =
    fun (x1061 : View.Editor_view.t) ->
    (ignore : _)
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lint")
         "forceLinting"
         [| View.Editor_view.t_to_js x1061 |])
  ;;
end

module Commands = struct
  let standard_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "standardKeymap")
  ;;

  let default_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "defaultKeymap")
  ;;

  let emacs_style_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "emacsStyleKeymap")
  ;;

  let cursor_char_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorCharLeft")
  ;;

  let select_char_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectCharLeft")
  ;;

  let cursor_group_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorGroupLeft")
  ;;

  let select_group_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectGroupLeft")
  ;;

  let cursor_char_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorCharRight")
  ;;

  let select_char_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectCharRight")
  ;;

  let cursor_group_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorGroupRight")
  ;;

  let select_group_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectGroupRight")
  ;;

  let cursor_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineUp")
  ;;

  let select_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineUp")
  ;;

  let cursor_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineDown")
  ;;

  let select_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineDown")
  ;;

  let cursor_page_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorPageUp")
  ;;

  let select_page_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectPageUp")
  ;;

  let cursor_page_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorPageDown")
  ;;

  let select_page_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectPageDown")
  ;;

  let cursor_line_boundary_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineBoundaryBackward")
  ;;

  let select_line_boundary_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineBoundaryBackward")
  ;;

  let cursor_doc_start : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorDocStart")
  ;;

  let select_doc_start : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectDocStart")
  ;;

  let cursor_line_boundary_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorLineBoundaryForward")
  ;;

  let select_line_boundary_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLineBoundaryForward")
  ;;

  let cursor_doc_end : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorDocEnd")
  ;;

  let select_doc_end : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectDocEnd")
  ;;

  let insert_newline_and_indent : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "insertNewlineAndIndent")
  ;;

  let insert_blank_line : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "insertBlankLine")
  ;;

  let select_all : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectAll")
  ;;

  let delete_char_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteCharBackward")
  ;;

  let delete_char_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteCharForward")
  ;;

  let delete_group_backward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteGroupBackward")
  ;;

  let delete_group_forward : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteGroupForward")
  ;;

  let cursor_syntax_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorSyntaxLeft")
  ;;

  let select_syntax_left : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectSyntaxLeft")
  ;;

  let cursor_syntax_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorSyntaxRight")
  ;;

  let select_syntax_right : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectSyntaxRight")
  ;;

  let move_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "moveLineUp")
  ;;

  let copy_line_up : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "copyLineUp")
  ;;

  let move_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "moveLineDown")
  ;;

  let copy_line_down : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "copyLineDown")
  ;;

  let simplify_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "simplifySelection")
  ;;

  let select_line : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectLine")
  ;;

  let select_parent_syntax : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "selectParentSyntax")
  ;;

  let indent_less : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "indentLess")
  ;;

  let indent_more : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "indentMore")
  ;;

  let indent_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "indentSelection")
  ;;

  let delete_line : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "deleteLine")
  ;;

  let cursor_matching_bracket : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "cursorMatchingBracket")
  ;;

  let toggle_comment : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "toggleComment")
  ;;
end

module Gutter = struct
  module Block_info = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1066 : Ojs.t) -> x1066
    and t_to_js : t -> Ojs.t = fun (x1065 : Ojs.t) -> x1065

    let from : t -> int =
      fun (x1067 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1067) "from")
    ;;

    let length : t -> int =
      fun (x1068 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1068) "length")
    ;;

    let top : t -> int =
      fun (x1069 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1069) "top")
    ;;

    let height : t -> int =
      fun (x1070 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1070) "height")
    ;;

    let to_ : t -> int =
      fun (x1071 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1071) "to")
    ;;

    let bottom : t -> int =
      fun (x1072 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1072) "bottom")
    ;;
  end

  module Line_numbers_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1074 : Ojs.t) -> x1074
    and t_to_js : t -> Ojs.t = fun (x1073 : Ojs.t) -> x1073

    module Dom_event_handlers = struct
      type t = Ojs.t

      let rec t_of_js : Ojs.t -> t = fun (x1076 : Ojs.t) -> x1076
      and t_to_js : t -> Ojs.t = fun (x1075 : Ojs.t) -> x1075

      let create : ?mousedown:(View.Editor_view.t -> Block_info.t -> unit) -> unit -> t =
        fun ?mousedown:(x1077 : (View.Editor_view.t -> Block_info.t -> unit) option) () ->
        let x1078 = Ojs.empty_obj () in
        (match x1077 with
         | Some x1079 ->
           Ojs.set_prop_ascii
             x1078
             "mousedown"
             (Ojs.fun_to_js 2 (fun (x1080 : Ojs.t) (x1081 : Ojs.t) ->
                x1079 (View.Editor_view.t_of_js x1080) (Block_info.t_of_js x1081)))
         | None -> ());
        t_of_js x1078
      ;;
    end

    let create
      :  ?format_number:(int -> State.Editor_state.t -> string)
      -> ?dom_event_handlers:Dom_event_handlers.t -> unit -> t
      =
      fun ?format_number:(x1082 : (int -> State.Editor_state.t -> string) option)
        ?dom_event_handlers:(x1083 : Dom_event_handlers.t option)
        () ->
      let x1084 = Ojs.empty_obj () in
      (match x1082 with
       | Some x1086 ->
         Ojs.set_prop_ascii
           x1084
           "formatNumber"
           (Ojs.fun_to_js 2 (fun (x1087 : Ojs.t) (x1088 : Ojs.t) ->
              Ojs.string_to_js
                (x1086 (Ojs.int_of_js x1087) (State.Editor_state.t_of_js x1088))))
       | None -> ());
      (match x1083 with
       | Some x1085 ->
         Ojs.set_prop_ascii x1084 "domEventHandlers" (Dom_event_handlers.t_to_js x1085)
       | None -> ());
      t_of_js x1084
    ;;
  end

  let line_numbers : Line_numbers_config.t -> State.Extension.t =
    fun (x1089 : Line_numbers_config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "lineNumbers"
         [| Line_numbers_config.t_to_js x1089 |])
  ;;

  let highlight_active_line_gutter : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "highlightActiveLineGutter"
         [||])
  ;;

  module Gutter_marker = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1091 : Ojs.t) -> x1091
    and t_to_js : t -> Ojs.t = fun (x1090 : Ojs.t) -> x1090
  end

  module Gutter_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1093 : Ojs.t) -> x1093
    and t_to_js : t -> Ojs.t = fun (x1092 : Ojs.t) -> x1092

    let create
      :  ?class_:string -> ?render_empty_elements:bool
      -> ?markers:(View.Editor_view.t -> Gutter_marker.t State.Range_set.t)
      -> ?line_marker:(View.Editor_view.t -> Block_info.t -> Gutter_marker.t option)
      -> ?line_marker_change:(View.View_update.t -> bool)
      -> ?initial_spacer:(View.Editor_view.t -> Gutter_marker.t)
      -> ?update_spacer:
           (spacer:Gutter_marker.t -> update:View.View_update.t -> Gutter_marker.t)
      -> ?dom_event_handlers:Line_numbers_config.Dom_event_handlers.t -> unit -> t
      =
      fun ?class_:(x1094 : string option)
        ?render_empty_elements:(x1095 : bool option)
        ?markers:
          (x1096 : (View.Editor_view.t -> Gutter_marker.t State.Range_set.t) option)
        ?line_marker:
          (x1097 : (View.Editor_view.t -> Block_info.t -> Gutter_marker.t option) option)
        ?line_marker_change:(x1098 : (View.View_update.t -> bool) option)
        ?initial_spacer:(x1099 : (View.Editor_view.t -> Gutter_marker.t) option)
        ?update_spacer:
          (x1100 :
             (spacer:Gutter_marker.t -> update:View.View_update.t -> Gutter_marker.t)
               option)
        ?dom_event_handlers:(x1101 : Line_numbers_config.Dom_event_handlers.t option)
        () ->
      let x1102 = Ojs.empty_obj () in
      (match x1094 with
       | Some x1119 -> Ojs.set_prop_ascii x1102 "class" (Ojs.string_to_js x1119)
       | None -> ());
      (match x1095 with
       | Some x1118 ->
         Ojs.set_prop_ascii x1102 "renderEmptyElements" (Ojs.bool_to_js x1118)
       | None -> ());
      (match x1096 with
       | Some x1115 ->
         Ojs.set_prop_ascii
           x1102
           "markers"
           (Ojs.fun_to_js 1 (fun (x1116 : Ojs.t) ->
              State.Range_set.t_to_js
                Gutter_marker.t_to_js
                (x1115 (View.Editor_view.t_of_js x1116))))
       | None -> ());
      (match x1097 with
       | Some x1111 ->
         Ojs.set_prop_ascii
           x1102
           "lineMarker"
           (Ojs.fun_to_js 2 (fun (x1112 : Ojs.t) (x1113 : Ojs.t) ->
              Ojs.option_to_js
                Gutter_marker.t_to_js
                (x1111 (View.Editor_view.t_of_js x1112) (Block_info.t_of_js x1113))))
       | None -> ());
      (match x1098 with
       | Some x1109 ->
         Ojs.set_prop_ascii
           x1102
           "lineMarkerChange"
           (Ojs.fun_to_js 1 (fun (x1110 : Ojs.t) ->
              Ojs.bool_to_js (x1109 (View.View_update.t_of_js x1110))))
       | None -> ());
      (match x1099 with
       | Some x1107 ->
         Ojs.set_prop_ascii
           x1102
           "initialSpacer"
           (Ojs.fun_to_js 1 (fun (x1108 : Ojs.t) ->
              Gutter_marker.t_to_js (x1107 (View.Editor_view.t_of_js x1108))))
       | None -> ());
      (match x1100 with
       | Some x1104 ->
         Ojs.set_prop_ascii
           x1102
           "updateSpacer"
           (Ojs.fun_to_js 2 (fun (x1105 : Ojs.t) (x1106 : Ojs.t) ->
              Gutter_marker.t_to_js
                (x1104
                   ~spacer:(Gutter_marker.t_of_js x1105)
                   ~update:(View.View_update.t_of_js x1106))))
       | None -> ());
      (match x1101 with
       | Some x1103 ->
         Ojs.set_prop_ascii
           x1102
           "domEventHandlers"
           (Line_numbers_config.Dom_event_handlers.t_to_js x1103)
       | None -> ());
      t_of_js x1102
    ;;
  end

  let gutter : Gutter_config.t -> State.Extension.t =
    fun (x1120 : Gutter_config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "View")
         "gutter"
         [| Gutter_config.t_to_js x1120 |])
  ;;
end

module History = struct
  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1122 : Ojs.t) -> x1122
    and t_to_js : t -> Ojs.t = fun (x1121 : Ojs.t) -> x1121

    let create : ?min_depth:int -> ?new_group_delay:int -> unit -> t =
      fun ?min_depth:(x1123 : int option) ?new_group_delay:(x1124 : int option) () ->
      let x1125 = Ojs.empty_obj () in
      (match x1123 with
       | Some x1127 -> Ojs.set_prop_ascii x1125 "minDepth" (Ojs.int_to_js x1127)
       | None -> ());
      (match x1124 with
       | Some x1126 -> Ojs.set_prop_ascii x1125 "newGroupDelay" (Ojs.int_to_js x1126)
       | None -> ());
      t_of_js x1125
    ;;
  end

  let history : Config.t -> State.Extension.t =
    fun (x1128 : Config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "history"
         [| Config.t_to_js x1128 |])
  ;;

  let undo : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "undo")
  ;;

  let redo : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "redo")
  ;;

  let undo_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "undoSelection")
  ;;

  let redo_selection : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "redoSelection")
  ;;

  let history_keymap : View.Key_binding.t list =
    Ojs.list_of_js
      View.Key_binding.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Commands")
         "historyKeymap")
  ;;
end

module Search = struct
  module Config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1131 : Ojs.t) -> x1131
    and t_to_js : t -> Ojs.t = fun (x1130 : Ojs.t) -> x1130

    let create : ?top:bool -> ?match_case:bool -> unit -> t =
      fun ?top:(x1132 : bool option) ?match_case:(x1133 : bool option) () ->
      let x1134 = Ojs.empty_obj () in
      (match x1132 with
       | Some x1136 -> Ojs.set_prop_ascii x1134 "top" (Ojs.bool_to_js x1136)
       | None -> ());
      (match x1133 with
       | Some x1135 -> Ojs.set_prop_ascii x1134 "matchCase" (Ojs.bool_to_js x1135)
       | None -> ());
      t_of_js x1134
    ;;
  end

  let search : Config.t -> State.Extension.t =
    fun (x1137 : Config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "search"
         [| Config.t_to_js x1137 |])
  ;;

  let find_next : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "findNext")
  ;;

  let find_previous : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "findPrevious")
  ;;

  let select_matches : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "selectMatches")
  ;;

  let replace_next : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "replaceNext")
  ;;

  let replace_all : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "replaceAll")
  ;;

  let open_search_panel : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "openSearchPanel")
  ;;

  let close_search_panel : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "closeSearchPanel")
  ;;

  let goto_line : View.Command.t =
    View.Command.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Search")
         "gotoLine")
  ;;
end

module Basic_setup = struct
  let basic_setup : State.Extension.t =
    State.Extension.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Basic_setup")
         "basicSetup")
  ;;

  let minimal_setup : State.Extension.t =
    State.Extension.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Basic_setup")
         "minimalSetup")
  ;;
end

module Language = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1139 : Ojs.t) -> x1139
  and t_to_js : t -> Ojs.t = fun (x1138 : Ojs.t) -> x1138

  let extension : t -> State.Extension.t =
    fun (x1140 : t) ->
    State.Extension.t_of_js (Ojs.get_prop_ascii (t_to_js x1140) "extension")
  ;;
end

module Stream_parser = struct
  module String_stream = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1142 : Ojs.t) -> x1142
    and t_to_js : t -> Ojs.t = fun (x1141 : Ojs.t) -> x1141

    let new_string_stream : string:string -> tab_size:int -> indent_unit:int -> t =
      fun ~string:(x1143 : string) ~tab_size:(x1144 : int) ~indent_unit:(x1145 : int) ->
      t_of_js
        (Ojs.new_obj
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
              "StringStream")
           [| Ojs.string_to_js x1143; Ojs.int_to_js x1144; Ojs.int_to_js x1145 |])
    ;;

    let pos : t -> int =
      fun (x1146 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1146) "pos")
    ;;

    let set_pos : t -> int -> unit =
      fun (x1147 : t) (x1148 : int) ->
      Ojs.set_prop_ascii (t_to_js x1147) "pos" (Ojs.int_to_js x1148)
    ;;

    let start : t -> int =
      fun (x1149 : t) -> Ojs.int_of_js (Ojs.get_prop_ascii (t_to_js x1149) "start")
    ;;

    let string : t -> string =
      fun (x1150 : t) -> Ojs.string_of_js (Ojs.get_prop_ascii (t_to_js x1150) "string")
    ;;

    let eol : t -> bool =
      fun (x1151 : t) -> Ojs.bool_of_js (Ojs.call (t_to_js x1151) "eol" [||])
    ;;

    let sol : t -> bool =
      fun (x1152 : t) -> Ojs.bool_of_js (Ojs.call (t_to_js x1152) "sol" [||])
    ;;

    let peek : t -> string option =
      fun (x1153 : t) ->
      Ojs.option_of_js Ojs.string_of_js (Ojs.call (t_to_js x1153) "peek" [||])
    ;;

    let next : t -> string option =
      fun (x1155 : t) ->
      Ojs.option_of_js Ojs.string_of_js (Ojs.call (t_to_js x1155) "next" [||])
    ;;

    let current : t -> string =
      fun (x1157 : t) -> Ojs.string_of_js (Ojs.call (t_to_js x1157) "current" [||])
    ;;

    let skip_to_end : t -> unit =
      fun (x1158 : t) -> (ignore : _) (Ojs.call (t_to_js x1158) "skipToEnd" [||])
    ;;

    let eat_space : t -> bool =
      fun (x1159 : t) -> Ojs.bool_of_js (Ojs.call (t_to_js x1159) "eatSpace" [||])
    ;;

    let eat : t -> match_:string -> string option =
      fun (x1161 : t) ~match_:(x1160 : string) ->
      Ojs.option_of_js
        Ojs.string_of_js
        (Ojs.call (t_to_js x1161) "eat" [| Ojs.string_to_js x1160 |])
    ;;

    let eat_regex : t -> match_:RegExp.t -> string option =
      fun (x1164 : t) ~match_:(x1163 : RegExp.t) ->
      Ojs.option_of_js
        Ojs.string_of_js
        (Ojs.call (t_to_js x1164) "eat" [| RegExp.t_to_js x1163 |])
    ;;

    let eat_while : t -> match_:string -> bool =
      fun (x1167 : t) ~match_:(x1166 : string) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x1167) "eatWhile" [| Ojs.string_to_js x1166 |])
    ;;

    let eat_while_regex : t -> match_:RegExp.t -> bool =
      fun (x1169 : t) ~match_:(x1168 : RegExp.t) ->
      Ojs.bool_of_js (Ojs.call (t_to_js x1169) "eatWhile" [| RegExp.t_to_js x1168 |])
    ;;

    let match_
      : t -> pattern:string -> ?consume:bool -> ?case_insensitive:bool -> unit -> bool
      =
      fun (x1176 : t)
        ~pattern:(x1170 : string)
        ?consume:(x1171 : bool option)
        ?case_insensitive:(x1172 : bool option)
        () ->
      Ojs.bool_of_js
        (let x1177 = t_to_js x1176 in
         Ojs.call
           (Ojs.get_prop_ascii x1177 "match")
           "apply"
           [| x1177
            ; (let x1173 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x1173 "push" [| Ojs.string_to_js x1170 |]);
               (match x1171 with
                | Some x1175 ->
                  (ignore : _) (Ojs.call x1173 "push" [| Ojs.bool_to_js x1175 |])
                | None -> ());
               (match x1172 with
                | Some x1174 ->
                  (ignore : _) (Ojs.call x1173 "push" [| Ojs.bool_to_js x1174 |])
                | None -> ());
               x1173)
           |])
    ;;

    let match_regex
      :  t -> pattern:RegExp.t -> ?consume:bool -> ?case_insensitive:bool -> unit
      -> string list option
      =
      fun (x1184 : t)
        ~pattern:(x1178 : RegExp.t)
        ?consume:(x1179 : bool option)
        ?case_insensitive:(x1180 : bool option)
        () ->
      Ojs.option_of_js
        (fun (x1186 : Ojs.t) -> Ojs.list_of_js Ojs.string_of_js x1186)
        (let x1185 = t_to_js x1184 in
         Ojs.call
           (Ojs.get_prop_ascii x1185 "match")
           "apply"
           [| x1185
            ; (let x1181 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
               (ignore : _) (Ojs.call x1181 "push" [| RegExp.t_to_js x1178 |]);
               (match x1179 with
                | Some x1183 ->
                  (ignore : _) (Ojs.call x1181 "push" [| Ojs.bool_to_js x1183 |])
                | None -> ());
               (match x1180 with
                | Some x1182 ->
                  (ignore : _) (Ojs.call x1181 "push" [| Ojs.bool_to_js x1182 |])
                | None -> ());
               x1181)
           |])
    ;;
  end

  module Stream_parser = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1189 : Ojs.t) -> x1189
    and t_to_js : t -> Ojs.t = fun (x1188 : Ojs.t) -> x1188

    let create
      :  ?language_data:Ojs.t -> start_state:(unit -> 'state)
      -> token:(String_stream.t -> 'state -> string option) -> unit -> t
      =
      fun ?language_data:(x1190 : Ojs.t option)
        ~start_state:(x1191 : unit -> 'state)
        ~token:(x1192 : String_stream.t -> 'state -> string option)
        () ->
      let x1193 = Ojs.empty_obj () in
      (match x1190 with
       | Some x1197 -> Ojs.set_prop_ascii x1193 "languageData" x1197
       | None -> ());
      Ojs.set_prop_ascii
        x1193
        "startState"
        (Ojs.fun_to_js 1 (fun _ -> Obj.magic (x1191 ())));
      Ojs.set_prop_ascii
        x1193
        "token"
        (Ojs.fun_to_js 2 (fun (x1194 : Ojs.t) (x1195 : Ojs.t) ->
           Ojs.option_to_js
             Ojs.string_to_js
             (x1192 (String_stream.t_of_js x1194) (Obj.magic x1195))));
      t_of_js x1193
    ;;
  end

  module Stream_language = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1199 : Ojs.t) -> x1199
    and t_to_js : t -> Ojs.t = fun (x1198 : Ojs.t) -> x1198

    let define : Stream_parser.t -> t =
      fun (x1200 : Stream_parser.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
              "StreamLanguage")
           "define"
           [| Stream_parser.t_to_js x1200 |])
    ;;

    let to_language : t -> Language.t =
      fun (x1201 : t) -> Language.t_of_js (t_to_js x1201)
    ;;
  end
end

module Mllike = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1203 : Ojs.t) -> x1203
  and t_to_js : t -> Ojs.t = fun (x1202 : Ojs.t) -> x1202

  let fsharp : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_mllike")
         "fSharp")
  ;;

  let sml : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_mllike")
         "sml")
  ;;
end

module Diff = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1205 : Ojs.t) -> x1205
  and t_to_js : t -> Ojs.t = fun (x1204 : Ojs.t) -> x1204

  let diff : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_diff")
         "diff")
  ;;
end

module Commonlisp = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1207 : Ojs.t) -> x1207
  and t_to_js : t -> Ojs.t = fun (x1206 : Ojs.t) -> x1206

  let common_lisp : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_commonlisp")
         "commonLisp")
  ;;
end

module Scheme = struct
  open Stream_parser

  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1209 : Ojs.t) -> x1209
  and t_to_js : t -> Ojs.t = fun (x1208 : Ojs.t) -> x1208

  let scheme : Stream_parser.t =
    Stream_parser.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Legacy_modes_scheme")
         "scheme")
  ;;
end

module Lezer_highlight = struct
  module Highlighter = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1211 : Ojs.t) -> x1211
    and t_to_js : t -> Ojs.t = fun (x1210 : Ojs.t) -> x1210
  end

  module Tag = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1213 : Ojs.t) -> x1213
    and t_to_js : t -> Ojs.t = fun (x1212 : Ojs.t) -> x1212
  end

  module Tags = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1215 : Ojs.t) -> x1215
    and t_to_js : t -> Ojs.t = fun (x1214 : Ojs.t) -> x1214

    let arithmetic_operator : t -> Tag.t =
      fun (x1216 : t) ->
      Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1216) "arithmeticOperator")
    ;;

    let atom : t -> Tag.t =
      fun (x1217 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1217) "atom")
    ;;

    let bool : t -> Tag.t =
      fun (x1218 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1218) "bool")
    ;;

    let block_comment : t -> Tag.t =
      fun (x1219 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1219) "blockComment")
    ;;

    let bracket : t -> Tag.t =
      fun (x1220 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1220) "bracket")
    ;;

    let character : t -> Tag.t =
      fun (x1221 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1221) "character")
    ;;

    let comment : t -> Tag.t =
      fun (x1222 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1222) "comment")
    ;;

    let compare_operator : t -> Tag.t =
      fun (x1223 : t) ->
      Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1223) "compareOperator")
    ;;

    let content : t -> Tag.t =
      fun (x1224 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1224) "content")
    ;;

    let control_keyword : t -> Tag.t =
      fun (x1225 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1225) "controlKeyword")
    ;;

    let definition_keyword : t -> Tag.t =
      fun (x1226 : t) ->
      Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1226) "definitionKeyword")
    ;;

    let doc_comment : t -> Tag.t =
      fun (x1227 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1227) "docComment")
    ;;

    let float : t -> Tag.t =
      fun (x1228 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1228) "float")
    ;;

    let integer : t -> Tag.t =
      fun (x1229 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1229) "integer")
    ;;

    let invalid : t -> Tag.t =
      fun (x1230 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1230) "invalid")
    ;;

    let keyword : t -> Tag.t =
      fun (x1231 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1231) "keyword")
    ;;

    let line_comment : t -> Tag.t =
      fun (x1232 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1232) "lineComment")
    ;;

    let literal : t -> Tag.t =
      fun (x1233 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1233) "literal")
    ;;

    let logic_operator : t -> Tag.t =
      fun (x1234 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1234) "logicOperator")
    ;;

    let macro_name : t -> Tag.t =
      fun (x1235 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1235) "macroName")
    ;;

    let name : t -> Tag.t =
      fun (x1236 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1236) "name")
    ;;

    let number : t -> Tag.t =
      fun (x1237 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1237) "number")
    ;;

    let operator : t -> Tag.t =
      fun (x1238 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1238) "operator")
    ;;

    let paren : t -> Tag.t =
      fun (x1239 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1239) "paren")
    ;;

    let property_name : t -> Tag.t =
      fun (x1240 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1240) "propertyName")
    ;;

    let punctuation : t -> Tag.t =
      fun (x1241 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1241) "punctuation")
    ;;

    let string : t -> Tag.t =
      fun (x1242 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1242) "string")
    ;;

    let type_name : t -> Tag.t =
      fun (x1243 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1243) "typeName")
    ;;

    let variable_name : t -> Tag.t =
      fun (x1244 : t) -> Tag.t_of_js (Ojs.get_prop_ascii (t_to_js x1244) "variableName")
    ;;

    let special : t -> Tag.t -> Tag.t =
      fun (x1246 : t) (x1245 : Tag.t) ->
      Tag.t_of_js (Ojs.call (t_to_js x1246) "special" [| Tag.t_to_js x1245 |])
    ;;
  end

  let tags : Tags.t =
    Tags.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Lezer_highlight")
         "tags")
  ;;

  let class_highlighter : Highlighter.t =
    Highlighter.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Lezer_highlight")
         "classHighlighter")
  ;;
end

module Highlight = struct
  module Syntax_highlighting_options = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1248 : Ojs.t) -> x1248
    and t_to_js : t -> Ojs.t = fun (x1247 : Ojs.t) -> x1247

    let create : ?fallback:bool -> unit -> t =
      fun ?fallback:(x1249 : bool option) () ->
      let x1250 = Ojs.empty_obj () in
      (match x1249 with
       | Some x1251 -> Ojs.set_prop_ascii x1250 "fallback" (Ojs.bool_to_js x1251)
       | None -> ());
      t_of_js x1250
    ;;
  end

  module Highlight_style = struct
    let define : specs:Ojs.t list -> Lezer_highlight.Highlighter.t =
      fun ~specs:(x1252 : Ojs.t list) ->
      Lezer_highlight.Highlighter.t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
              "HighlightStyle")
           "define"
           [| Ojs.list_to_js (fun (x1253 : Ojs.t) -> x1253) x1252 |])
    ;;
  end

  let syntax_highlighting
    :  Lezer_highlight.Highlighter.t -> ?options:Syntax_highlighting_options.t -> unit
    -> State.Extension.t
    =
    fun (x1254 : Lezer_highlight.Highlighter.t)
      ?options:(x1255 : Syntax_highlighting_options.t option)
      () ->
    State.Extension.t_of_js
      (let x1258 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language"
       in
       Ojs.call
         (Ojs.get_prop_ascii x1258 "syntaxHighlighting")
         "apply"
         [| x1258
          ; (let x1256 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (ignore : _)
               (Ojs.call x1256 "push" [| Lezer_highlight.Highlighter.t_to_js x1254 |]);
             (match x1255 with
              | Some x1257 ->
                (ignore : _)
                  (Ojs.call x1256 "push" [| Syntax_highlighting_options.t_to_js x1257 |])
              | None -> ());
             x1256)
         |])
  ;;

  let highlighting_for
    : State.Editor_state.t -> tags:Lezer_highlight.Tag.t list -> string option
    =
    fun (x1259 : State.Editor_state.t) ~tags:(x1260 : Lezer_highlight.Tag.t list) ->
    Ojs.option_of_js
      Ojs.string_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "highlightingFor"
         [| State.Editor_state.t_to_js x1259
          ; Ojs.list_to_js Lezer_highlight.Tag.t_to_js x1260
         |])
  ;;

  let default_highlight_style : Lezer_highlight.Highlighter.t =
    Lezer_highlight.Highlighter.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "defaultHighlightStyle")
  ;;
end

module Folding = struct
  module Fold = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1264 : Ojs.t) -> x1264
    and t_to_js : t -> Ojs.t = fun (x1263 : Ojs.t) -> x1263

    let create : from:int -> to_:int -> t =
      fun ~from:(x1265 : int) ~to_:(x1266 : int) ->
      let x1267 = Ojs.empty_obj () in
      Ojs.set_prop_ascii x1267 "from" (Ojs.int_to_js x1265);
      Ojs.set_prop_ascii x1267 "to" (Ojs.int_to_js x1266);
      t_of_js x1267
    ;;
  end

  module Fold_service_callback = struct
    type t = State.Editor_state.t -> line_start:int -> line_end:int -> Fold.t option

    let rec t_of_js : Ojs.t -> t =
      fun (x1273 : Ojs.t)
        (x1274 : State.Editor_state.t)
        ~line_start:(x1275 : int)
        ~line_end:(x1276 : int) ->
      Ojs.option_of_js
        Fold.t_of_js
        (Ojs.apply
           x1273
           [| State.Editor_state.t_to_js x1274
            ; Ojs.int_to_js x1275
            ; Ojs.int_to_js x1276
           |])

    and t_to_js : t -> Ojs.t =
      fun (x1268 :
            State.Editor_state.t -> line_start:int -> line_end:int -> Fold.t option) ->
      Ojs.fun_to_js 3 (fun (x1269 : Ojs.t) (x1270 : Ojs.t) (x1271 : Ojs.t) ->
        Ojs.option_to_js
          Fold.t_to_js
          (x1268
             (State.Editor_state.t_of_js x1269)
             ~line_start:(Ojs.int_of_js x1270)
             ~line_end:(Ojs.int_of_js x1271)))
    ;;
  end

  let fold_service : (Fold_service_callback.t, Fold_service_callback.t) State.Facet.t =
    State.Facet.t_of_js
      Fold_service_callback.t_of_js
      Fold_service_callback.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "foldService")
  ;;

  let fold_gutter : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "foldGutter"
         [||])
  ;;
end

module Matchbrackets = struct
  let bracket_matching : unit -> State.Extension.t =
    fun () ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Language")
         "bracketMatching"
         [||])
  ;;
end

module Lang_markdown = struct
  let markdown : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_markdown")
         "markdown"
         [||])
  ;;
end

module Lang_python = struct
  let python : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_python")
         "python"
         [||])
  ;;
end

module Lang_sql = struct
  module Sql_dialect_spec = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1281 : Ojs.t) -> x1281
    and t_to_js : t -> Ojs.t = fun (x1280 : Ojs.t) -> x1280

    let create
      :  ?keywords:string -> ?builtin:string -> ?types:string -> ?backslash_escapes:string
      -> ?hash_comments:bool -> ?slash_comments:bool -> ?space_after_dashes:bool
      -> ?double_quoted_strings:bool -> ?char_set_casts:bool -> ?operator_chars:string
      -> ?special_var:string -> ?identifier_quotes:string -> unit -> t
      =
      fun ?keywords:(x1282 : string option)
        ?builtin:(x1283 : string option)
        ?types:(x1284 : string option)
        ?backslash_escapes:(x1285 : string option)
        ?hash_comments:(x1286 : bool option)
        ?slash_comments:(x1287 : bool option)
        ?space_after_dashes:(x1288 : bool option)
        ?double_quoted_strings:(x1289 : bool option)
        ?char_set_casts:(x1290 : bool option)
        ?operator_chars:(x1291 : string option)
        ?special_var:(x1292 : string option)
        ?identifier_quotes:(x1293 : string option)
        () ->
      let x1294 = Ojs.empty_obj () in
      (match x1282 with
       | Some x1306 -> Ojs.set_prop_ascii x1294 "keywords" (Ojs.string_to_js x1306)
       | None -> ());
      (match x1283 with
       | Some x1305 -> Ojs.set_prop_ascii x1294 "builtin" (Ojs.string_to_js x1305)
       | None -> ());
      (match x1284 with
       | Some x1304 -> Ojs.set_prop_ascii x1294 "types" (Ojs.string_to_js x1304)
       | None -> ());
      (match x1285 with
       | Some x1303 ->
         Ojs.set_prop_ascii x1294 "backslashEscapes" (Ojs.string_to_js x1303)
       | None -> ());
      (match x1286 with
       | Some x1302 -> Ojs.set_prop_ascii x1294 "hashComments" (Ojs.bool_to_js x1302)
       | None -> ());
      (match x1287 with
       | Some x1301 -> Ojs.set_prop_ascii x1294 "slashComments" (Ojs.bool_to_js x1301)
       | None -> ());
      (match x1288 with
       | Some x1300 -> Ojs.set_prop_ascii x1294 "spaceAfterDashes" (Ojs.bool_to_js x1300)
       | None -> ());
      (match x1289 with
       | Some x1299 ->
         Ojs.set_prop_ascii x1294 "doubleQuotedStrings" (Ojs.bool_to_js x1299)
       | None -> ());
      (match x1290 with
       | Some x1298 -> Ojs.set_prop_ascii x1294 "charSetCasts" (Ojs.bool_to_js x1298)
       | None -> ());
      (match x1291 with
       | Some x1297 -> Ojs.set_prop_ascii x1294 "operatorChars" (Ojs.string_to_js x1297)
       | None -> ());
      (match x1292 with
       | Some x1296 -> Ojs.set_prop_ascii x1294 "specialVar" (Ojs.string_to_js x1296)
       | None -> ());
      (match x1293 with
       | Some x1295 ->
         Ojs.set_prop_ascii x1294 "identifierQuotes" (Ojs.string_to_js x1295)
       | None -> ());
      t_of_js x1294
    ;;
  end

  module Sql_dialect = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1308 : Ojs.t) -> x1308
    and t_to_js : t -> Ojs.t = fun (x1307 : Ojs.t) -> x1307

    let define : spec:Sql_dialect_spec.t -> t =
      fun ~spec:(x1309 : Sql_dialect_spec.t) ->
      t_of_js
        (Ojs.call
           (Ojs.get_prop_ascii
              (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_sql")
              "SQLDialect")
           "define"
           [| Sql_dialect_spec.t_to_js x1309 |])
    ;;
  end

  module Sql_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1311 : Ojs.t) -> x1311
    and t_to_js : t -> Ojs.t = fun (x1310 : Ojs.t) -> x1310

    let create
      :  ?dialect:Sql_dialect.t -> ?upper_case_keywords:bool
      -> ?tables:Autocomplete.Completion.t list -> ?default_table:int -> ?schema:Ojs.t
      -> unit -> t
      =
      fun ?dialect:(x1312 : Sql_dialect.t option)
        ?upper_case_keywords:(x1313 : bool option)
        ?tables:(x1314 : Autocomplete.Completion.t list option)
        ?default_table:(x1315 : int option)
        ?schema:(x1316 : Ojs.t option)
        () ->
      let x1317 = Ojs.empty_obj () in
      (match x1312 with
       | Some x1323 -> Ojs.set_prop_ascii x1317 "dialect" (Sql_dialect.t_to_js x1323)
       | None -> ());
      (match x1313 with
       | Some x1322 -> Ojs.set_prop_ascii x1317 "upperCaseKeywords" (Ojs.bool_to_js x1322)
       | None -> ());
      (match x1314 with
       | Some x1320 ->
         Ojs.set_prop_ascii
           x1317
           "tables"
           (Ojs.list_to_js Autocomplete.Completion.t_to_js x1320)
       | None -> ());
      (match x1315 with
       | Some x1319 -> Ojs.set_prop_ascii x1317 "defaultTable" (Ojs.int_to_js x1319)
       | None -> ());
      (match x1316 with
       | Some x1318 -> Ojs.set_prop_ascii x1317 "schema" x1318
       | None -> ());
      t_of_js x1317
    ;;
  end

  let postgresql : Sql_dialect.t =
    Sql_dialect.t_of_js
      (Ojs.get_prop_ascii
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_sql")
         "PostgreSQL")
  ;;

  let sql : ?config:Sql_config.t -> unit -> Language.t =
    fun ?config:(x1324 : Sql_config.t option) () ->
    Language.t_of_js
      (let x1327 =
         Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_sql"
       in
       Ojs.call
         (Ojs.get_prop_ascii x1327 "sql")
         "apply"
         [| x1327
          ; (let x1325 = Ojs.new_obj (Ojs.get_prop_ascii Ojs.global "Array") [||] in
             (match x1324 with
              | Some x1326 ->
                (ignore : _) (Ojs.call x1325 "push" [| Sql_config.t_to_js x1326 |])
              | None -> ());
             x1325)
         |])
  ;;
end

module Lang_html = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1329 : Ojs.t) -> x1329
  and t_to_js : t -> Ojs.t = fun (x1328 : Ojs.t) -> x1328

  let html : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_html")
         "html"
         [||])
  ;;
end

module Lang_css = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1331 : Ojs.t) -> x1331
  and t_to_js : t -> Ojs.t = fun (x1330 : Ojs.t) -> x1330

  let css : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_css")
         "css"
         [||])
  ;;
end

module Lang_javascript = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1333 : Ojs.t) -> x1333
  and t_to_js : t -> Ojs.t = fun (x1332 : Ojs.t) -> x1332

  let javascript : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii
            (Ojs.get_prop_ascii Ojs.global "codemirror")
            "Lang_javascript")
         "javascript"
         [||])
  ;;
end

module Lang_php = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1335 : Ojs.t) -> x1335
  and t_to_js : t -> Ojs.t = fun (x1334 : Ojs.t) -> x1334

  let php : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_php")
         "php"
         [||])
  ;;
end

module Lang_rust = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1337 : Ojs.t) -> x1337
  and t_to_js : t -> Ojs.t = fun (x1336 : Ojs.t) -> x1336

  let rust : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_rust")
         "rust"
         [||])
  ;;
end

module Lang_xml = struct
  type t = Ojs.t

  let rec t_of_js : Ojs.t -> t = fun (x1339 : Ojs.t) -> x1339
  and t_to_js : t -> Ojs.t = fun (x1338 : Ojs.t) -> x1338

  let xml : unit -> Language.t =
    fun () ->
    Language.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Lang_xml")
         "xml"
         [||])
  ;;
end

module Merge = struct
  module Unified_merge_config = struct
    type t = Ojs.t

    let rec t_of_js : Ojs.t -> t = fun (x1341 : Ojs.t) -> x1341
    and t_to_js : t -> Ojs.t = fun (x1340 : Ojs.t) -> x1340

    let create_from_string
      :  ?highlight_changes:bool -> ?gutter:bool -> ?syntax_highlight_deletions:bool
      -> ?merge_controls:bool -> string -> t
      =
      fun ?highlight_changes:(x1342 : bool option)
        ?gutter:(x1343 : bool option)
        ?syntax_highlight_deletions:(x1344 : bool option)
        ?merge_controls:(x1345 : bool option)
        (x1346 : string) ->
      let x1347 = Ojs.empty_obj () in
      (match x1342 with
       | Some x1351 -> Ojs.set_prop_ascii x1347 "highlightChanges" (Ojs.bool_to_js x1351)
       | None -> ());
      (match x1343 with
       | Some x1350 -> Ojs.set_prop_ascii x1347 "gutter" (Ojs.bool_to_js x1350)
       | None -> ());
      (match x1344 with
       | Some x1349 ->
         Ojs.set_prop_ascii x1347 "syntaxHighlightDeletions" (Ojs.bool_to_js x1349)
       | None -> ());
      (match x1345 with
       | Some x1348 -> Ojs.set_prop_ascii x1347 "mergeControls" (Ojs.bool_to_js x1348)
       | None -> ());
      Ojs.set_prop_ascii x1347 "original" (Ojs.string_to_js x1346);
      t_of_js x1347
    ;;

    let create_from_text
      :  ?highlight_changes:bool -> ?gutter:bool -> ?syntax_highlight_deletions:bool
      -> ?merge_controls:bool -> Text.Text.t -> t
      =
      fun ?highlight_changes:(x1352 : bool option)
        ?gutter:(x1353 : bool option)
        ?syntax_highlight_deletions:(x1354 : bool option)
        ?merge_controls:(x1355 : bool option)
        (x1356 : Text.Text.t) ->
      let x1357 = Ojs.empty_obj () in
      (match x1352 with
       | Some x1361 -> Ojs.set_prop_ascii x1357 "highlightChanges" (Ojs.bool_to_js x1361)
       | None -> ());
      (match x1353 with
       | Some x1360 -> Ojs.set_prop_ascii x1357 "gutter" (Ojs.bool_to_js x1360)
       | None -> ());
      (match x1354 with
       | Some x1359 ->
         Ojs.set_prop_ascii x1357 "syntaxHighlightDeletions" (Ojs.bool_to_js x1359)
       | None -> ());
      (match x1355 with
       | Some x1358 -> Ojs.set_prop_ascii x1357 "mergeControls" (Ojs.bool_to_js x1358)
       | None -> ());
      Ojs.set_prop_ascii x1357 "original" (Text.Text.t_to_js x1356);
      t_of_js x1357
    ;;
  end

  let unified_merge_view : Unified_merge_config.t -> State.Extension.t =
    fun (x1362 : Unified_merge_config.t) ->
    State.Extension.t_of_js
      (Ojs.call
         (Ojs.get_prop_ascii (Ojs.get_prop_ascii Ojs.global "codemirror") "Merge")
         "unifiedMergeView"
         [| Unified_merge_config.t_to_js x1362 |])
  ;;
end
